<!DOCTYPE html>
<html >
<head>
<h1 id="sec113" class="chapter">Chapitre 14  Équations et systèmes différentiels.</h1><!--SEC END -->
<!--TOC section id="sec114" Introduction et représentation graphique.-->
<h2 id="sec114" class="section">14.1  Introduction et représentation graphique.</h2><!--SEC END --><p>
On s’intéresse à l’équation différentielle
<a id="eqref_15"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>15</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 y&apos;=\frac{dy}{dt}=f(y,t)
\qquad (15) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&Element;</mo><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>y(t) \in \mathbb{R}^n</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi>&Ropf;</mi> <mi>n</mi></msup><mo>&times;</mo><mi>&Ropf;</mi><mo>&rightarrow;</mo><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>f: \mathbb{R}^n \times \mathbb{R} \rightarrow \mathbb{R}^n</annotation></semantics></math>.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n=1</annotation></semantics></math>, c’est une équation différentielle, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&amp;gt;1</annotation></semantics></math> c’est
un système différentiel.</p><p>Exemple : en dimension <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n=1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>y&apos;=f(y,t)=ay</annotation></semantics></math>. On sait résoudre cette
équation, les solutions sont de la forme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><msup><mi>e</mi> <mrow><mi>a</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=Ce^{at}</annotation></semantics></math>. Si on trace
la courbe représentative de ces solutions (appelée
courbe intégrale), on observe que par
tout point du plan, il passe une solution unique. La tangente
à une courbe intégrale a pour pente <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>a</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>y&apos;=ay</annotation></semantics></math> donc pour
vecteur directeur le vecteur de composantes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mi>a</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1,ay)</annotation></semantics></math>.</p><p>C’est vrai de manière plus générale, le vecteur directeur
de la tangente à une courbe intégrale est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1,f(y,t))</annotation></semantics></math>. Si
on représente dans le plan selon un quadrillage régulier
les vecteurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1,f(y,t))</annotation></semantics></math>, une courbe intégrale doit être
tangente à ces vecteurs chaque fois qu’elle passe en un point
du quadrillage, (et à peu près tangente si elle passe à
proximité). Un tel quadrillage est appelé champ des tangentes
(commande <code>plotfield</code> en Xcas, mode également disponible
sur certaines calculatrices).</p><p>Exercice : tracer le champ des tangentes et quelques solutions
pour quelques exemples de fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(y,t)</annotation></semantics></math>, avec Xcas créer
une figure 2d, puis choisir le mode Champ des tangentes
du menu Geo, Graphe, entrer la fonction, puis cliquer en quelques
points pour faire tracer la solution passant par ces points.<br>
Par exemple pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>y</mi><mo>+</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=&#x2d;y+\cos(t)</annotation></semantics></math><br>


<div><form onsubmit="setTimeout(function(){UI.eval_form(form);});return false;">
<input type="text" name="name" size="1" value=

"y0">

=<input type="number" name="valname" onchange="UI.eval_form(form);" value=

"1.0">

<input type="button" value="-" onclick="valname.value -= stepname.value;UI.eval_form(form);">
<input type="button" value="+" onclick="valname.value -= -stepname.value;UI.eval_form(form);">
<input type="number" name="stepname" value=

"0.1">

<input type="range" name="rangename"
onclick="valname.value=value;UI.eval_form(form);" value=

"1.0" min="-5" max="5" step="0.1">

<textarea name="prog" onchange="UI.eval_form(form)" style="width:400px;vertical-align:bottom;font-size:large">

gl_x=-5..5; gl_y=-5..5;
plotfield(-y+cos(t),[t=-5..5,y=-5..5],xstep=0.4,ystep=0.4);
plotode(-y+cos(t),[t=-5..5,y],[0,y0],tstep=0.1,color=red)


</textarea>
</form>
<span>Not evaled</span></div>

</p><p>L’équation (<a href="#eqref_15">15</a>) est d’ordre 1, or certaines équations
différentielles se présentent naturellement comme des
équations d’ordre 2, par exemple l’équation fondementale
de la dynamique (accélération=somme des forces divisée par
la masse). Mais on peut facilement se ramener à un
système différentiel d’ordre
1, en augmentant la dimension de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>. Par exemple, si
on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>,</mo><mi>v</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y=(x(t),v(t))</annotation></semantics></math>, où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x(t)</annotation></semantics></math> est la position
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v(t)</annotation></semantics></math> la vitesse, alors l’équation devient un système d’ordre 1
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>v</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd></mtr></mtable><mo>)</mo></mrow><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>v</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mfrac><mi>F</mi><mi>m</mi></mfrac></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\frac{d}{dt} \left(\begin{array}{c} x(t) \\ v(t) \end{array}
\right) 
= \left(\begin{array}{c} v(t) \\ \frac{F}{m} \end{array} \right)  </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> est la force, qui dépend de la position <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x(t)</annotation></semantics></math> 
(champ électrique, gravitation...) et
éventuellement de la vitesse (force de frottement, champ magnétique...).
On utilise aussi assez fréquemment <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>,</mo><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y=(q(t),p(t))</annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>q(t)</annotation></semantics></math> est la position, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>p(t)</annotation></semantics></math> la quantité de mouvement
(qui dépend de la vitesse, linéairement en mécanique classique).</p><p>Représentation graphique : comme précédemment,
on peut se placer dans l’espace
des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(t,x,v)</annotation></semantics></math> (si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est en dimension 1), mais il est souvent
plus difficile d’observer des phénomènes sur un graphe
en 3-d que dans le plan, on préfère ne pas représenter explicitement le
temps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>, mais uniquement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x,v)</annotation></semantics></math>, on est donc naturellement
ramené à représenter une solution (une courbe intégrale)
par une courbe paramétrique en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x,v)</annotation></semantics></math> (ou en position
impulsion). On a encore la notion de champ des tangentes
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(y,t)=f(y)</annotation></semantics></math> ne dépend pas explicitement du temps
(on dit que le système est <em>autonome</em>), dans ce
cas une courbe intégrale a pour tangente en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&Element;</mo><msup><mi>&Ropf;</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>y\in \mathbb{R}^2</annotation></semantics></math> 
de direction portée par le vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&Element;</mo><msup><mi>&Ropf;</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>f(y) \in \mathbb{R}^2</annotation></semantics></math>.<br>
<span style="font-weight:bold">Exemple</span> : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>&prime;</mo><mo>=</mo><mn>5</mn><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>v</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x,v)&apos;=5(&#x2d;v,x)</annotation></semantics></math>. La commande <br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">purge(v,x);plotfield(5*[-v,x],[x=-1..1,v=-1..1],normalize)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

permet d’en représenter le champ des tangentes
et d’avoir une idée approximative de l’allure des solutions
(<code>normalize</code> affiche des vecteur tangents de norme 1, si
on n’utilise pas cette option, la taille des vecteurs tangents donne
la “vitesse” de déplacement).
On sait résoudre ce système différentiel, soit en appliquant
une technique matricielle présentée ci-dessous, 
soit en se ramenant à une équation
linéaire d’ordre 2 à coefficients constants:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>&prime;</mo><mo>&prime;</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>5</mn><mi>v</mi><mo>&prime;</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>25</mn><mi>x</mi></mrow><annotation encoding='application/x-tex'>x&apos;{&apos;}=&#x2d;5v&apos;=&#x2d;25x </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mi>cos</mi><mo stretchy="false">(</mo><mn>5</mn><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mi>B</mi><mi>sin</mi><mo stretchy="false">(</mo><mn>5</mn><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x(t)=A\cos(5t)+B\sin(5t)</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding='application/x-tex'>A, B</annotation></semantics></math> étant déterminés
par les conditions initiales sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x,v)</annotation></semantics></math>.</p><p>Une équation donnée sous la forme (<a href="#eqref_15">15</a>)
est appelée une équation résolue en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>,
car on a exprimé la dérivée en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>. Il
existe (plus fréquemment en mathématiques) d’autres formes d’équations
différentielles (non résolues) où le premier travail de résolution
peut consister à exprimer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>y&apos;</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> (ce qui n’est pas toujours possible 
explicitement).</p><p>Exemple : en dimension 1, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>ty&apos;=y</annotation></semantics></math>, on sait résoudre exactement
cette équation à variables séparables, les solutions sont de la 
forme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>Ct</annotation></semantics></math>.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;height:100px;font-size:large">purge(x,y);gl_x=-1..1;gl_y=-5..5;
plotfield(y/t,[t=-1..1,y=-5..5],xstep=0.05,ystep=0.5);
seq(line(y=k*x,color=red),k,-5,5,0.5)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

On observe que contrairement à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>a</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>y&apos;=ay</annotation></semantics></math>
où passe une solution et une seule par chaque point du plan,
ici toutes les solutions valent 0 en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>t=0</annotation></semantics></math> : il passe une
infinité de solutions par le point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(0,0)</annotation></semantics></math> et il n’en passe aucune
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>,</mo><mspace width="mediummathspace"/><mi>a</mi><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>(0,a), \ a \neq 0</annotation></semantics></math>. Ce phénomène de non unicité/non
existence vient de la mise sous forme résolue <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi><mo stretchy="false">/</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>y&apos;=y/t</annotation></semantics></math> qui
fait apparaitre une singularité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(y,t)</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>t=0</annotation></semantics></math>.</p><p>On présente dans la suite de cette section 
des résultats qualitatifs sur les équations sous forme résolue
lorsqu’on ne sait pas les résoudre, ainsi que 
quelques méthodes explicites
pour certaines équations différentielles que l’on sait
résoudre.</p>
<!--TOC section id="sec115" Existence et unicité-->
<h2 id="sec115" class="section">14.2  Existence et unicité</h2><!--SEC END --><p> <a id="sec:existence"></a>
Il s’agit ici de préciser dans quelles conditions le résultat
intuitif suivant est vrai : étant donné une condition initiale
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>y(t_0)=y_0</annotation></semantics></math>, il y a une et une seule évolution possible, donc
une solution unique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math> de l’équation ou du système
(<a href="#eqref_15">15</a>).</p><p>On a le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 26</span>  <em> </em><a id="thm:eqdiff"></a><em> (Cauchy-Lipschitz)
Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> est continument dérivable en </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math><em> sur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup><mo>&times;</mo><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n \times \mathbb{R}</annotation></semantics></math><em>
ou sur un domaine ouvert </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math><em> inclus dans </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup><mo>&times;</mo><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n \times \mathbb{R}</annotation></semantics></math><em>, alors l’équation
(ou le système) résolu (</em><a href="#eqref_15">15</a><em>) admet pour toute condition
initiale </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>y(t_0)=y_0</annotation></semantics></math><em> une solution unique
sur un intervalle maximal ouvert en temps contenant </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>t_0</annotation></semantics></math><em>.
</em></div><p>
<span style="font-weight:bold">Remarques</span>
</p><ul class="itemize"><li class="li-itemize">
Attention, l’existence d’une solution ne signifie absolument pas que
l’on sait calculer explicitement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math>.
</li><li class="li-itemize">L’existence et l’unicité d’une solution permet d’affirmer le
caractère déterministe de l’équation. Mais la méconnaissance
précise de la condition initiale peut au cours du temps
provoquer une erreur tellement grande sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math>
que celle-ci devient imprédictible.
</li><li class="li-itemize">Le théorème ne dit rien sur la taille de l’intervalle
d’existence de la solution (en temps). Certaines solutions
peuvent exploser en temps fini, par exemple<br>
<code>desolve(y'=y^2 and y(0)=1)</code><br>
Bien entendu, si on modélise une quantité physique par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>, dire
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> explose (en temps fini ou infini du reste)
signifie que les approximations utilisées pour la modélisation
ne sont plus valable bien avant.
</li></ul><p>
On admettra ce théorème, voici quelques idées heuristiques
de la preuve. L’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=f(y,t)</annotation></semantics></math> peut se réécrire sous la forme
intégrale équivalente 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><msubsup><mo>&Integral;</mo> <mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow> <mi>t</mi></msubsup><mi>y</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>u</mi><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><msubsup><mo>&Integral;</mo> <mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow> <mi>t</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>,</mo><mi>u</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>u</mi></mrow><annotation encoding='application/x-tex'>y(t)=y(t_0)+\int_{t_0}^t y&apos;(u) \ du =
 y(t_0)+\int_{t_0}^t f(y(u),u)\ du  </annotation></semantics></math> 
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> est assez proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>t_0</annotation></semantics></math>, on peut approcher l’intégrale par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mtext>petite erreur</mtext></mrow><annotation encoding='application/x-tex'>y(t) = y(t_0) + (t&#x2d;t_0) f(y(t_0),t_0) + \mbox{petite erreur} </annotation></semantics></math>
C’est exactement ce qu’on fait en suivant le champ des tangentes
pour approcher une courbe intégrale graphiquement, et si on
discrétise le temps avec un pas petit, cette méthode
d’approximation est appelée méthode d’Euler. On peut
bien sur utiliser d’autres approximations (meilleures) de
l’intégrale pour avoir une meilleure approximation de la solution,
et les méthodes dites de Runge-Kutta utilisent cette idée. D’un
point de vue théorique, la preuve repose plutôt sur ce qu’on
appelle le théorème du point fixe, on met la valeur approchée
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math> trouvée dans l’équation intégrale pour avoir
une nouvelle valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math>, on recommence,
ainsi de suite, et on montre que
le processus converge (il s’agit mathématiquement parlant
d’une suite récurrente de fonctions, la preuve rigoureuse
de la convergence nécessite des outils mathématiques 
de niveau L3-M1 de maths, c’est l’analogue des suites
récurrentes de réels qui permettent de résoudre
numériquement des équations comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x=\cos(x)</annotation></semantics></math>
abordées en mat249).</p><p><span style="font-weight:bold">Conséquence du théorème </span><a href="#thm%3Aeqdiff"><span style="font-weight:bold">26</span></a> : 
deux courbes intégrales de la même équation
différentielle ne peuvent se couper dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>. Donc si on connait
une courbe intégrale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> et qu’on prend une condition initiale
en-dehors de cette courbe, la courbe intégrale unique passant
par cette condition initiale restera du même coté de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>. Si on
connait deux courbes intégrales de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>, une courbe intégrale
passant par une condition initiale entre les deux courbes restera
entre les deux courbes.</p><p><span style="font-weight:bold">Exemple</span> : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=y(1&#x2d;y)</annotation></semantics></math> (équation logistique). 


<div><form onsubmit="setTimeout(function(){UI.eval_form(form);});return false;">
<input type="text" name="name" size="1" value=

"y0">

=<input type="number" name="valname" onchange="UI.eval_form(form);" value=

"0.5">

<input type="button" value="-" onclick="valname.value -= stepname.value;UI.eval_form(form);">
<input type="button" value="+" onclick="valname.value -= -stepname.value;UI.eval_form(form);">
<input type="number" name="stepname" value=

"0.05">

<input type="range" name="rangename"
onclick="valname.value=value;UI.eval_form(form);" value=

"0.5" min="-0.5" max="1.5" step="0.05">

<textarea name="prog" onchange="UI.eval_form(form)" style="width:400px;vertical-align:bottom;font-size:large">

gl_x=-5..5;gl_y=-1..2;
plotfield(y*(1-y),[t=-5..5,y=-1..2],xstep=0.4,ystep=0.2);
plotode(y*(1-y),[t=-5..5,y],[0,y0],tstep=0.1,color=red)


</textarea>
</form>
<span>Not evaled</span></div>


Cette équation autonome admet deux solutions
évidentes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y=0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>y=1</annotation></semantics></math>. Donc pour toute condition initiale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>&Element;</mo><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>y(t_0)
\in ]0,1[</annotation></semantics></math>, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&Element;</mo><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>y(t) \in ]0,1[</annotation></semantics></math><sup><a id="text23" href="#note23">1</a></sup>. 
On en déduit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>y</mi><mo stretchy="false">)</mo><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;=y(1&#x2d;y)&amp;gt;0</annotation></semantics></math>
donc la solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> est strictement croissante, comme elle est
bornée par 0 et 1, elle admet une limite pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo>&pm;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t \rightarrow \pm
\infty</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>y&apos;</annotation></semantics></math> tend vers 0 pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo>&pm;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t \rightarrow \pm
\infty</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> tend vers 0 ou 1, et comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> croit, 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&rightarrow;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y \rightarrow 0</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t=&#x2d;\infty</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&rightarrow;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>y \rightarrow 1</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t=+\infty</annotation></semantics></math>.
Le comportement à l’infini est donc indépendant de la valeur
précise de la condition initiale, pourvu qu’elle soit dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]0,1[</annotation></semantics></math>.</p><p><span style="font-weight:bold">Exercice </span>: toujours pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=y(1&#x2d;y)</annotation></semantics></math> que se passe-t-il pour une
condition initiale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>y(t_0)&amp;gt;1</annotation></semantics></math> ?</p>
<!--TOC section id="sec116" Quelques méthodes de résolution explicite.-->
<h2 id="sec116" class="section">14.3  Quelques méthodes de résolution explicite.</h2><!--SEC END -->
<!--TOC subsection id="sec117" Équations à variables
séparables-->
<h3 id="sec117" class="subsection">14.3.1  Équations à variables
séparables</h3><!--SEC END --><p><a id="hevea_default140"></a><a id="hevea_default141"></a>
Si on peut factoriser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(y,t)</annotation></semantics></math> en termes ne dépendant que
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> ou ne dépendant que de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>, on dit que l’équation
est à variable séparable <math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo>,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=f(y,t)=g(t)h(y) </annotation></semantics></math>
Cette équation admet des solutions constantes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>y=y_0</annotation></semantics></math> lorsque
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><msub><mi>y</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>h(y_0)=0</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>h(y(t_0)) \neq 0</annotation></semantics></math>, par le théorème de
Cauchy-Lipschitz <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>h(y(t))</annotation></semantics></math> ne s’annule nulle part sur son domaine
de définition. On peut donc diviser par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>h(y)</annotation></semantics></math> et 
intégrer :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo>&Rightarrow;</mo><mo>&Integral;</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mo>&Integral;</mo><mi>g</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\Rightarrow \int \frac{dy}{h(y)} = \int g(t) \ 
dt </annotation></semantics></math>
On obtient une équation implicite de la forme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>G</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mi>C</mi></mrow><annotation encoding='application/x-tex'>H(y)=G(t)+C</annotation></semantics></math> où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est une primitive de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mi>h</mi></mrow><annotation encoding='application/x-tex'>1/h</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> une constante
arbitraire. Dans les cas favorables, on peut exprimer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> en fonction
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> (par exemple si l’équation est linéaire sans second membre,
on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>h(y)=y</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> est le log que l’on sait
inverser). Dans les cas moins favorables, on peut exprimer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> en fonction d’un paramètre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math> : la courbe intégrale est
une courbe paramétrée. Dans les cas défavorables, on reste
sous forme implicite.</p><p><span style="font-weight:bold">Exercice </span>: résoudre explicitement l’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=y(1&#x2d;y)</annotation></semantics></math>
et retrouver les résultats qualitatifs de la section précédente. <br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">desolve(y'=y*(1-y)) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p>
<!--TOC subsection id="sec118" Équations linéaires-->
<h3 id="sec118" class="subsection">14.3.2  Équations linéaires</h3><!--SEC END --><p><a id="hevea_default142"></a><a id="hevea_default143"></a>
On commence par résoudre l’équation sans second membre
(aussi appelée homogène)
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>y</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><msub><mi>a</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>a_n(t) y^{[n]} +...+a_1(t)y&apos;+a_0(t)y=0 </annotation></semantics></math>
sur un intervalle ouvert sur lequel <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>a_n(t) \neq 0</annotation></semantics></math>. 
L’ensemble des solutions est un espace vectoriel (car l’équation
est linéaire) et de dimension l’ordre de
l’équation : pour le prouver on peut appliquer le théorème
de Cauchy-Lipschitz au système d’ordre 1 équivalent, ce
système est tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> est un vecteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math>, on a ensuite
un isomorphisme entre les solutions et la condition initiale.</p><p>Si l’ordre est 1, on a une équation à variables séparables
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo stretchy="false">/</mo><mi>y</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>a</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><msub><mi>a</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> y&apos;/y=&#x2d;a_0(t)/a_1(t)</annotation></semantics></math> et la solution est une exponentielle :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mo>&Integral;</mo><mfrac><mrow><msub><mi>a</mi> <mn>0</mn></msub></mrow><mrow><msub><mi>a</mi> <mn>1</mn></msub></mrow></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=Ce^{&#x2d;\int \frac{a_0}{a_1} \ dt} </annotation></semantics></math>
<span style="font-weight:bold">Exemple</span> : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;&#x2d;ty=0</annotation></semantics></math>, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><msup><mi>e</mi> <mrow><mo>&Integral;</mo><mi>t</mi><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow></msup><mo>=</mo><mi>C</mi><msup><mi>e</mi> <mrow><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=Ce^{\int t \ dt}=Ce^{t^2/2}</annotation></semantics></math></p><p>Si l’ordre est plus grand que 1, on n’a en général pas de solution
explicitable avec les fonctions usuelles et des primitives<sup><a id="text24" href="#note24">2</a></sup>, 
pour certaines équations importantes en physique, 
des fonctions spéciales
ont été créées pour exprimer les solutions, par
exemple les fonctions de Bessel. Il existe quelques
cas particuliers où le calcul explicite est possible, dont
le cas où les coefficients sont constants (section suivante).
Si on connait une solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi></mrow><annotation encoding='application/x-tex'>w</annotation></semantics></math> d’une équation linéaire, alors 
en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mi>w</mi><mi>z</mi></mrow><annotation encoding='application/x-tex'>y=wz</annotation></semantics></math>, la fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>z&apos;</annotation></semantics></math> vérifie une équation linéaire
d’ordre un de moins, ainsi si on connait une solution d’une équation
linéaire d’ordre 2, on peut la résoudre complètement.</p><p>Le calcul d’une solution particulière 
d’une équation linéaire avec second
membre se fait en faisant varier les constantes d’intégration :
on prend la forme générale de la solution de l’équation
homogène,
on remplace les constantes d’intégration par des fonctions inconnues,
on remplace dans l’équation avec second membre et on
résoud en les fonctions inconnues, la méthode détaillée
dans le cas des coefficients constants s’applique à l’identique.
La solution générale est la somme d’une solution particulière
et de la solution générale de l’équation sans second membre.</p><p><span style="font-weight:bold">Exemple </span>: <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi><mi>y</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>y&apos;&#x2d;ty=&#x2d;t</annotation></semantics></math>, solution générale de l’équation
homogène <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><msup><mi>e</mi> <mrow><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=Ce^{t^2/2}</annotation></semantics></math>, variation de la constante
on remplace <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=C(t)e^{t^2/2}</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi><mi>y</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>y&apos;&#x2d;ty=&#x2d;t</annotation></semantics></math> et on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo>&prime;</mo><msup><mi>e</mi> <mrow><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>C&apos; e^{t^2/2}=&#x2d;t</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo>&prime;</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>C&apos;=&#x2d;te^{&#x2d;t^2/2}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo>=</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup><mo>+</mo><mi>K</mi></mrow><annotation encoding='application/x-tex'>C=e^{&#x2d;t^2/2}+K</annotation></semantics></math>,
d’où la solution générale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup><mo>+</mo><mi>K</mi><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup><mo>=</mo><mn>1</mn><mo>+</mo><mi>K</mi><msup><mi>e</mi> <mrow><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=(e^{&#x2d;t^2/2}+K)e^{t^2/2}=1+Ke^{t^2/2}</annotation></semantics></math>.</p>
<!--TOC subsection id="sec119" Équations linéaires à coefficients constants-->
<h3 id="sec119" class="subsection">14.3.3  Équations linéaires à coefficients constants</h3><!--SEC END --><p>
On peut chercher des solutions de l’équation sans second membre
sous la forme d’exponentielles
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{rt}</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> doit alors vérifier une équation polynomiale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P(r)=0</annotation></semantics></math>
appelée <span style="font-weight:bold">équation caractéristique</span><a id="hevea_default144"></a><a id="hevea_default145"></a>,
de degré le degré de l’équation différentielle. 
Plus précisément, si on remplace <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{rt}</annotation></semantics></math> dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>y</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mn>1</mn></msub><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><msub><mi>a</mi> <mn>0</mn></msub><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>a_n y^{[n]}+...+a_1 y&apos;+a_0y=0 </annotation></semantics></math> alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>r</mi> <mi>n</mi></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mn>1</mn></msub><mi>r</mi><mo>+</mo><msub><mi>a</mi> <mn>0</mn></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>a_n r^n +...+a_1r +a_0=P(r)=0 </annotation></semantics></math>
</p><div class="theorem"><span style="font-weight:bold">Théorème 27</span>  <em>
Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> n’a que des racines simples </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>r</mi> <mi>n</mi></msub><mo>&Element;</mo><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>r_1,...,r_n \in \mathbb{C}</annotation></semantics></math><em>, 
l’ensemble des solutions
est alors l’espace vectoriel engendré par 
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">{</mo><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mn>1</mn></msub><mi>t</mi></mrow></msup><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mi>n</mi></msub><mi>t</mi></mrow></msup><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>\{ e^{r_1t}, ... , e^{r_nt} \}</annotation></semantics></math><em>
</em></div><p>
En effet, on a le bon nombre
d’éléments (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>), il suffit donc de montrer 
qu’il s’agit d’une famille libre. </p><p>Pour cela, il suffit de faire tendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> vers l’infini
si toutes les parties réelles des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>r_j</annotation></semantics></math> sont distinctes. Si
certaines sont égales, on peut faire tendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> vers l’infini
sur une demi-droite du plan complexe, 
on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mi>T</mi><msup><mi>e</mi> <mrow><mi>i</mi><mi>&alpha;</mi></mrow></msup><mo>,</mo><mi>T</mi><mo>&Element;</mo><msup><mi>&Ropf;</mi> <mo>+</mo></msup></mrow><annotation encoding='application/x-tex'>t=Te^{i\alpha}, T \in \mathbb{R}^+</annotation></semantics></math> 
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> est un petit angle
choisi pour que les parties réelles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>j</mi></msub><msup><mi>e</mi> <mrow><mi>i</mi><mi>&alpha;</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>r_je^{i\alpha}</annotation></semantics></math> 
soient toutes distinctes (ceci revient à choisir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>
tel que les projections des racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>r_j</annotation></semantics></math> 
sur l’axe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>Ox</annotation></semantics></math> tourné de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>&#x2d;\alpha</annotation></semantics></math> soient toutes distinctes,
on brise ainsi une symétrie sur les racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>).</p><p>On peut aussi faire une récurrence. Au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n=1</annotation></semantics></math> c’est évident.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&amp;gt;1</annotation></semantics></math> et si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>&lambda;</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(\lambda_1,...,\lambda_n)</annotation></semantics></math> vérifient :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>&lambda;</mi> <mi>j</mi></msub><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mi>j</mi></msub><mi>t</mi></mrow></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>\sum_{j=1}^n \lambda_j e^{r_jt} = 0 </annotation></semantics></math>
on factorise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mi>n</mi></msub><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{r_n t}</annotation></semantics></math> et on dérive, on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>&lambda;</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>j</mi></msub><mo>&minus;</mo><msub><mi>r</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>j</mi></msub><mo>&minus;</mo><msub><mi>r</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mi>t</mi></mrow></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>\sum_{j=1}^{n&#x2d;1} \lambda_j (r_j&#x2d;r_n) e^{(r_j&#x2d;r_n)t} =0  </annotation></semantics></math>
on est ramené à l’identité précédente au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math>
donc par récurrence, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>j</mi></msub><mo>&minus;</mo><msub><mi>r</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>\lambda_j (r_j&#x2d;r_n)=0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>j</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>\lambda_j=0</annotation></semantics></math>
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&ne;</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>j \neq n</annotation></semantics></math>, puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>n</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>\lambda_n=0</annotation></semantics></math> avec la relation du départ.</p><p>Dans le cas général, on a :
</p><div class="theorem"><span style="font-weight:bold">Théorème 28</span>  <em>
Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> a des racines multiples, il faut modifier la base
de l’énoncé précédent : pour chaque
racine </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>r_k</annotation></semantics></math><em> de multiplicité </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>m&amp;gt;1</annotation></semantics></math><em>, on remplace </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mi>k</mi></msub><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{r_kt}</annotation></semantics></math><em>
répété </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math><em> fois par
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">{</mo><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mi>k</mi></msub><mi>t</mi></mrow></msup><mo>,</mo><mi>t</mi><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mi>k</mi></msub><mi>t</mi></mrow></msup><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>t</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mi>k</mi></msub><mi>t</mi></mrow></msup><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>\{ e^{r_kt}, te^{r_kt}, ..., t^{m&#x2d;1} e^{r_kt} \}</annotation></semantics></math><em>
</em></div><p>
En effet, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mi>y</mi><msup><mo stretchy="false">)</mo> <mrow><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></msup><mo>=</mo><mi>t</mi><msup><mi>y</mi> <mrow><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow></msup><mo>+</mo><mi>j</mi><msup><mi>y</mi> <mrow><mo stretchy="false">[</mo><mi>j</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>(ty)^{[j]} = t y^{[j]} + j y^{[j&#x2d;1]} </annotation></semantics></math>
Supposons que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> est solution de l’équation, 
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>ty</annotation></semantics></math> est encore solution si :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>n</mi><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>y</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msup><mi>y</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">]</mo></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mn>1</mn></msub><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>na_n y^{[n&#x2d;1]} + (n&#x2d;1)a_{n&#x2d;1} y^{[n&#x2d;2]}+...+a_1y=0 </annotation></semantics></math>
et on reconnait une équation différentielle linéaire à coefficients
constants dont l’équation caractéristique est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P&apos;=0</annotation></semantics></math>, on a donc
montré la :
</p><div class="theorem"><span style="font-weight:bold">Proposition 29</span>  <em>
Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math><em> est solution des deux équations différentielles à coefficients
constants de polynomes caractéristiques respectifs </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math><em> alors
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>ty</annotation></semantics></math><em> est solution de l’équation différentielle à coefficients
constants de polynome caractéristique </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em>.
</em></div><p>
Pour prouver le théorème, il faut encore se convaincre que la
famille est une base, ce qui revient
à prouver l’indépendance linéaire de ces fonctions.
Cela se fait comme précédemment. Si toutes les parties réelles
des racines sont distinctes, en faisant tendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> vers
l’infini on se ramène à un équivalent polynômial nul.
Si certaines parties réelles sont égales, on peut à nouveau
faire tendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> vers l’infini dans le plan complexe en
tournant d’un petit angle. On peut aussi adapter la récurrence,
sur le nombre de racines. S’il y
en a une, on a un polynôme. Sinon, on factorise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mi>n</mi></msub><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{r_nt}</annotation></semantics></math>,
et on dérive la multiplicité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>r_n</annotation></semantics></math> pour appliquer
le résultat au cran <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math>, on a alors un système triangulaire
sur le groupe d’inconnues de la même exponentielle. On peut aussi
se ramener à des polynômes en posant comme ci-dessus
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mi>T</mi><msup><mi>e</mi> <mrow><mi>i</mi><mi>&alpha;</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>t=Te^{i\alpha}</annotation></semantics></math> et en faisant tendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> vers l’infini.</p><p>Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est à coefficients réels et admet une racine non réelle
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>z</mi><mo>&#x000AF;</mo></mover></mrow><annotation encoding='application/x-tex'>\overline{z}</annotation></semantics></math> est encore racine, on peut réécrire 
la base d’exponentielles complexes en une base
de fonctions réelles en utilisant des fonctions trigonométriques.
En effet les combinaisons linéaires réelles
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>z</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{zt}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mover><mi>z</mi><mo>&#x000AF;</mo></mover><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{\overline{z}t}</annotation></semantics></math> ont des coefficients conjugués :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>+</mo><mi>i</mi><mi>&beta;</mi><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>i</mi><mi>b</mi><mo stretchy="false">)</mo><mi>t</mi></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>&minus;</mo><mi>i</mi><mi>&beta;</mi><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mi>i</mi><mi>b</mi><mo stretchy="false">)</mo><mi>t</mi></mrow></msup><mo>=</mo><msup><mi>e</mi> <mrow><mi>a</mi><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mn>2</mn><mi>&alpha;</mi><mi>cos</mi><mo stretchy="false">(</mo><mi>b</mi><mi>t</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mn>2</mn><mi>&beta;</mi><mi>sin</mi><mo stretchy="false">(</mo><mi>b</mi><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(\alpha + i \beta) e^{(a+ib)t} + (\alpha &#x2d; i \beta)  e^{(a&#x2d;ib)t}
=  e^{at} ( 2 \alpha \cos(bt) &#x2d; 2 \beta \sin(bt) ) </annotation></semantics></math></p><p><span style="font-weight:bold">Exemples </span>: 
</p><ul class="itemize"><li class="li-itemize">
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>&prime;</mo><mo>+</mo><mn>3</mn><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;{&apos;}+3y&apos;&#x2d;4y=0</annotation></semantics></math>, équation caractéristique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>r</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>&minus;</mo><mn>4</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>r^2+3r&#x2d;4=0</annotation></semantics></math>,
deux racines distinctes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>r</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>r=1, r=&#x2d;4</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>&alpha;</mi><msup><mi>e</mi> <mi>t</mi></msup><mo>+</mo><mi>&beta;</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=\alpha e^t+\beta e^{&#x2d;4t}</annotation></semantics></math>
</li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>&prime;</mo><mo>+</mo><mn>2</mn><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;{&apos;}+2y&apos;+y=0</annotation></semantics></math>, équation caractéristique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>r</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>r</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>r^2+2r+1=0</annotation></semantics></math>,
a une racine double <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>r=&#x2d;1</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>&alpha;</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo>+</mo><mi>&beta;</mi><mi>t</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=\alpha e^{&#x2d;t}+\beta t e^{&#x2d;t}</annotation></semantics></math>
</li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>&prime;</mo><mo>+</mo><mn>2</mn><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>2</mn><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;{&apos;}+2y&apos;+2y=0</annotation></semantics></math>, équation caractéristique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>r</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>r</mi><mo>+</mo><mn>2</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>r^2+2r+2=0</annotation></semantics></math>,
deux racines conjuguées <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>&pm;</mo><mi>i</mi></mrow><annotation encoding='application/x-tex'>r=&#x2d;1\pm i</annotation></semantics></math>, donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>&alpha;</mi><mi>cos</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mi>&beta;</mi><mi>sin</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)=e^{&#x2d;t}(\alpha \cos(t)+\beta \sin(t))</annotation></semantics></math>
</li></ul><p>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">desolve(y''+2y'+2y=0) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>On peut trouver une solution particulière de l’équation avec
second membre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>s(t)</annotation></semantics></math> par la méthode de variation
des constantes, qui s’applique d’ailleurs
également lorsque l’équation est linéaire à coefficients
variables. Si la solution générale est engendrée par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>y</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>y_1,...,y_n</annotation></semantics></math>, on pose :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>&lambda;</mi> <mi>i</mi></msub><msub><mi>y</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>y=\sum_{i=1}^n \lambda_i y_i </annotation></semantics></math>
On pose
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo>&prime;</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>=</mo><mn>0</mn><mspace width="mediummathspace"/><mo>&Rightarrow;</mo><mspace width="mediummathspace"/><mi>y</mi><mo>&prime;</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>&lambda;</mi> <mi>i</mi></msub><msub><mi>y</mi> <mi>i</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>\sum_{i=1}^n \lambda_i&apos; y_i=0 \ \Rightarrow \ 
y&apos;=\sum_{i=1}^n \lambda_i y_i&apos; </annotation></semantics></math>
et ainsi de suite jusqu’à la dérivée d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>, ces
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> équations et l’équation différentielle donnent 
alors un système linéaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>n,n</annotation></semantics></math> en
les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>\lambda_i&apos;</annotation></semantics></math>. 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>{</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo>&prime;</mo><msub><mi>y</mi> <mi>i</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo>&prime;</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>&prime;</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo>&prime;</mo><msubsup><mi>y</mi> <mi>i</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">]</mo></mrow></msubsup></mtd> <mtd><mo>=</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo>&prime;</mo><msubsup><mi>y</mi> <mi>i</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msubsup></mtd> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>a</mi> <mi>n</mi></msub></mrow></mfrac></mtd></mtr> <mtr><mtd/></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'>\left\{ \begin{array}{ccc}
\sum_{i=1}^n \lambda_i&apos; y_i &amp;=&amp;0\\
\sum_{i=1}^n \lambda_i&apos; y_i&apos; &amp;=&amp;0\\
...\\
\sum_{i=1}^n \lambda_i&apos; y_i^{[n&#x2d;2]} &amp;=&amp;0\\
\sum_{i=1}^n \lambda_i&apos; y_i^{[n&#x2d;1]} &amp;=&amp; \frac{s(t)}{a_n}\\
\end{array} \right.  </annotation></semantics></math>
Ce système a pour déterminant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> la matrice
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>-ième ligne la dérivée d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>i&#x2d;1</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>y</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>y_1,...,y_n</annotation></semantics></math>.
Si on calcule la dérivée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math>, il faut faire
porter la dérivée sur la dernière ligne pour avoir une
contribution non nulle, on peut alors utiliser l’équation
différentielle pour montrer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> vérifie une
équation linéaire d’ordre 1 <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub><mi>d</mi><mo>&prime;</mo><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>d</mi></mrow><annotation encoding='application/x-tex'>a_nd&apos;=(&#x2d;1)^na_{n&#x2d;1}d</annotation></semantics></math> donc il est soit 
identiquement nul soit jamais nul. 
On montre alors par récurrence que l’indépendance linéaire
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>y</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>y_1,...,y_n</annotation></semantics></math> entraine alors
que le déterminant est non nul.
En effet s’il est nul au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, alors l’une
des colonnes est combinaison linéaire des autres, par exemple
la dernière, on a donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>y</mi> <mi>n</mi></msub><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>c</mi> <mi>j</mi></msub><msub><mi>y</mi> <mi>j</mi></msub><mo>,</mo><mspace width="1em"/><msub><mi>y</mi> <mi>n</mi></msub><mo>&prime;</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>c</mi> <mi>j</mi></msub><msub><mi>y</mi> <mi>j</mi></msub><mo>&prime;</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mspace width="1em"/><msubsup><mi>y</mi> <mi>n</mi> <mrow><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></msubsup><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>c</mi> <mi>j</mi></msub><msubsup><mi>y</mi> <mi>j</mi> <mrow><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></msubsup><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>y_n= \sum_{j=1}^{n&#x2d;1} c_j y_j, \quad y_n&apos;=\sum_{j=1}^{n&#x2d;1} c_j y_j&apos;, ...
\quad y_n^{[k]}=\sum_{j=1}^{n&#x2d;1} c_j y_j^{[k]}, ... </annotation></semantics></math>
en dérivant on en déduit que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>c</mi> <mi>j</mi></msub><mo>&prime;</mo><msub><mi>y</mi> <mi>j</mi></msub><mo>=</mo><mn>0</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>c</mi> <mi>j</mi></msub><mo>&prime;</mo><msubsup><mi>y</mi> <mi>j</mi> <mrow><mo stretchy="false">[</mo><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msubsup><mo>=</mo><mn>0</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>\sum_{j=1}^{n&#x2d;1} c_j&apos; y_j=0, ..., \sum_{j=1}^{n&#x2d;1} c_j&apos; y_j^{[k&#x2d;1]}=0,...  </annotation></semantics></math>
on est ramené à un système linéaire homogène en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> inconnues
(les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>j</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>c_j&apos;</annotation></semantics></math>) à qui on applique l’hypothèse de récurrence, 
on en déduit que
les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>j</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>c_j&apos;</annotation></semantics></math> sont nuls donc les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>c_j</annotation></semantics></math> sont des constantes ce qui contredit
l’indépendance linéaire des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>y_j</annotation></semantics></math>.</p><p>Pour des second membre combinaison linéaire
de termes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>b(t)e^{rt}</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> polynôme,
il est plus simple de chercher directement une solution particulière
combinaison linéaire de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><mi>r</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>a(t)e^{rt}</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> est de même
degré que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> n’est pas racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, ou de degré le
degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> plus la multiplicité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> comme racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.
On peut aussi utiliser la transformation de Laplace et son inverse.</p>
<!--TOC subsection id="sec120" Systèmes différentiels linéaires à coefficients
constants d’ordre 1.-->
<h3 id="sec120" class="subsection">14.3.4  Systèmes différentiels linéaires à coefficients
constants d’ordre 1.</h3><!--SEC END --><p><a id="hevea_default146"></a>
Il s’agit donc de systèmes de la forme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>A</mi><mi>y</mi><mo>+</mo><mi>b</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=Ay+b(t) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&Element;</mo><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>y(t)\in \mathbb{R}^n</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est une matrice carrée de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> 
indépendante du temps, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&Element;</mo><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>b(t) \in \mathbb{R}^n</annotation></semantics></math>.</p><p>On commence par résoudre l’équation homogène <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>A</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>y&apos;=Ay</annotation></semantics></math>.
Si la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est diagonalisable, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>P</mi><mi>D</mi><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A=PDP^{&#x2d;1}</annotation></semantics></math> où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>=diag<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>d</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(d_1,...,d_n)</annotation></semantics></math> est diagonale et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> inversible, le système devient :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>P</mi><mi>D</mi><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>y</mi></mrow><annotation encoding='application/x-tex'>y&apos;=PDP^{&#x2d;1} y </annotation></semantics></math>
donc en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mi>P</mi><mi>z</mi></mrow><annotation encoding='application/x-tex'>y=Pz</annotation></semantics></math>, on a (puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est indépendant du temps) :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>z</mi><mo>&prime;</mo><mo>=</mo><mi>D</mi><mi>z</mi><mspace width="1em"/><mo>&Leftrightarrow;</mo><mspace width="1em"/><msub><mi>z</mi> <mi>k</mi></msub><mo>&prime;</mo><mo>=</mo><msub><mi>d</mi> <mi>k</mi></msub><msub><mi>z</mi> <mi>k</mi></msub><mo>,</mo><mspace width="mediummathspace"/><mi>k</mi><mo>=</mo><mn>1</mn><mo>.</mo><mo>.</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>z&apos;=Dz \quad \Leftrightarrow \quad z_k&apos;=d_kz_k, \ k=1..n </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mi>k</mi></msub><mo>=</mo><msub><mi>c</mi> <mi>k</mi></msub><msup><mi>e</mi> <mrow><msub><mi>d</mi> <mi>k</mi></msub><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>z_k=c_k e^{d_kt}</annotation></semantics></math>, puis la solution générale
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><msub><mi>c</mi> <mn>1</mn></msub><msup><mi>e</mi> <mrow><msub><mi>d</mi> <mn>1</mn></msub><mi>t</mi></mrow></msup></mtd></mtr> <mtr><mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><msub><mi>c</mi> <mi>n</mi></msub><msup><mi>e</mi> <mrow><msub><mi>d</mi> <mi>n</mi></msub><mi>t</mi></mrow></msup></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>y(t)=P\left( \begin{array}{c} c_1 e^{d_1t} \\ ... \\c_n e^{d_nt}
\end{array} \right) </annotation></semantics></math>
Le calcul avec Xcas se fait en utilisant la commande <code>desolve</code>,
par exemple<br>
<code>desolve(y'=[[1,2],[2,1]]*y)</code><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">desolve(y'=[[1,2],[2,1]]*y) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
ou avec conditions initiales<br>
<code>desolve(y'=[[1,2],[2,1]]*y and y(0)=[1,2])</code><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">desolve([y'=[[1,2],[2,1]]*y,y(0)=[1,2]]) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
On peut aussi utiliser la fonction <code>exp</code>
avec comme argument <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>At</annotation></semantics></math> (on généralise ainsi 
la notation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>a</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{at}</annotation></semantics></math> 
de la dimension 1), multiplié par la condition initiale :<br>
<code>exp([[1,2],[2,1]]*t)*[1,2]</code><br>
Les calculs intermédiaires pour diagonaliser la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> sont
exécutés par les commandes <code>eigenvals</code>, <code>eigenvects</code>,
<code>jordan</code>.</p><p>On peut ensuite calculer une solution particulière par la méthode
de variation des constantes, ou encore en résolvant 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi><mo>&prime;</mo><mo>=</mo><mi>D</mi><mi>z</mi><mo>+</mo><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>b</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>z&apos;=Dz+P^{&#x2d;1}b(t)</annotation></semantics></math> composante par composante (ou par transformation
de Laplace). Avec Xcas,
il suffit d’ajouter le second membre dans la commande <code>desolve</code><br>
<code>desolve(y'=[[1,2],[2,1]]*y+[x,x+1])</code></p><p>Si la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> n’est pas diagonalisable (ce qui entraine
qu’elle a au moins une valeur propre de
multiplicité plus grande que 1), on peut alors
la trigonaliser, on se ramene à résoudre un système
triangulaire, ce qui revient à résoudre pour chaque
composante une équation
différentielle linéaire d’ordre 1 avec un éventuel 
second membre. </p>
<!--TOC subsection id="sec121" Systèmes et équations-->
<h3 id="sec121" class="subsection">14.3.5  Systèmes et équations</h3><!--SEC END --><p>
Il y a un lien entre systèmes différentiels linéaires
et équations linéaires. En effet une équation d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> peut
s’écrire comme un système différentiel d’ordre 1,
on peut calculer le polynôme caractéristique de la matrice
on retrouve alors l’équation caractéristique. Inversement,
toute matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> admet un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
annulateur tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P(A)=0</annotation></semantics></math><sup><a id="text25" href="#note25">3</a></sup>,
le polynôme caractéristique de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est un polynôme annulateur
(théorème de Cayley-Hamilton).
Les composantes des solutions du système différentiel sont des 
solutions de l’équation différentielle dont l’équation
caractéristique est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P(x)=0</annotation></semantics></math>. En effet :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>0</mn><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><msub><mi>p</mi> <mi>k</mi></msub><msup><mi>A</mi> <mi>k</mi></msup><mi>y</mi><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><msub><mi>p</mi> <mi>k</mi></msub><msup><mi>y</mi> <mrow><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>0=P(A)y=\sum_{k=0}^n p_k A^k y = \sum_{k=0}^n p_k y^{[k]} </annotation></semantics></math></p><p><span style="font-weight:bold">Exemple en dimension 2.</span>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mi>a</mi></mtd> <mtd><mi>b</mi></mtd></mtr> <mtr><mtd><mi>c</mi></mtd> <mtd><mi>d</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>A=\left(\begin{array}{cc}
a &amp; b \\
c &amp; d
\end{array}\right)  </annotation></semantics></math>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>b=0</annotation></semantics></math> alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub><mo>&prime;</mo><mo>=</mo><mi>a</mi><msub><mi>y</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>y_1&apos;=ay_1</annotation></semantics></math> on en déduit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>y_1</annotation></semantics></math> puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>y_2</annotation></semantics></math>. Supposons donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>b\neq 0</annotation></semantics></math>, alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo><mo>+</mo><mi>a</mi><mi>d</mi><mo>&minus;</mo><mi>b</mi><mi>c</mi></mrow><annotation encoding='application/x-tex'>P(x)=x^{2} &#x2d; x (a+d) +a d&#x2d;b c </annotation></semantics></math>
(on peut vérifier que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P(A)=0</annotation></semantics></math>)
donc si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>A</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>y&apos;=Ay</annotation></semantics></math> alors 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub><mo>&prime;</mo><mo>&prime;</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>a</mi><mi>d</mi><mo>&minus;</mo><mi>b</mi><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y_1&apos;{&apos;}&#x2d;(a+d)y_1&apos;+ad&#x2d;bc=0 </annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>y_2</annotation></semantics></math> s’en déduit avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>a</mi><msub><mi>y</mi> <mn>1</mn></msub><mo>=</mo><mi>b</mi><msub><mi>y</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>y_1&apos;&#x2d;ay_1=by_2</annotation></semantics></math> (on peut du reste
partir de cette relation pour établir l’équation d’ordre 2
vérifiée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>y_1</annotation></semantics></math>). On peut ainsi
résoudre tous les systèmes de dimension 2, même
si la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> n’est pas diagonalisable.</p><p><span style="font-weight:bold">Exercice </span>: Résoudre de cette manière le système<br>
<code>desolve(y'=[[1,2],[2,1]]*y and y(0)=[1,2])</code><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">desolve([y'=[[1,2],[2,1]]*y,y(0)=[1,2]]) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p><span style="font-weight:bold">Autre exemple </span>: système d’ordre 2 se ramenant à une équation
d’ordre 2 à coefficients complexes. Les équations pour une particule
chargée dans un champ magnétique constant porté par l’axe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mi>z</mi></mrow><annotation encoding='application/x-tex'>Oz</annotation></semantics></math> et
un champ électrique constant perpendiculaire (donc dans le plan <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>Oxy</annotation></semantics></math>),
avec vitesse initiale nulle ou contenue dans le plan <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>Oxy</annotation></semantics></math> donnent une 
trajectoire plane
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>{</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mi>m</mi><mover><mi>x</mi><mo>&Dot;</mo></mover></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>q</mi><mi>B</mi><mover><mi>y</mi><mo>&dot;</mo></mover><mo>+</mo><mi>q</mi><msub><mi>E</mi> <mi>x</mi></msub></mtd></mtr> <mtr><mtd><mi>m</mi><mover><mi>y</mi><mo>&Dot;</mo></mover></mtd> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>q</mi><mi>B</mi><mover><mi>x</mi><mo>&dot;</mo></mover><mo>+</mo><mi>q</mi><msub><mi>E</mi> <mi>y</mi></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'>\left\{ \begin{array}{ccc} m\ddot{x}&amp;=&amp;qB\dot{y} +qE_x\\
m\ddot{y}&amp;=&amp; &#x2d;qB\dot{x} +qE_y
\end{array} \right. </annotation></semantics></math>
Si on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>z=x+iy</annotation></semantics></math> alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> vérifie l’équation
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mover><mi>z</mi><mo>&Dot;</mo></mover><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>i</mi><mfrac><mrow><mi>q</mi><mi>B</mi></mrow><mi>m</mi></mfrac><mover><mi>z</mi><mo>&dot;</mo></mover><mo>+</mo><mfrac><mrow><mi>q</mi><mi>E</mi></mrow><mi>m</mi></mfrac><mo>,</mo><mspace width="1em"/><mi>E</mi><mo>=</mo><msub><mi>E</mi> <mi>x</mi></msub><mo>+</mo><mi>i</mi><msub><mi>E</mi> <mi>y</mi></msub></mrow><annotation encoding='application/x-tex'>\ddot{z}=&#x2d;i\frac{qB}{m} \dot{z}+\frac{qE}{m}, \quad E=E_x+iE_y </annotation></semantics></math>
Le polynôme caractéristique de cette équation 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>r</mi> <mn>2</mn></msup><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>i</mi><mfrac><mrow><mi>q</mi><mi>B</mi></mrow><mi>m</mi></mfrac><mi>r</mi></mrow><annotation encoding='application/x-tex'>r^2=&#x2d;i\frac{qB}{m}r </annotation></semantics></math>
possède deux racines distinctes 0 et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>i</mi><mfrac><mrow><mi>q</mi><mi>B</mi></mrow><mi>m</mi></mfrac></mrow><annotation encoding='application/x-tex'>&#x2d;i\frac{qB}{m}</annotation></semantics></math> (mais pas le
conjugué, l’équation n’est pas à coefficients réels!) donc
la solution homogène est 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>z</mi><mo>=</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>i</mi><mfrac><mrow><mi>q</mi><mi>B</mi></mrow><mi>m</mi></mfrac><mi>t</mi></mrow></msup><mo>,</mo><mspace width="1em"/><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo>&Element;</mo><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>z=\alpha + \beta e^{&#x2d;i\frac{qB}{m}t}, \quad \alpha,\beta \in \mathbb{C} </annotation></semantics></math>
Le champ électrique joue ici le rôle de second membre, comme 0
est solution de l’équation caractéristique, la forme de la 
solution particulière est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi><mo>=</mo><mi>A</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>z=At</annotation></semantics></math>, en remplaçant on obtient 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>i</mi><mi>E</mi><mo stretchy="false">/</mo><mi>B</mi></mrow><annotation encoding='application/x-tex'> A=iE/B</annotation></semantics></math> donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>z</mi><mo>=</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>i</mi><mfrac><mrow><mi>q</mi><mi>B</mi></mrow><mi>m</mi></mfrac><mi>t</mi></mrow></msup><mo>+</mo><mi>i</mi><mfrac><mi>E</mi><mi>B</mi></mfrac><mi>t</mi></mrow><annotation encoding='application/x-tex'>z=\alpha + \beta e^{&#x2d;i\frac{qB}{m}t}+i\frac{E}{B}t  </annotation></semantics></math>
La forme générale des solutions est un cercle si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>E=0</annotation></semantics></math>
parcouru une infinité de fois, qui se déforme sous l’effet
du champ électrique en une sorte de spirale de ressort, pour
une vitesse initialle nulle, on obtient une cycloïde.</p>
<!--TOC subsection id="sec122" Allure des courbes en dimension 2.-->
<h3 id="sec122" class="subsection">14.3.6  Allure des courbes en dimension 2.</h3><!--SEC END --><p>
Si on se place dans le repère propre (en prenant les vecteurs
propres comme vecteurs de base), et si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> a deux valeurs
propres distinctes (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est alors diagonalisable),
alors chaque coordonnée suit une exponentielle, dans ce repère
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>&alpha;</mi><msup><mi>e</mi> <mrow><mi>a</mi><mi>t</mi></mrow></msup><mo>,</mo><mi>&beta;</mi><msup><mi>e</mi> <mrow><mi>b</mi><mi>t</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)=(\alpha e^{at}, \beta e^{bt})</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&ne;</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>a \neq b</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>
sont réels, l’une des exponentielles domine l’autre lorsque
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t\rightarrow +\infty</annotation></semantics></math> et c’est l’inverse lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t\rightarrow
&#x2d;\infty</annotation></semantics></math>, la courbe est donc asymptote aux directions propres.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> sont complexes conjugués de partie réelle non nulle, 
on a une spirale qui
tend vers 0 d’un coté et vers l’infini de l’autre (selon le signe
de la partie réelle). Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est
symétrique, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> sont réels, ce cas ne peut
pas se produire, de plus on peut choisir un repère propre
orthonormé, les courbes ressemblent à des hyperboles.
Ce sont des hyperboles si trace<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>(A)=0</annotation></semantics></math> (la somme des valeurs
propres vaut 0 donc le produit des coordonnées dans
le repère propre vaut une constante),
ces hyperboles sont équilatères si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est symétrique.
Quelques exemples :
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">A:=[[-1,1],[1,2]];p,d:=jordan(A) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">A:=[[1,-1],[2,4]];p,d:=jordan(A) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">A:=[[0,1],[-1,0]];p,d:=jordan(A) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<br><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:400px;font-size:large">A:=[[1,1],[-1,1]];p,d:=jordan(A) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML='&nbsp;'+tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">seq(seq(
plotparam(exp(A*t)*[a/5,b/5],t=-1..1,affichage=arrow_line),
a,-3,3),b,-3,3)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</p><p><span style="font-weight:bold">Remarque :</span>pour un système différentiel à coefficients
non constants, il n’existe pas de méthode générale de
résolution. Il arrive que dans certains cas particuliers,
on puisse résoudre le système, par exemple si on trouve
une matrice de passage indépendante du temps ramenant
le système à un système diagonal ou triangulaire :
un exemple avec
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mn>1</mn><mo>+</mo><mi>t</mi></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mtd> <mtd><mn>1</mn><mo>+</mo><mi>t</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>A=\left(\begin{array}{cc} 1+t &amp; &#x2d;t \\ &#x2d;t &amp; 1+t\end{array}\right) </annotation></semantics></math>
Ou si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&Integral;</mo><mi>A</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int A(t) \ dt</annotation></semantics></math> commute avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, on peut prendre 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>exp</mi><mo stretchy="false">(</mo><mo>&Integral;</mo><mi>A</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\exp(\int A(t))</annotation></semantics></math> comme solution.</p>
<!--TOC subsection id="sec123" Systèmes d’ordre plus grand que 1-->
<h3 id="sec123" class="subsection">14.3.7  Systèmes d’ordre plus grand que 1</h3><!--SEC END --><p>
On se ramène à un système d’ordre 1.
Par exemple deux ressorts couplés
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>{</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mover><mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow><mo>&Dot;</mo></mover></mtd> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><msup><mi>&omega;</mi> <mn>2</mn></msup><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><msup><mi>&omega;</mi> <mn>2</mn></msup><msub><mi>x</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><mover><mrow><msub><mi>x</mi> <mn>2</mn></msub></mrow><mo>&Dot;</mo></mover></mtd> <mtd><mo>=</mo></mtd> <mtd><msup><mi>&omega;</mi> <mn>2</mn></msup><msub><mi>x</mi> <mn>1</mn></msub><mo>&minus;</mo><mn>2</mn><msup><mi>&omega;</mi> <mn>2</mn></msup><msub><mi>x</mi> <mn>2</mn></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'>\left\{ 
\begin{array}{ccc}
\ddot{x_1}&amp;=&amp;&#x2d;2\omega^2 x_1+\omega^2 x_2\\
\ddot{x_2}&amp;=&amp;\omega^2 x_1&#x2d;2\omega^2x_2
\end{array}
\right.  </annotation></semantics></math>
on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>2</mn></msub><mo>,</mo><mover><mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow><mo>&dot;</mo></mover><mo>,</mo><mover><mrow><msub><mi>x</mi> <mn>2</mn></msub></mrow><mo>&dot;</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Y=(x_1,x_2,\dot{x_1},\dot{x_2})</annotation></semantics></math>, on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mover><mi>Y</mi><mo>&dot;</mo></mover><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mover><mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow><mo>&dot;</mo></mover></mtd></mtr> <mtr><mtd><mover><mrow><msub><mi>x</mi> <mn>2</mn></msub></mrow><mo>&dot;</mo></mover></mtd></mtr> <mtr><mtd><mover><mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow><mo>&Dot;</mo></mover></mtd></mtr> <mtr><mtd><mover><mrow><msub><mi>x</mi> <mn>2</mn></msub></mrow><mo>&Dot;</mo></mover></mtd></mtr></mtable><mo>)</mo></mrow><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mo>&sdot;</mo><msup><mi>&omega;</mi> <mn>2</mn></msup></mtd> <mtd><msup><mi>&omega;</mi> <mn>2</mn></msup></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><msup><mi>&omega;</mi> <mn>2</mn></msup></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mo>&sdot;</mo><msup><mi>&omega;</mi> <mn>2</mn></msup></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><msub><mi>x</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>x</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><mover><mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow><mo>&dot;</mo></mover></mtd></mtr> <mtr><mtd><mover><mrow><msub><mi>x</mi> <mn>2</mn></msub></mrow><mo>&dot;</mo></mover></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\dot{Y}=\left(
\begin{array}{c}\dot{x_1}\\\dot{x_2}\\\ddot{x_1}\\\ddot{x_2}\end{array}
\right)
=\left(\begin{array}{cccc}
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
&#x2d;2\cdot \omega^{2} &amp; \omega^{2} &amp; 0 &amp; 0 \\
\omega^{2} &amp; &#x2d;2\cdot \omega^{2} &amp; 0 &amp; 0
\end{array}\right) 
\left(
\begin{array}{c}x_1\\x_2\\\dot{x_1}\\\dot{x_2}\end{array}
\right)
 </annotation></semantics></math> 
On délègue le calcul des valeurs propres à la machine :
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">assume(omega>0);a:=omega^2*[[-2,1],[1,-2]] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">A:=blockmatrix(2,2,[0*idn(2),idn(2),a,0*idn(2)]) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">p,d:=jordan(A) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

Les valeurs propres sont <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&pm;</mo><mi>i</mi><mi>&omega;</mi><mo>,</mo><mo>&pm;</mo><mi>i</mi><msqrt><mn>3</mn></msqrt><mi>&omega;</mi></mrow><annotation encoding='application/x-tex'>\pm i \omega, \pm i\sqrt{3} \omega</annotation></semantics></math> imaginaires
pures, donc les solutions du système sont périodiques
de fréquence <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&omega;</mi></mrow><annotation encoding='application/x-tex'>\omega</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>3</mn></msqrt><mi>&omega;</mi></mrow><annotation encoding='application/x-tex'>\sqrt{3}\omega</annotation></semantics></math>, qui sont des fréquences
intrinsèques du système. Si on ajoute un second membre
périodique de période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Omega;</mi></mrow><annotation encoding='application/x-tex'>\Omega</annotation></semantics></math>, lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Omega;</mi><mo>&ne;</mo><mi>&omega;</mi></mrow><annotation encoding='application/x-tex'>\Omega \neq \omega</annotation></semantics></math> et 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Omega;</mi><mo>&ne;</mo><msqrt><mn>3</mn></msqrt><mi>&omega;</mi></mrow><annotation encoding='application/x-tex'>\Omega \neq \sqrt{3}\omega</annotation></semantics></math>, il y a une solution particulière
de fréquence <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Omega;</mi></mrow><annotation encoding='application/x-tex'>\Omega</annotation></semantics></math> et les solutions sont bornées (3 fréquences),
par contre si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Omega;</mi><mo>=</mo><mi>&omega;</mi></mrow><annotation encoding='application/x-tex'>\Omega=\omega</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Omega;</mi><mo>=</mo><msqrt><mn>3</mn></msqrt><mi>&omega;</mi></mrow><annotation encoding='application/x-tex'>\Omega=\sqrt{3}\omega</annotation></semantics></math>, il y a résonance.</p>
<!--TOC subsection id="sec124" Intégrales premières.-->
<h3 id="sec124" class="subsection">14.3.8  Intégrales premières.</h3><!--SEC END --><p><a id="hevea_default147"></a><a id="hevea_default148"></a>
Lorsqu’on ne sait pas résoudre explicitement une équation
ou un système différentiel, il peut arriver qu’on connaisse
une ou des constantes du mouvement en cinématique, appelées
aussi intégrales premières. </p><p>C’est le cas par exemple de
l’énergie totale (mécanique plus cinétique) pour des forces
conservatives. En dimension un, la connaissance de l’intégrale 
première énergie
totale permet de ramener l’équation fondamentale de la
dynamique d’ordre 2 à une équation
du premier ordre à variables séparables :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>m</mi><mi>x</mi><msup><mo>&prime;</mo> <mn>2</mn></msup><mo>+</mo><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi></mrow><annotation encoding='application/x-tex'>\frac{1}{2} m x&apos;^2+ V(x) = E  </annotation></semantics></math>
soit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><msqrt><mfrac><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>E</mi><mo>&minus;</mo><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mi>m</mi></mfrac></msqrt></mrow><annotation encoding='application/x-tex'>\frac{dx}{dt} = \sqrt{\frac{2(E&#x2d;V(x))}{m}} </annotation></semantics></math>
donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><msqrt><mfrac><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>E</mi><mo>&minus;</mo><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mi>m</mi></mfrac></msqrt></mfrac><mo>=</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\frac{dx}{\sqrt{\frac{2(E&#x2d;V(x))}{m}}}=dt </annotation></semantics></math>
on peut ainsi calculer le temps en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> et tracer
le graphe de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> puis le graphe de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> en fonction
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> par symétrie
par rapport à la première bissectrice.</p><p>Exemple : calcul de la période d’un pendule, on repère
une masse reliée à un fil de longueur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> à un point fixe
par l’angle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&theta;</mi></mrow><annotation encoding='application/x-tex'>\theta</annotation></semantics></math> formé avec la verticale (orienté vers le
bas), de sorte que
l’énergie potentielle de la masse est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>m</mi><mi>g</mi><mi>l</mi><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;mgl\cos(\theta)</annotation></semantics></math>
on a donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>m</mi><msup><mi>l</mi> <mn>2</mn></msup><msup><mover><mi>&theta;</mi><mo>&dot;</mo></mover> <mn>2</mn></msup><mo>&minus;</mo><mi>m</mi><mi>g</mi><mi>l</mi><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi></mrow><annotation encoding='application/x-tex'>\frac{1}{2} m l^2\dot{\theta}^2&#x2d;mgl\cos(\theta)=E </annotation></semantics></math>
puis
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mover><mi>&theta;</mi><mo>&dot;</mo></mover><mo>=</mo><msqrt><mfrac><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>E</mi><mo>+</mo><mi>m</mi><mi>g</mi><mi>l</mi><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mi>m</mi><msup><mi>l</mi> <mn>2</mn></msup></mrow></mfrac></msqrt></mrow><annotation encoding='application/x-tex'>\dot{\theta}=\sqrt{\frac{2(E+mgl\cos(\theta))}{ml^2}} </annotation></semantics></math>
Si on lache sans vitesse initiale la masse avec un angle 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&theta;</mi> <mn>0</mn></msub><mo>&Element;</mo><mo stretchy="false">]</mo><mo>&minus;</mo><mi>&pi;</mi><mo>,</mo><mi>&pi;</mi><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>\theta_0 \in ]&#x2d;\pi,\pi[</annotation></semantics></math> alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>m</mi><mi>g</mi><mi>l</mi><mi>cos</mi><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>E=&#x2d;mgl\cos(\theta_0)</annotation></semantics></math> donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mover><mi>&theta;</mi><mo>&dot;</mo></mover><mo>=</mo><msqrt><mrow><mn>2</mn><mfrac><mi>g</mi><mi>l</mi></mfrac><mo stretchy="false">(</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>cos</mi><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></msqrt></mrow><annotation encoding='application/x-tex'>\dot{\theta}=\sqrt{2\frac{g}{l}(\cos(\theta)&#x2d;\cos(\theta_0))} </annotation></semantics></math>
puis
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>d</mi><mi>&theta;</mi></mrow><msqrt><mrow><mn>2</mn><mfrac><mi>g</mi><mi>l</mi></mfrac><mo stretchy="false">(</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>cos</mi><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></msqrt></mfrac><mo>=</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\frac{d\theta}{\sqrt{2\frac{g}{l}(\cos(\theta)&#x2d;\cos(\theta_0))}}
= dt  </annotation></semantics></math>
Pour des raisons de symétrie, la période du pendule est donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>T</mi><mo>=</mo><mn>4</mn><msubsup><mo>&Integral;</mo> <mrow><mi>t</mi><mo stretchy="false">/</mo><mi>&theta;</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow> <mrow><mi>t</mi><mo stretchy="false">/</mo><mi>&theta;</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>&theta;</mi> <mn>0</mn></msub></mrow></msubsup><mi>d</mi><mi>t</mi><mo>=</mo><mn>4</mn><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><msub><mi>&theta;</mi> <mn>0</mn></msub></mrow></msubsup><mfrac><mrow><mi>d</mi><mi>&theta;</mi></mrow><msqrt><mrow><mn>2</mn><mfrac><mi>g</mi><mi>l</mi></mfrac><mo stretchy="false">(</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>cos</mi><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></msqrt></mfrac></mrow><annotation encoding='application/x-tex'>T=4\int_{t/\theta(t)=0}^{t/\theta(t)=\theta_0} dt 
=4 \int_0^{\theta_0} \frac{d\theta}{\sqrt{2\frac{g}{l}(\cos(\theta)&#x2d;\cos(\theta_0))}}  </annotation></semantics></math>
L’expression à intégrer n’admet pas de primitive avec les fonctions
usuelles, on l’appelle intégrale elliptique (il y a un lien avec
la longueur d’un arc d’ellipse). On peut calculer une valeur numérique
approchée de cette intégrale si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&theta;</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\theta_0</annotation></semantics></math> est donné.
<br><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:400px;font-size:large">theta0:=0.78; 4/sqrt(g/l)*int(1/sqrt(2*(cos(theta)-cos(theta0))),theta,0,theta0) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML='&nbsp;'+tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><span></span><br>

Pour de petites valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&theta;</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\theta_0</annotation></semantics></math>, on peut approcher 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\cos(\theta)</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>&theta;</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>1&#x2d;\theta^2/2</annotation></semantics></math> et calculer l’intégrale
<br><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:400px;font-size:large">assume(theta0>0); 4/sqrt(g/l)*int(1/sqrt(theta0^2-theta^2),theta,0,theta0) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML='&nbsp;'+tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><span></span><br>

qui ne dépend pas de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&theta;</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\theta_0</annotation></semantics></math>. On observe que cette approximation 
est encore assez bonne pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&theta;</mi> <mn>0</mn></msub><mi>&lt;</mi><mi>&pi;</mi><mo stretchy="false">/</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>\theta_0&amp;lt;\pi/4</annotation></semantics></math> (erreur&lt;4%).</p><p>En dimension plus grande, l’existence d’intégrales
premières peut permettre de 
connaitre la forme de la courbe intégrale et même
parfois de résoudre complètement l’équation (cas du problème
à deux corps ci-dessous).</p><p>Autre exemple, la découverte d’un facteur 
intégrant pour la forme différentielle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mi>d</mi><mi>x</mi><mo>+</mo><mi>N</mi><mi>d</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>Mdx+Ndy</annotation></semantics></math>
donne une intégrale première pour l’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mi>y</mi><mo stretchy="false">/</mo><mi>d</mi><mi>x</mi><mo>=</mo><mi>M</mi><mo stretchy="false">/</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>dy/dx=M/N</annotation></semantics></math>,
en effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&omega;</mi><mo>=</mo><mi>&#x03D5;</mi><mo stretchy="false">(</mo><mi>M</mi><mi>d</mi><mi>x</mi><mo>+</mo><mi>N</mi><mi>d</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\omega=\phi(Mdx+Ndy)=dV(x,y)</annotation></semantics></math> est nul
sur une courbe intégrale, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>V(x,y)</annotation></semantics></math>
est constant, les courbes intégrales sont donc 
les courbes de niveau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>V(x,y)</annotation></semantics></math>. Une équation à variables
séparables est un cas particulier, avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> ne dépendant que de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>.</p><p>Pour un système autonome, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi></mrow><annotation encoding='application/x-tex'>E</annotation></semantics></math> est une intégrale première si
grad<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mo>.</mo><mi>f</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>(E).f=0</annotation></semantics></math>, en effet
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mi>E</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mfrac><mrow><mo>&PartialD;</mo><mi>E</mi></mrow><mrow><mo>&PartialD;</mo><msub><mi>y</mi> <mi>j</mi></msub></mrow></mfrac><msub><mi>f</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\frac{d}{dt} E(y(t))= \sum_{j=1}^n \frac{\partial E}{\partial y_j} f_j </annotation></semantics></math></p><p><span style="font-weight:bold">Problème à deux corps </span> 
Cas d’un point de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^3</annotation></semantics></math>
soumis à une force centrale<a id="hevea_default149"></a><a id="hevea_default150"></a>
comme la gravité ou la force coulombienne :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><msup><mi>d</mi> <mn>2</mn></msup><mstyle mathvariant="bold"><mi>r</mi></mstyle></mrow><mrow><mi>d</mi><msup><mi>t</mi> <mn>2</mn></msup></mrow></mfrac><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&mu;</mi><mfrac><mstyle mathvariant="bold"><mi>r</mi></mstyle><mrow><msup><mi>r</mi> <mn>3</mn></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{d^2 {\mathbf r}}{dt^2}=&#x2d;\mu \frac{{\mathbf r}}{r^3} </annotation></semantics></math> 
on montre
</p><ul class="itemize"><li class="li-itemize">
la conservation du moment cinétique 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mstyle mathvariant="bold"><mi>L</mi></mstyle><mo>=</mo><mstyle mathvariant="bold"><mi>r</mi></mstyle><mo>&wedge;</mo><mfrac><mrow><mi>d</mi><mstyle mathvariant="bold"><mi>r</mi></mstyle></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding='application/x-tex'>{\bf L}=
{\mathbf r} \wedge \frac{d {\mathbf r}}{dt} </annotation></semantics></math>
(vérification immédiate en dérivant).
Ceci entraine que
le mouvement est dans un plan orthogonal à 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mstyle mathvariant="bold"><mi>L</mi></mstyle><mo>=</mo><mi>L</mi><mover><mi>k</mi><mo>&RightVector;</mo></mover></mrow><annotation encoding='application/x-tex'>{\mathbf L}=L \overrightarrow{k}</annotation></semantics></math>
et la loi des aires (où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&theta;</mi></mrow><annotation encoding='application/x-tex'>\theta</annotation></semantics></math> est l’angle formé par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mstyle mathvariant="bold"><mi>r</mi></mstyle></mrow><annotation encoding='application/x-tex'>{\mathbf r}</annotation></semantics></math> avec une direction fixe du plan) :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>r</mi> <mn>2</mn></msup><mfrac><mrow><mi>d</mi><mi>&theta;</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mi>L</mi></mrow><annotation encoding='application/x-tex'>r^2 \frac{d\theta}{dt}=L </annotation></semantics></math>
(ceci est vrai dès que la force est centrale, indépendamment
de la norme de la force)
</li><li class="li-itemize">la conservation du vecteur excentricité défini par :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mstyle mathvariant="bold"><mi>E</mi></mstyle><mo>=</mo><mfrac><mn>1</mn><mi>&mu;</mi></mfrac><mfrac><mrow><mi>d</mi><mstyle mathvariant="bold"><mi>r</mi></mstyle></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>&wedge;</mo><mstyle mathvariant="bold"><mi>L</mi></mstyle><mo>&minus;</mo><mfrac><mstyle mathvariant="bold"><mi>r</mi></mstyle><mi>r</mi></mfrac><mo>=</mo><mfrac><mi>L</mi><mi>&mu;</mi></mfrac><mfrac><mrow><mi>d</mi><mstyle mathvariant="bold"><mi>r</mi></mstyle></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>&wedge;</mo><mover><mi>k</mi><mo>&RightVector;</mo></mover><mo>&minus;</mo><mover><mrow><msub><mi>e</mi> <mi>r</mi></msub></mrow><mo>&RightVector;</mo></mover></mrow><annotation encoding='application/x-tex'> {\mathbf E}= \frac{1}{\mu} \frac{d{\mathbf r}}{dt} \wedge 
{\mathbf L} &#x2d; \frac{{\mathbf r}}{r} 
= \frac{L }{\mu} \frac{d{\mathbf r}}{dt} \wedge 
\overrightarrow{k} &#x2d; \overrightarrow{e_r}  </annotation></semantics></math>
En effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mover><mrow><msub><mi>e</mi> <mi>r</mi></msub></mrow><mo>&RightVector;</mo></mover><mo stretchy="false">/</mo><mi>d</mi><mi>t</mi><mo>=</mo><mi>d</mi><mi>&theta;</mi><mo stretchy="false">/</mo><mi>d</mi><mi>t</mi><mover><mrow><msub><mi>e</mi> <mi>&theta;</mi></msub></mrow><mo>&RightVector;</mo></mover></mrow><annotation encoding='application/x-tex'>d \overrightarrow{e_r}/dt=d\theta/dt
\overrightarrow{e_\theta}</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">{</mo><mover><mrow><msub><mi>e</mi> <mi>r</mi></msub></mrow><mo>&RightVector;</mo></mover><mo>,</mo><mover><mrow><msub><mi>e</mi> <mi>&theta;</mi></msub></mrow><mo>&RightVector;</mo></mover><mo>,</mo><mover><mi>k</mi><mo>&RightVector;</mo></mover><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>\{ \overrightarrow{e_r},
\overrightarrow{e_\theta}, \overrightarrow{k} \}</annotation></semantics></math> est orthonormé direct
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mo>=</mo><msup><mi>r</mi> <mn>2</mn></msup><mi>d</mi><mi>&theta;</mi><mo stretchy="false">/</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>L=r^2 d\theta/dt</annotation></semantics></math>.
</li></ul><p>
Si on prend l’axe des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> porté par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mstyle mathvariant="bold"><mi>E</mi></mstyle></mrow><annotation encoding='application/x-tex'>{\mathbf E}</annotation></semantics></math>,
en faisant le produit scalaire avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mstyle mathvariant="bold"><mi>r</mi></mstyle></mrow><annotation encoding='application/x-tex'>{\mathbf r}</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>r</mi><mi>E</mi><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle mathvariant="bold"><mi>r</mi></mstyle><mo>.</mo><mstyle mathvariant="bold"><mi>E</mi></mstyle><mo>=</mo><mfrac><mn>1</mn><mi>&mu;</mi></mfrac><mo stretchy="false">(</mo><mfrac><mrow><mi>d</mi><mstyle mathvariant="bold"><mi>r</mi></mstyle></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>&wedge;</mo><mstyle mathvariant="bold"><mi>L</mi></mstyle><mo stretchy="false">)</mo><mo>.</mo><mstyle mathvariant="bold"><mi>r</mi></mstyle><mo>&minus;</mo><mi>r</mi></mrow><annotation encoding='application/x-tex'>rE \cos(\theta)={\mathbf r}.{\mathbf E}
= \frac{1}{\mu} 
(\frac{d{\mathbf r}}{dt} \wedge {\mathbf L}) . {\mathbf r} &#x2d; r </annotation></semantics></math>
on obtient en appliquant les propriétés du produit mixte et la
définition de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mstyle mathvariant="bold"><mi>L</mi></mstyle></mrow><annotation encoding='application/x-tex'>{\mathbf L}</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>r</mi><mo>=</mo><mfrac><mrow><msup><mi>L</mi> <mn>2</mn></msup></mrow><mrow><mi>&mu;</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>E</mi><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> r = \frac{L^2}{\mu(1+E \cos(\theta))} </annotation></semantics></math>
la courbe intégrale est donc une conique d’excentricité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi></mrow><annotation encoding='application/x-tex'>E</annotation></semantics></math>
ayant l’origine pour foyer et parcourue selon la loi des aires
(l’aire balayée par le segment origine-point mobile est
proportionnelle au temps).</p>
<!--TOC subsection id="sec125" Le modèle proie-prédateur-->
<h3 id="sec125" class="subsection">14.3.9  Le modèle proie-prédateur</h3><!--SEC END --><p>
<a id="hevea_default151"></a>
<a id="hevea_default152"></a>
C’est un système autonome en dimension 2 pour lequel on sait
calculer une intégrale première. Il se présente sous la forme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mover><mi>x</mi><mo>&dot;</mo></mover></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi><mi>y</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mover><mi>y</mi><mo>&dot;</mo></mover></mtd> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>y</mi><mo stretchy="false">(</mo><mi>c</mi><mo>&minus;</mo><mi>d</mi><mi>x</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
\dot{x}&amp;=&amp;x(a&#x2d;by)\\
\dot{y}&amp;=&amp;&#x2d;y(c&#x2d;dx)
 \end{matrix} </annotation></semantics></math>
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>a,b,c,d</annotation></semantics></math> des constantes positives, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> l’effectif des proies,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> celui des prédateurs,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> correspond à la reproduction naturelle des proies, 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> à la mortalité par
rencontre d’un prédateur, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> à la mortalité naturelle
des prédateurs et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> à la natalité dépendant du nombre de
proies.
On peut déterminer les points d’équilibre et leur stabilité
comme pour n’importe quel système autonome (exercice),
on trouve <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(0,0)</annotation></semantics></math> qui est instable et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">/</mo><mi>d</mi><mo>,</mo><mi>a</mi><mo stretchy="false">/</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(c/d,a/b)</annotation></semantics></math>, les valeurs propres
du linéarisé 
sont 2 imaginaires purs conjugués, donc on ne peut pas conclure sur
la stabilité à ce stade.</p><p>On peut déterminer une intégrale première en faisant apparaitre
des dérivées logarthmiques
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi><mi>y</mi><mo>,</mo><mspace width="1em"/><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>c</mi><mo>+</mo><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>\frac{d}{dt}(\ln(x))=a&#x2d;by, \quad \frac{d}{dt}(\ln(y))=&#x2d;c+dx  </annotation></semantics></math>
donc en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>=</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mi>Y</mi><mo>=</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>X=\ln(x), Y=\ln(y)</annotation></semantics></math> on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mover><mi>X</mi><mo>&dot;</mo></mover><mo>=</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi><msup><mi>e</mi> <mi>Y</mi></msup><mo>,</mo><mspace width="1em"/><mover><mi>Y</mi><mo>&dot;</mo></mover><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>c</mi><mo>+</mo><mi>d</mi><msup><mi>e</mi> <mi>X</mi></msup></mrow><annotation encoding='application/x-tex'>\dot{X}=a&#x2d;be^Y, \quad \dot{Y}=&#x2d;c+de^X </annotation></semantics></math>
d’où :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mover><mi>X</mi><mo>&dot;</mo></mover><mo stretchy="false">(</mo><mi>d</mi><msup><mi>e</mi> <mi>X</mi></msup><mo>&minus;</mo><mi>c</mi><mo stretchy="false">)</mo><mo>+</mo><mover><mi>Y</mi><mo>&dot;</mo></mover><mo stretchy="false">(</mo><mi>b</mi><msup><mi>e</mi> <mi>Y</mi></msup><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>\dot{X} (de^X&#x2d;c) + \dot{Y}(be^Y&#x2d;a)=0 </annotation></semantics></math>
donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><msup><mi>e</mi> <mi>X</mi></msup><mo>&minus;</mo><mi>c</mi><mi>X</mi><mo>+</mo><mi>b</mi><msup><mi>e</mi> <mi>Y</mi></msup><mo>&minus;</mo><mi>a</mi><mi>Y</mi></mrow><annotation encoding='application/x-tex'>f(X,Y)=de^X&#x2d;cX+be^Y&#x2d;aY </annotation></semantics></math>
est une intégrale première du mouvement, qui se passe donc sur
les courbes de niveau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(X,Y)</annotation></semantics></math> ou de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mi>x</mi><mo>&minus;</mo><mi>c</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi><mi>y</mi><mo>&minus;</mo><mi>a</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>dx&#x2d;c\ln(x)+by&#x2d;a\ln(y)</annotation></semantics></math>
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x,y)</annotation></semantics></math>. On observe que ces courbes de niveau sont fermées, 
impliquant un mouvement périodique, si on exprime <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> en fonction
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> par le théorème des fonctions implicites donc sur toute la
courbe à l’exception des deux points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mo>&pm;</mo></msub></mrow><annotation encoding='application/x-tex'>x_\pm</annotation></semantics></math> où la tangente est verticale
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>d</mi><mi>x</mi><mo>&minus;</mo><mi>c</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi><mi>y</mi><mo>&minus;</mo><mi>a</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>K</mi><mo>&Rightarrow;</mo><mi>y</mi><mo>=</mo><msub><mi>y</mi> <mo>&pm;</mo></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>dx&#x2d;c\ln(x)+by&#x2d;a\ln(y)=K \Rightarrow y=y_{\pm}(x) </annotation></semantics></math>
alors on peut calculer la période du mouvement en appliquant :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\frac{dx}{x(a&#x2d;by(x))}=dt </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>T</mi><mo>=</mo><mo>&Integral;</mo><mi>d</mi><mi>t</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mrow><msub><mi>x</mi> <mo>&minus;</mo></msub></mrow> <mrow><msub><mi>x</mi> <mo>+</mo></msub></mrow></msubsup><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi><msub><mi>y</mi> <mo>+</mo></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><msubsup><mo>&Integral;</mo> <mrow><msub><mi>x</mi> <mo>+</mo></msub></mrow> <mrow><msub><mi>x</mi> <mo>&minus;</mo></msub></mrow></msubsup><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>x</mi><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi><msub><mi>y</mi> <mo>&minus;</mo></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>T=\int dt = \int_{x_&#x2d;}^{x_+}  \frac{dx}{x(a&#x2d;by_+(x))}
+ \int_{x_+}^{x_&#x2d;}  \frac{dx}{x(a&#x2d;by_&#x2d;(x))}
 </annotation></semantics></math></p>
<!--TOC subsection id="sec126" Quelques autres méthodes-->
<h3 id="sec126" class="subsection">14.3.10  Quelques autres méthodes</h3><!--SEC END --><p>
On peut encore citer : 
changement de fonction, changement de variables, 
équation homogène, équations de Bernoulli,
de Clairault, de Ricatti, développements en séries
entières..., certaines de ces méthodes sont
implémentées par les logiciels de calcul formel.</p>
<!--TOC section id="sec127" Comportement asymptotique des solutions-->
<h2 id="sec127" class="section">14.4  Comportement asymptotique des solutions</h2><!--SEC END --><p>
Les équations de la physique sont souvent des équations
autonomes sans second membre (pas de dépendance explicite en temps) 
ou avec un second membre
qui est le seul terme de l’équation dépendant du temps (il
s’agit d’un forçage extérieur). Dans le premier cas,
les solutions doivent rester bornées (par exemple en énergie), donc
ne peuvent pas tendre vers l’infini. Dans le second cas,
une question naturelle
est alors la suivante : le système atteint-il un équilibre,
peut-on décomposer la solution en deux parties : un régime
permanent et un régime transitoire ?</p><p>On a déjà fait une étude de comportement asymptotique
pour l’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=y(1&#x2d;y)</annotation></semantics></math>, la solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y=0</annotation></semantics></math> se comporte
comme un point déquilibre instable, si on en dévie même
légèrement, on s’en éloigne définitivement, alors que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>y=1</annotation></semantics></math> se
comporte comme un point déquilibre stable.
Nous allons généraliser cette étude, pour les équations
linéaires à coefficients constants (avec ou sans second membre,
perturbation dépendant du temps),
les équations autonomes sans second membre,
et dans le cas de systèmes différentiels linéaires à
coefficients constants.</p>
<!--TOC subsection id="sec128" Équations linéaires à coefficients constants 
d’ordre 1 et 2-->
<h3 id="sec128" class="subsection">14.4.1  Équations linéaires à coefficients constants 
d’ordre 1 et 2</h3><!--SEC END --><p>
Pour les équations homogènes d’ordre 1 <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>a</mi><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;+ay=0</annotation></semantics></math>, 
la solution générale est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>a</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=Ce^{&#x2d;at}</annotation></semantics></math>, le comportement
asymptotique lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t \rightarrow +\infty</annotation></semantics></math> dépend du signe
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math>, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>a&amp;gt;0</annotation></semantics></math> la limite est 0 et la solution décroit
exponentiellement vite. Donc si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>a&amp;gt;0</annotation></semantics></math>, quelle
que soit la condition initiale, toutes les solutions de 
l’équation avec second membre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>a</mi><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;+ay=f(t)</annotation></semantics></math> ont
le même comportement asymptotique, celui
d’une solution particulière de l’équation :on a donc
un régime transitoire exponentiellement décroissant
et un régime permanent.</p><p>Pour les équations homogènes d’ordre 2 <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>y</mi><mo>&prime;</mo><mo>&prime;</mo><mo>+</mo><mi>b</mi><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>c</mi><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>ay&apos;{&apos;}+by&apos;+cy=0</annotation></semantics></math>,
la solution générale est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mn>1</mn></msub><mi>t</mi></mrow></msup><mo>+</mo><mi>B</mi><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mn>2</mn></msub><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>y(t)=Ae^{r_1t}+Be^{r_2t}</annotation></semantics></math>
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>r_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>r_2</annotation></semantics></math> sont les deux racines simples de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><msup><mi>r</mi> <mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>r</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>ar^2+br+c=0</annotation></semantics></math>
ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi> <mrow><msub><mi>r</mi> <mn>1</mn></msub><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>A</mi><mo>+</mo><mi>B</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)=e^{r_1t}(A+Bt)</annotation></semantics></math> si l’équation caractéristique admet
une racine double. Le comportement à l’infini dépend
du signe de la partie réelle de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>r_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>r_2</annotation></semantics></math>. Il faut que
les deux parties réelles soient strictement négatives pour que 
la solution tende vers 0, à vitesse exponentielle, si l’une au moins
des parties réelles est positive ou nulle, alors il n’y a pas
convergence vers 0. Plus précisément
</p><ul class="itemize"><li class="li-itemize">
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo>=</mo><msup><mi>b</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>4</mn><mi>a</mi><mi>c</mi><mi>&lt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\Delta=b^2&#x2d;4ac&amp;lt;0</annotation></semantics></math>, il y a deux racines complexes
conjuguées distinctes de partie réelle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>b</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;b/(2a)</annotation></semantics></math>, donc la
solution décroit exponentiellement vers 0 si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo stretchy="false">/</mo><mi>a</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>b/a&amp;gt;0</annotation></semantics></math>,
comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>b</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mi>a</mi><mo stretchy="false">)</mo><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{&#x2d;b/(2a)t}</annotation></semantics></math>, avec des oscillations périodiques
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>i</mi><msqrt><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&Delta;</mi></mrow></msqrt><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mi>a</mi><mo stretchy="false">)</mo><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{i\sqrt{&#x2d;\Delta}/(2a)t}</annotation></semantics></math>, de période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo>=</mo><mn>4</mn><mi>&pi;</mi><mi>a</mi><mo stretchy="false">/</mo><msqrt><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&Delta;</mi></mrow></msqrt></mrow><annotation encoding='application/x-tex'>T=4\pi
a/\sqrt{&#x2d;\Delta}</annotation></semantics></math> (régime oscillatoire amorti enveloppé
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>b</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mi>a</mi><mo stretchy="false">)</mo><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{&#x2d;b/(2a)t}</annotation></semantics></math>). 
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>b=0</annotation></semantics></math>, la solution ne tend pas vers 0, reste de taille bornée,
elle est périodique de période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo>=</mo><mn>4</mn><mi>&pi;</mi><mi>a</mi><mo stretchy="false">/</mo><msqrt><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&Delta;</mi></mrow></msqrt></mrow><annotation encoding='application/x-tex'>T=4\pi a/\sqrt{&#x2d;\Delta}</annotation></semantics></math>
(régime oscillatoire)
</li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo>=</mo><msup><mi>b</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>4</mn><mi>a</mi><mi>c</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\Delta=b^2&#x2d;4ac&amp;gt;0</annotation></semantics></math>, on a deux racines réelles distinctes,
qui sont toutes les deux strictement négatives si l’opposé de
leur somme et leur produit sont positifs : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo stretchy="false">/</mo><mi>a</mi><mi>&gt;</mi><mn>0</mn><mo>,</mo><mi>c</mi><mo stretchy="false">/</mo><mi>a</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>b/a&amp;gt;0, c/a&amp;gt;0</annotation></semantics></math>
(régime amorti équivalent à la plus grande des deux
exponentielles)
</li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo>=</mo><msup><mi>b</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>4</mn><mi>a</mi><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>\Delta=b^2&#x2d;4ac=0</annotation></semantics></math>, on a une racine double <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>b</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;b/(2a)</annotation></semantics></math>,
il y a convergence vers 0 si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo stretchy="false">/</mo><mi>a</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>b/a&amp;gt;0</annotation></semantics></math>.
</li><li class="li-itemize">Dans tous les autres cas, la partie réelle d’une
des racines est positive ou nulle et il n’y a pas de convergence
vers 0 de la solution générale. Si on a deux racines
imaginaires pures conjuguées, la solution est périodique,
sinon la solution tend vers l’infini pour une condition initiale
générique.
</li></ul><p><span style="font-weight:bold">Exemples </span>
</p><ul class="itemize"><li class="li-itemize">
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>&prime;</mo><mo>+</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;{&apos;}+y=0</annotation></semantics></math>, deux racines imaginaires pures conjuguées,
solution générale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi><mi>cos</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>a\sin(x)+b\cos(x)</annotation></semantics></math> périodique
</li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>&prime;</mo><mo>+</mo><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;{&apos;}+y&apos;+y=0</annotation></semantics></math>, deux racines complexes conjuguées de partie
réelle négative, il y a convergence exponentielle vers 0 avec
des oscillations, la
solution générale est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><mo stretchy="false">/</mo><mn>2</mn></mrow></msup><mo stretchy="false">(</mo><mi>a</mi><mi>cos</mi><mo stretchy="false">(</mo><msqrt><mn>3</mn></msqrt><mi>x</mi><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi><mi>sin</mi><mo stretchy="false">(</mo><msqrt><mn>3</mn></msqrt><mi>x</mi><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>e^{&#x2d;x/2}(a \cos(\sqrt{3}x/2) + b
\sin(\sqrt{3}x/2))</annotation></semantics></math>.
</li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>&prime;</mo><mo>&minus;</mo><mn>2</mn><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;{&apos;}&#x2d;2y&apos;&#x2d;3y=0</annotation></semantics></math>, deux racines réelles, une positive, une
négative. La solution générale est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><msup><mi>e</mi> <mi>x</mi></msup><mo>+</mo><mi>b</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn><mi>x</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>ae^x+be^{&#x2d;3x}</annotation></semantics></math>, elle
tend génériquement vers l’infini (sauf condition initiale annulant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math>).
</li><li class="li-itemize">...
</li></ul><p>On peut généraliser à un ordre quelconque.
Si toutes les racines de l’équation caractéristique sont
de partie réelle négative, la solution générale
de l’équation homogène tend vers 0 à l’infini,
elle est appelée régime transitoire. Quelle que
soit la condition initiale, on tend vers la solution particulière
appelée régime permanent.</p>
<!--TOC subsection id="sec129" Forçage périodique-->
<h3 id="sec129" class="subsection">14.4.2  Forçage périodique</h3><!--SEC END --><p><a id="hevea_default153"></a>
Il arrive souvent qu’un système physique soit soumis à
un forçage extérieur périodique, par exemple
pour la température à échelle fine, l’alternance jour-nuit,
ou à grande échelle, l’alternance des saisons, ou
circuit RCL soumis à un courant périodique. Il est donc
utile de déterminer les caractéristiques de la solution
en régime permanent.</p><p>Exemple : ordre 1
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>a</mi><mi>y</mi><mo>=</mo><mi>A</mi><msup><mi>e</mi> <mrow><mi>i</mi><mi>&omega;</mi><mi>t</mi></mrow></msup><mo>,</mo><mspace width="1em"/><mi>a</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;+ay=A e^{i\omega t}, \quad a&amp;gt;0 </annotation></semantics></math>
On sait qu’une solution particulière est donnée par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><msup><mi>e</mi> <mrow><mi>i</mi><mi>&omega;</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'> B e^{i \omega t}</annotation></semantics></math>, on remplace et on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>i</mi><mi>&omega;</mi><mo>+</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mo>&Rightarrow;</mo><mi>B</mi><mo>=</mo><mfrac><mi>A</mi><mrow><mi>a</mi><mo>+</mo><mi>i</mi><mi>&omega;</mi></mrow></mfrac></mrow><annotation encoding='application/x-tex'>B(i\omega +a)=A \Rightarrow B=\frac{A}{a+i\omega} </annotation></semantics></math>
L’amplitude de la solution particulière est donc l’amplitude
du second membre divisée par le module 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>a</mi><mo>+</mo><mi>i</mi><mi>&omega;</mi><mo stretchy="false">&vert;</mo><mo>=</mo><msqrt><mrow><msup><mi>a</mi> <mn>2</mn></msup><mo>+</mo><msup><mi>&omega;</mi> <mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding='application/x-tex'>|a+i\omega|=\sqrt{a^2+\omega^2}</annotation></semantics></math>, et l’exponentielle subit
un déphasage donné par l’argument de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> soit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>arctan</mi><mo stretchy="false">(</mo><mi>&omega;</mi><mo stretchy="false">/</mo><mi>a</mi><mo stretchy="false">)</mo><mo>&Element;</mo><mo stretchy="false">]</mo><mo>&minus;</mo><mi>&pi;</mi><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><mn>0</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>&#x2d;\arctan(\omega/a) \in ]&#x2d;\pi/2,0[</annotation></semantics></math>. La solution
particulière suit donc le second membre, avec un déphasage
compris entre 0 et un quart de période, selon la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math>.
Si le système a une forte inertie intrinsèque (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> petit
pour avoir une exponentielle décroissant lentement), on s’approche
du quart de période, c’est pour cette raison que la température
près de la mer atteint son maximum en été environ 2 mois
après le solstice, alors que dans les terres, c’est plutot 3
semaines après (le maximum d’un quart de période
étant presque réalisé par la banquise qui atteint son
minimum d’extend presque 3 mois après le solstice).</p><p>À l’ordre 2, on peut faire la même étude, cette fois l’amplitude
est divisée par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mo>&minus;</mo><mi>a</mi><msup><mi>&omega;</mi> <mn>2</mn></msup><mo>+</mo><mi>i</mi><mi>b</mi><mi>&omega;</mi><mo>+</mo><mi>c</mi><mo stretchy="false">&vert;</mo><mo>=</mo><msqrt><mrow><msup><mi>b</mi> <mn>2</mn></msup><msup><mi>&omega;</mi> <mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>a</mi><msup><mi>&omega;</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>c</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow></msqrt><mo>=</mo><msup><mi>&omega;</mi> <mn>2</mn></msup><msqrt><mrow><msup><mi>b</mi> <mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>a</mi><mi>&omega;</mi><mo>&minus;</mo><mfrac><mi>c</mi><mi>&omega;</mi></mfrac><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding='application/x-tex'>|&#x2d;a\omega^2+ib\omega+c|
=\sqrt{ b^2\omega^2+(a\omega^2&#x2d;c)^2}
=\omega^2 \sqrt{ b^2+(a\omega&#x2d;\frac{c}{\omega})^2} </annotation></semantics></math>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>b=0</annotation></semantics></math> (pas de frottements) 
et si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mi>&omega;</mi></mrow><annotation encoding='application/x-tex'>i\omega</annotation></semantics></math> est solution de l’équation caractéristique,
la solution particulière est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>t</mi><msup><mi>e</mi> <mrow><mi>i</mi><mi>&omega;</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'> A t e^{i\omega t}</annotation></semantics></math>,
il y a résonance (c’est pour éviter d’entrer en résonance
avec une fréquence propre d’un pont qu’on ne doit pas le traverser
à plusieurs en marchant au même pas cadencé).</p>
<!--TOC subsection id="sec130" Équation autonome sans second membre-->
<h3 id="sec130" class="subsection">14.4.3  Équation autonome sans second membre</h3><!--SEC END --><p><a id="hevea_default154"></a>
Il s’agit d’une équation de la forme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=f(y)</annotation></semantics></math> où on
suppose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> continument dérivable. Les solutions
stationnaires sont données par les racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> (les
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> telles que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(r)=0</annotation></semantics></math>). Pour toute condition initiale entre
deux racines consécutive de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>, la solution va rester entre
ces deux racines consécutives. Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> ne s’annule pas
entre deux racines consécutives, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est de signe constant
donc la solution est monotone,
et tend vers une des racines lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo>&pm;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t \rightarrow \pm \infty</annotation></semantics></math>
<sup><a id="text26" href="#note26">4</a></sup>.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&amp;gt;0</annotation></semantics></math>, on tend vers la plus grande des racines lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t
\rightarrow +\infty</annotation></semantics></math>, sinon vers la plus petite. Si la condition 
initiale est au-delà de la plus grande racine ou en-deça
de la plus petite racine, on tend soit vers l’infini, soit vers la racines.</p><p>On peut préciser
la vitesse de convergence. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo><mo>,</mo><mi>c</mi><mi>&lt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(y)=c(y&#x2d;r), c&amp;lt;0</annotation></semantics></math>, (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> linéaire)
la convergence vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> se fait comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>c</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{ct}</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t \rightarrow
+\infty</annotation></semantics></math>. Dans le cas
général, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;(r) \neq 0</annotation></semantics></math>, 
ce résultat est encore valable, heuristiquement :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>+</mo><mi>o</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&Rightarrow;</mo><mfrac><mn>1</mn><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mfrac><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mi>o</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>o</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(y)=(y&#x2d;r)(f&apos;(r)+o(1)) \Rightarrow \frac{1}{f(y)}=
\frac{1}{f&apos;(r)(y&#x2d;r)} \frac{1}{1+o(1)}
=\frac{1}{f&apos;(r)(y&#x2d;r)}(1 + o(1)) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>o(1)</annotation></semantics></math> est une fonction qui tend vers 0 lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> tend vers
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>, donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo>&Integral;</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mo>&Integral;</mo><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>o</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>d</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>ln</mi><mo stretchy="false">&vert;</mo><mi>y</mi><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>o</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo>&Integral;</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mi>t</mi><mo>+</mo><mi>K</mi></mrow><annotation encoding='application/x-tex'>\int \frac{dy}{f(y)} = \int \frac{dy}{f&apos;(r)(y&#x2d;r)}(1 + o(1)) dy 
= \frac{\ln|y&#x2d;r|}{f&apos;(r)} (1 + o(1)) = \int \ dt = t+K   </annotation></semantics></math>
d’où le résultat (pour une justification plus rigoureuse
il faut appliquer le théorème des fonctions implicites
pour déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> et vérifier que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>o(1)</annotation></semantics></math> s’intègre).</p><div class="theorem"><span style="font-weight:bold">Théorème 30</span>  <em>
On considère l’équation différentielle </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=f(y)</annotation></semantics></math><em> où
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> est continument dérivable, et a des racines réelles
classées par ordre croissant </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>r</mi> <mi>k</mi></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>...,r_k,...</annotation></semantics></math><em>. Si la condition
initiale </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t_0)</annotation></semantics></math><em> est
située entre deux racines, la solution est monotone entre
ces deux racines et tend vers une des racines lorsque </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo>&pm;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t\rightarrow
\pm \infty</annotation></semantics></math><em>. Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t_0)</annotation></semantics></math><em> est situé au-delà de la dernière racine
ou en-decà de la première racine (si elles existent), 
la solution est monotone et
tend vers cette racine lorsque </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo>&pm;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t\rightarrow \pm \infty</annotation></semantics></math><em>
ou diverge (en temps fini ou infini).</em><p><em>Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mi>&lt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;(r_k) &amp;lt; 0</annotation></semantics></math><em>, la solution </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>r</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>y=r_k</annotation></semantics></math><em> est appelée équilibre
stable : pour toute condition initiale situé entre </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{k&#x2d;1}</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{k+1}</annotation></semantics></math><em>
la solution tend vers </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>r_k</annotation></semantics></math><em> lorsque </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t \rightarrow +\infty</annotation></semantics></math><em> 
et la convergence se fait à vitesse
exponentielle, comme </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><msup><mi>e</mi> <mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mi>t</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>o</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>Ce^{f&apos;(r_k)t(1+o(1))}</annotation></semantics></math><em>.
</em></p></div><p><span style="font-weight:bold">Exemple </span>: pour l’équation logistique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=y(1&#x2d;y)</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo>&minus;</mo><msup><mi>r</mi> <mn>2</mn></msup><mo>,</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>&minus;</mo><mn>2</mn><mi>r</mi></mrow><annotation encoding='application/x-tex'>f(r)=r(1&#x2d;r)=r&#x2d;r^2, f&apos;(r)=1&#x2d;2r</annotation></semantics></math>, 
il y a deux équilibres <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>r_0=0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>r_1=1</annotation></semantics></math>, avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>r</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;(r_0)=1&amp;gt;0</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>r</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mi>&lt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;(r_1)=&#x2d;1&amp;lt;0</annotation></semantics></math> donc un équilibre stable en 1, et un équilibre
instable en 0.</p>
<!--TOC subsection id="sec131" Systèmes linéaires-->
<h3 id="sec131" class="subsection">14.4.4  Systèmes linéaires</h3><!--SEC END --><p><a id="hevea_default155"></a>
<span style="font-weight:bold">Cas linéaire</span><br>
L’évolution du système est gouvernée par les valeurs propres
de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> du système, exactement comme pour les équations
linéaires où ce sont les racines de l’équation
caractéristique.
La solution générale tend vers 0 si toutes les valeurs propres
ont une partie réelle strictement négative. S’il y a des paires
de valeurs propres conjuguées de partie réelle négative,
des phénomènes cycliques amortis apparaissent.
Si les valeurs propres sont négatives ou nulles mais distinctes, la solution
reste bornée (avec des composantes qui peuvent être
périodiques).
Si une des valeurs propres a une partie réelle strictement positive,
alors pour une condition initiale générique, la solution tend vers
l’infini.</p><p><span style="font-weight:bold">Exemples </span>
</p><ul class="itemize"><li class="li-itemize">
<code>[Y]:=desolve(y'=A*y and y(0)=[1,0,0])</code> pour<br>
<code>A:=[[1,2,3],[4,5,6],[7,8,9]]</code>, 
puis <code>plot(Y[0],x=0..4)</code> la solution tend vers l’infini,
à vitesse exponentielle comme on peut
le voir avec <code>plot(ln(Y[0]),x=0..4)</code>.
En effet 16.12... est valeur propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>
(<code>eigenvalues(approx(A))</code>). On observe le même
comportement en remplaçant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>A</mi></mrow><annotation encoding='application/x-tex'>&#x2d;A</annotation></semantics></math> (ceci
diffère de la dimension 1, où en changeant le sens
du temps une solution divergente devient convergente).
On peut représenter le graphe de la courbe décrite
dans l’espace par exemple avec <code>plotparam(Y,x=0..2)</code>
</li><li class="li-itemize"><code>[Y]:=desolve(y'=A*y and y(0)=[1,0])</code> pour 
<code>A:=[[-3,1],[1,-5]]</code>, la courbe dans le plan est
obtenue par <code>plotparam(Y,x=0..10)</code>, en faisant
plusieurs zoom out, on voit la courbe partir de la condition
initiale le point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1,0)</annotation></semantics></math> et aboutir (presque) en l’origine.
Les valeurs propres sont en effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo>&pm;</mo><msqrt><mn>2</mn></msqrt><mi>&lt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>&#x2d;4\pm \sqrt{2}&amp;lt;0</annotation></semantics></math>.
</li><li class="li-itemize">Même chose avec <code>A:=[[-1,2],[-2,-1]];</code>.
La courbe part toujours du point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1,0)</annotation></semantics></math> pour
aboutir presque en l’origine, cette fois en spiralant
(car les valeurs propres sont complexes conjuguées)
</li><li class="li-itemize">Pour <code>A:=[[0,2],[-2,0]];</code>, les valeurs
propres sont imaginaires pures, la courbe est un cercle
décrite de manière périodique.
</li></ul><p><span style="font-weight:bold">Cas autonome</span><a id="hevea_default156"></a><br>
On ne sait pas intégrer un système <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=f(y)</annotation></semantics></math> sans plus
de précision sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> (ce n’est plus une équation à
variables séparables et il n’y a pas d’ordre dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math>,
donc pas de monotonie des solutions à attendre).
On ne peut donc
espérer un résultat général que si la condition initiale 
est proche d’un point d’équilibre (une solution de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(r)=0</annotation></semantics></math>).
Dans la plupart des cas, on peut conclure sur la stabilité
ou l’instabilité du point déquilibre en fonction de la partie
réelle des valeurs propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f&apos;(r)</annotation></semantics></math>, un peu comme en dimension 1.
Si toutes les valeurs propres ont des parties strictement négative
on peut montrer que
le système revient à l’équilibre exponentiellement vite, si
l’une des parties réelles est strictement positive,
pour une condition initiale générique, le système s’en
éloigne, et s’il y a des parties réelles nulles, on ne peut pas conclure/</p>
<!--TOC subsection id="sec132" Forçage près d’un point d’équilibre de système.-->
<h3 id="sec132" class="subsection">14.4.5  Forçage près d’un point d’équilibre de système.</h3><!--SEC END --><p>
Si on ajoute un terme dépendant du temps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=f(y)+g(t)</annotation></semantics></math>,
on ne sait plus résoudre l’équation ni décrire
son comportement qualitatif en toute généralité. Si
la condition initiale est proche d’un équilibre stable, et si
la perturbation est “petite” (en tenant compte de l’échelle
de temps des exponentielles du système linéarisé)
on peut alors linéariser et espérer que
la solution se comporte comme la solution de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><msub><mi>r</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=f&apos;(r_k)(y&#x2d;r_k) + g(t) </annotation></semantics></math>
au moins pendant un certain intervalle de temps.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi></mrow><annotation encoding='application/x-tex'>g(t)=g</annotation></semantics></math> est petit et constant, le point d’équilibre est déplacé
au premier ordre de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>&minus;</mo><msub><mi>r</mi> <mi>k</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>k</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>g</mi></mrow><annotation encoding='application/x-tex'>y&#x2d;r_k=&#x2d;f&apos;(r_k)^{&#x2d;1}g </annotation></semantics></math></p><p><span style="font-weight:bold">Exemple</span> : modèle d’évolution température puis température-CO2.</p><p>Le modèle le plus simple ne tient compte que des radiations venues du Soleil
et réémises par la Terre, considérée comme un corps noir
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>d</mi><mi>T</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mrow><mo>(</mo><mi>S</mi><mo>&minus;</mo><mi>&sigma;</mi><msup><mi>T</mi> <mn>4</mn></msup><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \frac{dT}{dt} = k \left( S &#x2d; \sigma T^4 \right) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> modélise l’inertie thermique, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math> est la constante solaire 
(environ 1364/4<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>W</mi><mo stretchy="false">/</mo><msup><mi>m</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>W/m^2</annotation></semantics></math>) et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&sigma;</mi></mrow><annotation encoding='application/x-tex'>\sigma</annotation></semantics></math> est relié à la constante de Stefan-Boltzmann (5.67e-8 S.I.).
On a alors un équilibre pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>e</mi></msub><mo>=</mo><msup><mi>S</mi> <mrow><mn>1</mn><mo stretchy="false">/</mo><mn>4</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>T_e=S^{1/4}</annotation></semantics></math>, et cet équilibre est stable.</p><p>Si on perturbe par un effet de serre additionnel du CO2,
on modélise l’évolution de la température
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> de la Terre par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>d</mi><mi>T</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mi>k</mi><mrow><mo>(</mo><mn>6</mn><mi>ln</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>C</mi><mi>O</mi><mn>2</mn></mrow><mn>280</mn></mfrac><mo stretchy="false">)</mo><mo>&minus;</mo><mi>&sigma;</mi><mo stretchy="false">(</mo><msup><mi>T</mi> <mn>4</mn></msup><mo>&minus;</mo><msubsup><mi>T</mi> <mi>e</mi> <mn>4</mn></msubsup><mo stretchy="false">)</mo><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \frac{dT}{dt} = k \left( 6 \ln (\frac{CO2}{280}) &#x2d; \sigma (T^4&#x2d;T_e^4) \right) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>e</mi></msub><mo>=</mo><mn>288</mn><mi>K</mi></mrow><annotation encoding='application/x-tex'>T_e=288K</annotation></semantics></math> est la température d’équiibre de la Terre et 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mi>O</mi><mn>2</mn><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>CO2(t)</annotation></semantics></math> la concentration en ppm de gaz carbonique, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> modélise
la capacité calorifique de la Terre (on peut estimer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>0.0025</mn><mi>K</mi><mo stretchy="false">/</mo><mi>y</mi><mi>r</mi></mrow><annotation encoding='application/x-tex'>k=0.0025K/yr</annotation></semantics></math>),
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&sigma;</mi></mrow><annotation encoding='application/x-tex'>\sigma</annotation></semantics></math> la constante de Stefan-Boltzmann (5.67e-8 S.I.).
Par exemple avec un taux de CO2 stabilisé à 450ppm, le nouvel
équilibre est donné à l’ordre 1 par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>T</mi><mo>&minus;</mo><msub><mi>T</mi> <mi>e</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><mi>&sigma;</mi><msubsup><mi>T</mi> <mi>e</mi> <mn>3</mn></msubsup><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mn>6</mn><mi>ln</mi><mo stretchy="false">(</mo><mfrac><mn>450</mn><mn>280</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T&#x2d;T_e=(4\sigma T_e^3)^{&#x2d;1}(6 \ln (\frac{450}{280}))  </annotation></semantics></math></p><p>Le taux de CO2 de l’atmosphère peut être considéré comme
un forçage extérieur (dépendant de scénarios d’émissions
de CO2) mais il dépend aussi de la température de l’océan,
on peut donc modéliser l’évolution conjointe des deux
variables par un système différentiel autonome auquel on
ajoute une composante dépendant du temps (émissions
anthropiques). Par exemple un système 2 par 2 avec un second
membre constant dans un scénario avec émissions de CO2 constantes.
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>T</mi></mtd></mtr> <mtr><mtd><mi>C</mi></mtd></mtr></mtable><mo>)</mo></mrow><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo>,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>k</mi><mo stretchy="false">(</mo><mi>&sigma;</mi><mo stretchy="false">(</mo><msubsup><mi>T</mi> <mn>0</mn> <mn>4</mn></msubsup><mo>&minus;</mo><msup><mi>T</mi> <mn>4</mn></msup><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mi>ln</mi><mo stretchy="false">(</mo><mfrac><mi>C</mi><mn>280</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>g</mi><mo stretchy="false">(</mo><mi>T</mi><mo>,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>+</mo><mi>a</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \frac{d}{dt} \left(\begin{array}{c}
T \\
C
\end{array}\right) =
F(T,C) = \left(\begin{array}{c}
k (\sigma(T_0^4&#x2d;T^4)+6 \ln(\frac{C}{280})  ) \\
g(T,C) + a
\end{array}\right)
 </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo>&PartialD;</mo> <mi>C</mi></msub><mi>g</mi></mrow><annotation encoding='application/x-tex'>\partial_C g</annotation></semantics></math> est négatif (l’océan
absorbe l’excédent de CO2 émis par rapport à la valeur 
avec laquelle il est en équilibre, on peut 
estimer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo>&PartialD;</mo> <mi>C</mi></msub><mi>g</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2.5</mn><mo stretchy="false">/</mo><mn>120</mn></mrow><annotation encoding='application/x-tex'>\partial_C g=&#x2d;2.5/120</annotation></semantics></math> par les observations : émissions 
4.5 ppm par an, hausse de CO2 2ppm/an, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mn>400</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2.5</mn><mo>=</mo><msub><mo>&PartialD;</mo> <mi>C</mi></msub><mi>g</mi><mo stretchy="false">(</mo><mn>400</mn><mo>&minus;</mo><mn>280</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>g(400)=&#x2d;2.5=\partial_Cg(400&#x2d;280)</annotation></semantics></math>),
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> représente la perturbation anthropique (par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mn>5</mn><mi>p</mi><mi>p</mi><mi>m</mi><mo stretchy="false">/</mo><mi>a</mi><mi>n</mi></mrow><annotation encoding='application/x-tex'>a=5ppm/an</annotation></semantics></math>
si stabilisation des émissions de CO2 à ce niveau).
Dans un modèle simplifié <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> ne dépend que de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math>,
la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>F&apos;</annotation></semantics></math> a des coefficients négatifs sur la diagonale et
un coefficient nul sous la diagonale, donc les valeurs propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>F&apos;</annotation></semantics></math>
sont négatives, le climat est stable. On atteint alors un nouvel 
équilibre avec une température <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> et un taux de CO2 <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> donnés
par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>&Delta;</mi><msub><mi>T</mi> <mi>e</mi></msub></mtd></mtr> <mtr><mtd><mi>&Delta;</mi><msub><mi>C</mi> <mi>e</mi></msub></mtd></mtr></mtable><mo>)</mo></mrow><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>F</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>T</mi> <mi>e</mi></msub><mo>,</mo><msub><mi>C</mi> <mi>e</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mi>a</mi></mtd></mtr></mtable><mo>)</mo></mrow><mo>,</mo><mspace width="1em"/><mi>F</mi><mo>&prime;</mo><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mo>&minus;</mo><mn>4</mn><mi>k</mi><mi>&sigma;</mi><msubsup><mi>T</mi> <mi>e</mi> <mn>3</mn></msubsup></mtd> <mtd><mn>6</mn><mi>k</mi><mo stretchy="false">/</mo><msub><mi>C</mi> <mi>e</mi></msub></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mo>&PartialD;</mo> <mi>C</mi></msub><mi>g</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\left(\begin{array}{c} \Delta T_e\\ \Delta C_e \end{array}\right)= &#x2d;F&apos;(T_e,C_e)^{&#x2d;1}\left(\begin{array}{c}0\\ a \end{array}\right), \quad
F&apos;=\left(\begin{array}{cc}&#x2d;4k\sigma T_e^3 &amp; 6k/C_e\\ 0 &amp; \partial_C g
\end{array}\right) </annotation></semantics></math>
La valeur de la constante de couplage entre CO2 et T affecte évidemment
le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><msup><mo>&prime;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>F&apos;^{&#x2d;1}</annotation></semantics></math> donc des valeurs à l’équilibre.
Ici avec nos estimations :
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">k:=0.0025; s:=5.67e-8;Fp:=[[-4*k*s*288^3,6*k/280],[0,-2.5/120]]; -Fp^-1*[0,5] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

on obtient une hausse de température de 1 degré et de CO2 de 240ppm.
Cela semble inférieur à la hausse de température observée,
car on n’a pas tenu compte d’autres rétroactions, en particulier
la glace et l’eau.
De plus dans un modèle plus réaliste, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> dépend aussi de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math>, 
en effet si l’océan
se réchauffe il dégaze du CO2. La matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>F&apos;</annotation></semantics></math> n’est plus triangulaire
supérieure, mais a 2 coefficients négatifs sur la diagonale et
2 positifs en-dehors. Si les valeurs propres restent négatives,
le climat est stable, mais si le couplage était suffisamment
fort pour que l’une des valeurs propres dépasse 0, 
le climat pourrait devenir instable! Ici on peut estimer grossièrement
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo>&PartialD;</mo> <mi>T</mi></msub><mi>g</mi><mo>=</mo><mn>0.42</mn></mrow><annotation encoding='application/x-tex'>\partial_T g=0.42</annotation></semantics></math> en tenant compte des cycles climatiques du passé,
pour une hausse de 5 degrés on observe
une hausse de 100ppm à l’équilibre (on doit avoir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo>&prime;</mo><mo>*</mo><mo stretchy="false">[</mo><mn>5,100</mn><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>F&apos;*[5,100]=[x,0]</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> correspondant au forçage astronomique sur la température).
Cette estimation laisse les valeurs propres négatives,
augmente de 10% environ la hausse de température et de CO2 à
l’équilibre.</p><p>On peut raffiner ce modèle en ajoutant par exemple la glace
et ses interactions avec la température (si la température
monte, la glace fond, si la glace fond, l’albédo de la Terre diminue
ce qui va faire monter la température), ce qui amène à un
système différentiel en dimension 3
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>T</mi></mtd></mtr> <mtr><mtd><mi>G</mi></mtd></mtr> <mtr><mtd><mi>C</mi></mtd></mtr></mtable><mo>)</mo></mrow><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>T</mi><mo>,</mo><mi>G</mi><mo>,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>k</mi><mo stretchy="false">(</mo><mi>&sigma;</mi><mo stretchy="false">(</mo><msubsup><mi>T</mi> <mn>0</mn> <mn>4</mn></msubsup><mo>&minus;</mo><msup><mi>T</mi> <mn>4</mn></msup><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mi>ln</mi><mo stretchy="false">(</mo><mfrac><mi>C</mi><mn>280</mn></mfrac><mo stretchy="false">)</mo><mo>&minus;</mo><mi>&beta;</mi><msup><mi>G</mi> <mrow><mn>2</mn><mo stretchy="false">/</mo><mn>3</mn></mrow></msup><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>f</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mi>g</mi><mo stretchy="false">(</mo><mi>T</mi><mo>,</mo><mi>C</mi><mo stretchy="false">)</mo><mo>+</mo><mi>a</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \frac{d}{dt} \left(\begin{array}{c}
T \\
G \\
C
\end{array}\right) =
F(T,G,C) = \left(\begin{array}{c}
k (\sigma(T_0^4&#x2d;T^4)+6 \ln(\frac{C}{280}) &#x2d; \beta G^{2/3} ) \\
f(T) \\
g(T,C) + a(t)
\end{array}\right)
 </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est une fonction décroissante, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo>&PartialD;</mo> <mi>T</mi></msub><mi>g</mi></mrow><annotation encoding='application/x-tex'>\partial_T g</annotation></semantics></math> est positif,
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>a(t)</annotation></semantics></math> représente la perturbation anthropique (la puissance deux
tiers appliquée à la masse de glace sert à passer d’un volume
à une surface pour représenter l’effet de la variation de volume
de glace sur l’albédo).</p>
<!--TOC section id="sec133" Résolution numérique-->
<h2 id="sec133" class="section">14.5  Résolution numérique</h2><!--SEC END -->
<!--TOC subsection id="sec134" Méthodes à un pas-->
<h3 id="sec134" class="subsection">14.5.1  Méthodes à un pas</h3><!--SEC END --><p>
On considère l’équation différentielle 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><mi>t</mi><mo>&Element;</mo><mi>&Ropf;</mi><mo>,</mo><mspace width="1em"/><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&Element;</mo><msup><mi>&Ropf;</mi> <mi>d</mi></msup><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>y&apos;=f(t,y), \quad t \in \mathbb{R}, \quad y(t) \in \mathbb{R}^d, y(0)=y_0 </annotation></semantics></math> 
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math> est la fonction inconnue cherchée
et où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est une fonction régulière de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> (par exemple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mn>1</mn></msup></mrow><annotation encoding='application/x-tex'>C^1</annotation></semantics></math> sur un domaine pour avoir existence et non recoupement des courbes
intégrales dans ce domaine). On cherche
à approcher numériquement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>t&amp;gt;0</annotation></semantics></math>. 
On présente ici des méthodes de résolution numérique à un pas,
dont le principe consiste à discrétiser l’intervalle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,t]</annotation></semantics></math> en des
subdivisions en temps de petite taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">]</mo><mo>,</mo><mo stretchy="false">[</mo><msub><mi>t</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>t</mi> <mn>2</mn></msub><mo stretchy="false">]</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mo stretchy="false">[</mo><msub><mi>t</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>=</mo><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,t_1], [t_1,t_2], ..., 
[t_{n&#x2d;1},t_n=t]</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>y_i</annotation></semantics></math> est une valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t_i)</annotation></semantics></math>
la méthode à un pas se traduit par une relation de récurrence entre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>y_i</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>y_{i+1}</annotation></semantics></math> qui reflète une méthode d’intégration
approchée de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msubsup><mo>&Integral;</mo> <mrow><msub><mi>t</mi> <mi>i</mi></msub></mrow> <mrow><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>y(t_{i+1})=y(t_i)+\int_{t_i}^{t_{i+1}} f(t,y(t)) \ dt </annotation></semantics></math>
Par exemple, la <span style="font-weight:bold">méthode d’Euler explicite</span><a id="hevea_default157"></a> 
utilise la méthode des
rectangles à gauche
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>+</mo><mo stretchy="false">(</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>y</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>+</mo><mi>h</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>y</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y_{i+1} = y_i + (t_{i+1}&#x2d;t_i) f(t_i,y_i)=y_i+hf(t_i,y_i) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo>=</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>t</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>h=t_{i+1}&#x2d;t_i</annotation></semantics></math><sup><a id="text27" href="#note27">5</a></sup> 
alors que la méthode d’Euler implicite utilise la méthode 
des rectangles à droite
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>+</mo><mo stretchy="false">(</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>+</mo><mi>h</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>+</mo><mi>h</mi><mo>,</mo><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y_{i+1} = y_i + (t_{i+1}&#x2d;t_i) f(t_{i+1},y_{i+1})=y_i+hf(t_{i}+h,y_{i+1}) </annotation></semantics></math>
cette dernière relation nécéssite de résoudre une équation pour
déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>y_{i+1}</annotation></semantics></math> d’où son nom de méthode implicite.
Plus généralement, la méthode de résolution revient à
se donner une fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Phi;</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\Phi(t,y,h)</annotation></semantics></math> et à poser :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>+</mo><mi>h</mi><mi>&Phi;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y_{i+1}=y_i+h\Phi(t_i,y_i,h) </annotation></semantics></math>
pour la méthode d’Euler explicite, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Phi;</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\Phi(t,y,h)=f(t,y)</annotation></semantics></math>, pour
la méthode d’Euler implicite, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Phi;</mi></mrow><annotation encoding='application/x-tex'>\Phi</annotation></semantics></math> s’obtient en résolvant une 
équation (par exemple avec la méthode du point fixe, pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math>
suffisamment petit).

</p><pre class="verbatim">fonction Euler(f,t0,t1,N,y0)
  // y'=f(t,y) avec f(t0)=y0, calcul de f(t1)
  local h,y,j;
  h:=(t1-t0)/N; // pas
  y:=evalf(y0);
  pour j de 0 jusque N-1 faire
    y += h*f(t0+j*h,y); // y(t+h)=y(t)+h*y'
  fpour;
  return y;
ffonction:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>



<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">f(t,y):=y; Euler(f,0,1,100,1)-exp(1);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Lorsqu’on compare la solution de l’équation et une valeur
approchée obtenue par une méthode à un pas, il faut distinguer 
</p><ul class="itemize"><li class="li-itemize">
l’erreur locale (ou erreur de consistance)
de la méthode qui est une majoration
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>&minus;</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|y_1&#x2d;y(t_1)|</annotation></semantics></math> en fonction du pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo>=</mo><msub><mi>t</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>t</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>h=t_1&#x2d;t_0</annotation></semantics></math>, on dit 
qu’une méthode est d’ordre au moins <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>&minus;</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>C</mi> <mi>n</mi></msub><msup><mi>h</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>|y_1&#x2d;y(t_1)|\leq
C_n h^{n+1}</annotation></semantics></math> (cette notion est reliée à l’ordre
de la méthode numérique d’intégration approchée utilisée).
</li><li class="li-itemize">l’erreur globale de la méthode, qui accumule deux phénomènes,
l’erreur locale à chaque pas et l’erreur sur la condition initiale
pour les subdivisions <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo><mo>,</mo><mi>i</mi><mi>&gt;</mi><mn>0</mn><mo>,</mo></mrow><annotation encoding='application/x-tex'>[t_i,t_{i+1}], i&amp;gt;0,</annotation></semantics></math> conséquence des erreurs
précédentes (en pratique il faudrait aussi ajouter les erreurs
d’arrondis et l’erreur
éventuelle sur la condition initiale). Pour majorer cette erreur,
il est nécessaire de supposer que la fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est lipschitzienne
par rapport à la variable <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>, l’erreur globale fera alors intervenir
un terme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>C</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{Ct}</annotation></semantics></math> multiplié par l’erreur locale
(accumulation exponentielle des erreurs au cours du temps).
</li></ul><p>
Plus précisément, on a le résultat suivant :
</p><div class="theorem"><span style="font-weight:bold">Théorème 31</span>  <em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math><em> la solution de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>y&apos;=f(t,y), y(t_0)=y_0</annotation></semantics></math><em> sur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>,</mo><mi>T</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[t_0,T]</annotation></semantics></math><em>.
On considére une méthode de résolution à un pas :
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>y</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>+</mo><msub><mi>h</mi> <mi>i</mi></msub><mi>&Phi;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>h</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y_{i+1}=y_i+h_i\Phi(t_i,y_i,h_i) </annotation></semantics></math><em> 
Si la méthode est d’ordre </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math><em>, i.e. si pour </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><msub><mi>h</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>h=max(h_i)</annotation></semantics></math><em> 
l’erreur locale satisfait 
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mi>&Phi;</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>C</mi> <mi>p</mi></msub><msup><mi>h</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>,</mo><mspace width="1em"/><mo>&forall;</mo><mi>t</mi><mo>&Element;</mo><mo stretchy="false">[</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>,</mo><mi>T</mi><mo stretchy="false">]</mo><mo>,</mo><mi>h</mi><mo>&leq;</mo><mi>H</mi></mrow><annotation encoding='application/x-tex'>|y(t) + h\Phi(t,y(t),h)&#x2d;y(t+h)|\leq C_p h^{p+1}, \quad \forall t \in [t_0,T], h \leq H  </annotation></semantics></math><em> 
et si la fonction </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Phi;</mi></mrow><annotation encoding='application/x-tex'>\Phi</annotation></semantics></math><em> est 
lipschitzienne en </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math><em> de constante </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Lambda;</mi></mrow><annotation encoding='application/x-tex'>\Lambda</annotation></semantics></math><em> pour </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo>&leq;</mo><mi>H</mi></mrow><annotation encoding='application/x-tex'>h\leq H</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math><em> dans un 
voisinage de la solution </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math><em>, 
i.e. si
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>&Phi;</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>z</mi><mo>,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>&Phi;</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>h</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&Lambda;</mi><mo stretchy="false">&vert;</mo><mi>z</mi><mo>&minus;</mo><mi>y</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|\Phi(t,z,h)&#x2d;\Phi(t,y,h)| \leq \Lambda |z&#x2d;y|  </annotation></semantics></math><em>
alors l’erreur globale vérifie
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>y</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mi>h</mi> <mi>p</mi></msup><mfrac><mrow><msub><mi>C</mi> <mi>p</mi></msub></mrow><mi>&Lambda;</mi></mfrac><mo stretchy="false">(</mo><msup><mi>e</mi> <mrow><mi>&Lambda;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>|y(t_n)&#x2d;y_n| \leq h^p \frac{C_p}{\Lambda}
(e^{\Lambda(t_n&#x2d;t_0)}&#x2d;1) </annotation></semantics></math><em>
</em></div><p>
Par exemple, pour Euler explicite, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Phi;</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\Phi(t,y,h)=f(t,y)</annotation></semantics></math>, la constante
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Lambda;</mi></mrow><annotation encoding='application/x-tex'>\Lambda</annotation></semantics></math> est la constante de Lipschitz de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>, et on prendra pour
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>C_1</annotation></semantics></math> un majorant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">&vert;</mo><msub><mo>&PartialD;</mo> <mi>y</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\frac{1}{2}|\partial_y f(t,y)|</annotation></semantics></math> dans un voisinage de la
solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&Element;</mo><mo stretchy="false">[</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>t</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>t \in [t_0,t_n]</annotation></semantics></math>.</p><p>Pour prouver ce résultat, il faut déterminer comment se propagent
les erreurs locales introduites à chaque pas.
Par exemple, on a une erreur locale au pas 1 <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>y</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>y(t_1)&#x2d;y_1</annotation></semantics></math> donc une
condition initiale modifiée pour le pas 2 <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>y_1</annotation></semantics></math> au lieu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t_1)</annotation></semantics></math>.
Cette erreur se propage au pas 2 en une erreur 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>&minus;</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>h</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>&Phi;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>h</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>&Phi;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>,</mo><msub><mi>h</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msub><mi>h</mi> <mn>1</mn></msub><mi>&Lambda;</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>&minus;</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mi>e</mi> <mrow><msub><mi>h</mi> <mn>1</mn></msub><mi>&Lambda;</mi></mrow></msup><mo stretchy="false">&vert;</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>&minus;</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>| y_1&#x2d;y(t_1)+h_1(\Phi(t_1,y_1,h_1)&#x2d;\Phi(t_1,y(t_1),h_1)| 
\leq (1+h_1 \Lambda)|y_1&#x2d;y(t_1)| \leq e^{h_1 \Lambda} |y_1&#x2d;y(t_1)| </annotation></semantics></math>
De même aux pas suivants, donc au pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> l’erreur locale au pas 1
s’est propagée en une erreur inférieure ou égale à 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>e</mi> <mrow><msub><mi>h</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>&Lambda;</mi></mrow></msup><mo>.</mo><mo>.</mo><mo>.</mo><msup><mi>e</mi> <mrow><msub><mi>h</mi> <mn>2</mn></msub><mi>&Lambda;</mi></mrow></msup><msup><mi>e</mi> <mrow><msub><mi>h</mi> <mn>1</mn></msub><mi>&Lambda;</mi></mrow></msup><mo stretchy="false">&vert;</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>&minus;</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>=</mo><msup><mi>e</mi> <mrow><mi>&Lambda;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">&vert;</mo><msub><mi>y</mi> <mn>1</mn></msub><mo>&minus;</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>C</mi> <mi>p</mi></msub><msubsup><mi>h</mi> <mn>0</mn> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mi>&Lambda;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{h_{n&#x2d;1} \Lambda}... e^{h_2 \Lambda} e^{h_1 \Lambda} |y_1&#x2d;y(t_1)|
= e^{\Lambda (t_n&#x2d;t_0)} |y_1&#x2d;y(t_1)| \leq C_ph_0^{p+1} e^{\Lambda (t_n&#x2d;t_0)} </annotation></semantics></math>
Il faut ensuite sommer les erreurs locales propagées de chaque pas
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>C</mi> <mi>p</mi></msub><msubsup><mi>h</mi> <mi>i</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mi>&Lambda;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></msup><mo>&leq;</mo><msub><mi>C</mi> <mi>p</mi></msub><msup><mi>h</mi> <mi>p</mi></msup><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>h</mi> <mi>i</mi></msub><msup><mi>e</mi> <mrow><mi>&Lambda;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>\sum_{i=0}^{n&#x2d;1} C_p h_i^{p+1} e^{\Lambda (t_n&#x2d;t_i)} 
\leq C_p h^p \sum_{i=0}^{n&#x2d;1} h_i e^{\Lambda (t_n&#x2d;t_i)}  </annotation></semantics></math>
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>&Lambda;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{\Lambda(t_n&#x2d;t)}</annotation></semantics></math> est positive décroissante sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>t</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[t_0,t_n]</annotation></semantics></math>, on peut majorer la somme par l’intégrale
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>C</mi> <mi>p</mi></msub><msup><mi>h</mi> <mi>p</mi></msup><msubsup><mo>&Integral;</mo> <mrow><msub><mi>t</mi> <mn>0</mn></msub></mrow> <mrow><msub><mi>t</mi> <mi>n</mi></msub></mrow></msubsup><msup><mi>e</mi> <mrow><mi>&Lambda;</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>C_p h^p \int_{t_0}^{t_n} e^{\Lambda (t_n&#x2d;t)} \ dt  </annotation></semantics></math>
d’où le résultat.</p><p>On observe qu’on peut atteindre n’importe quelle précision pourvu
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> soit suffisamment petit. Mais en pratique, ce n’est pas le cas.
En effet, le théorème ne tient pas compte des erreurs d’arrondis.
Si le pas est trop petit, les erreurs d’arrondi ne sont plus négligeables,
elles s’ajoutent aux erreurs locales et se propagent comme les erreurs
locales avec amplification exponentielle.
Il y a donc un pas optimal, et une précision maximale que l’on peut
atteindre.</p><p>Références : Hairer, Demailly.</p>
<!--TOC subsection id="sec135" Méthodes de Runge-Kutta (explicites)-->
<h3 id="sec135" class="subsection">14.5.2  Méthodes de Runge-Kutta (explicites)</h3><!--SEC END --><p><a id="hevea_default158"></a>
Ce sont des méthodes explicites qui 
utilisent une méthode de Newton-Cotes pour approcher
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&Integral;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int f(t,y(t)) \ dt</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[t_i,t_{i+1}]</annotation></semantics></math>.
Pour simplifier les notations, notons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>t</mi> <mi>i</mi></msub><mo>=</mo><mi>&alpha;</mi><mo>,</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>t_i=\alpha, t_{i+1}=\beta</annotation></semantics></math>,
on a alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&equiv;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>N</mi></munderover><msub><mi>&omega;</mi> <mi>k</mi></msub><mi>f</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\int_{\alpha}^{\beta} f(t,y(t)) 
\equiv \sum_{k=0}^N \omega_k f(\alpha_k,y(\alpha_k))) </annotation></semantics></math>
Pour estimer la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(\alpha_k,y(\alpha_k))</annotation></semantics></math>, il est nécessaire
d’approcher <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(\alpha_k)</annotation></semantics></math> ce qui se fait par une méthode
de Newton-Cotes, en utilisant les estimations des
valeurs des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mi>j</mi><mi>&lt;</mi><mi>k</mi></mrow><annotation encoding='application/x-tex'>y(\alpha_j), j&amp;lt;k</annotation></semantics></math>. On a 
donc des méthodes de Newton-Cotes avec un sous-ensemble croissant
de points d’interpolation, donc pour chaque valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> une
suite de coefficients <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&omega;</mi> <mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>,</mo><mi>j</mi><mi>&lt;</mi><mi>k</mi></mrow><annotation encoding='application/x-tex'>\omega_{j,k}, j&amp;lt;k</annotation></semantics></math> correspondant à la
méthode de Newton-Cotes utilisée. Il faut aussi indiquer la valeur de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\alpha_k</annotation></semantics></math> en donnant un coefficient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>k</mi></msub><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>c_k \in [0,1]</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo>=</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>+</mo><msub><mi>c</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>+</mo><msub><mi>c</mi> <mi>k</mi></msub><mi>h</mi></mrow><annotation encoding='application/x-tex'>\alpha_k = t_i + c_k (t_{i+1}&#x2d;t_i) = t_i+c_k h </annotation></semantics></math></p><p>En pratique on stocke un tableau dont les lignes donnent <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>c_k</annotation></semantics></math> et les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>k</mi></msub><msub><mi>&omega;</mi> <mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>,</mo><mi>j</mi><mi>&lt;</mi><mi>k</mi></mrow><annotation encoding='application/x-tex'>c_k\omega_{j,k}, j&amp;lt;k</annotation></semantics></math>,
et le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(\alpha_k)</annotation></semantics></math> se fait ligne par ligne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>&approx;</mo><msub><mi>Y</mi> <mi>k</mi></msub><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>c</mi> <mi>k</mi></msub><msub><mi>&omega;</mi> <mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(\alpha_{k}) \approx Y_{k}=y(\alpha_0) +
 h \sum_{j=0}^{k&#x2d;1} c_k\omega_{j,k} f(\alpha_j,y(\alpha_j))  </annotation></semantics></math>.
Par exemple pour la méthode d’Euler explicite, il y a deux lignes
contenant 0 et un seul coefficient :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mo>:</mo></mtd> <mtd/></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mo>:</mo></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mrow><annotation encoding='application/x-tex'>\begin{array}{ccc}
0 &amp;:&amp;  \\
1 &amp;:&amp; 1
\end{array}
 </annotation></semantics></math>.
Pour la méthode du point milieu, il y a trois lignes, la deuxière
ligne exprime comment on estime <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>+</mo><mi>h</mi><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t_i+h/2)</annotation></semantics></math>, la troisième
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t_{i+1})=y(t_i+h)</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mo>:</mo></mtd> <mtd/></mtr> <mtr><mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd> <mtd><mo>:</mo></mtd> <mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mo>:</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable></mrow><annotation encoding='application/x-tex'>\begin{array}{cccc}
0 &amp; : &amp;  \\
  \frac{1}{2} &amp; : &amp; \frac{1}{2} \\
1 &amp; : &amp; 0 &amp; 1
\end{array}
 </annotation></semantics></math>
on a donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>h</mi><mo stretchy="false">)</mo><mo>&approx;</mo><msub><mi>Y</mi> <mn>1</mn></msub><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>h</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t_i+\frac{1}{2}h) \approx Y_1=y(t_i)+\frac{1}{2}hf(t_i,y(t_i)) </annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo><mo>&approx;</mo><msub><mi>Y</mi> <mn>2</mn></msub><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo>,</mo><msub><mi>Y</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t_i+h) \approx Y_2=y(t_i)+hf(t_i+\frac{h}{2},Y_1)=y(t_i)+hf(t_i+\frac{h}{2},y(t_i)+\frac{h}{2}f(t_i,y(t_i))) </annotation></semantics></math></p><p>La suite des temps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\alpha_k</annotation></semantics></math> est croissante, mais pas forcément
de manière stricte, on peut avoir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo>=</mo><msub><mi>&alpha;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>\alpha_k=\alpha_{k+1}</annotation></semantics></math>, la valeur
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(\alpha_k)</annotation></semantics></math> n’étant pas estimée par la même méthode de Newton-Cotes
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(\alpha_{k+1})</annotation></semantics></math>.
La valeur des coefficients est ensuite déterminée pour obtenir un ordre
le plus grand possible pour l’erreur locale (ce qui peut nécessiter
la résolution de systèmes avec pas mal d’inconnues).</p><p>Ainsi, la méthode RK4 utilise le tableau suivant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mo>:</mo></mtd> <mtd/></mtr> <mtr><mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd> <mtd><mo>:</mo></mtd> <mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd></mtr> <mtr><mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd> <mtd><mo>:</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mo>:</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mo>:</mo></mtd> <mtd><mfrac><mn>1</mn><mn>6</mn></mfrac></mtd> <mtd><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd> <mtd><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd> <mtd><mfrac><mn>1</mn><mn>6</mn></mfrac></mtd></mtr></mtable></mrow><annotation encoding='application/x-tex'>\begin{array}{cccccc}
0 &amp; : &amp; \\
\frac{1}{2} &amp; : &amp; \frac{1}{2} \\
\frac{1}{2} &amp; : &amp; 0 &amp; \frac{1}{2} \\
1 &amp; : &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; : &amp; \frac{1}{6} &amp; \frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{6}
\end{array}
 </annotation></semantics></math>
Ce qui se traduit par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>Y</mi> <mn>1</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>y</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msub><mi>Y</mi> <mn>2</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo>,</mo><msub><mi>Y</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msub><mi>Y</mi> <mn>3</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>+</mo><mi>h</mi><mo>,</mo><msub><mi>Y</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msub><mi>Y</mi> <mn>4</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>h</mi><mn>6</mn></mfrac><mrow><mo>(</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>,</mo><mi>y</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo>,</mo><msub><mi>Y</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo>,</mo><msub><mi>Y</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>+</mo><mi>h</mi><mo>,</mo><msub><mi>Y</mi> <mn>3</mn></msub><mo stretchy="false">)</mo><mo>)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 Y_1&amp;=&amp;y(t_0)+\frac{h}{2}f(t_0,y_0) \\
Y_2&amp;=&amp;y(t_0)+\frac{h}{2}f(t_0+\frac{h}{2},Y_1) \\
Y_3 &amp;=&amp; y(t_0)+h f(t_0+h,Y_2) \\
Y_4 &amp;=&amp; y(t_0) + \frac{h}{6} \left(f(t_0,y(t_0))+
  2f(t_0+\frac{h}{2},Y_1)+2f(t_0+\frac{h}{2},Y_2)+f(t_0+h,Y_3)\right)
 \end{matrix} </annotation></semantics></math>
Les méthodes de Newton-Cotes utilisées sont les rectangles à
gauche puis à droite pour estimer le point milieu, et la méthode
de Simpson (en prenant la moyenne des deux estimations pour le
point milieu).
On peut montrer qu’elle est d’ordre 4 (erreur locale en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>h</mi> <mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(h^5)</annotation></semantics></math>)</p><p>Les méthodes de résolution numériques implémentées dans Xcas sont
des méthodes explicites de Runge-Kutta emboitées avec pas adaptatif, 
(le pas adaptatif est calculé en estimant l’erreur 
avec 2 méthodes emboitées RK4 et
Prince-Dormand, cf. Hairer).</p>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note23" href="#text23">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">En toute rigueur,
il faut prouver que la solution maximale est bien définie sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math> tout entier. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><msub><mi>t</mi> <mi>m</mi></msub><mo>,</mo><msub><mi>t</mi> <mi>M</mi></msub><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]t_m,t_M[</annotation></semantics></math> l’intervalle maximal de
définition de la solution. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>t</mi> <mi>M</mi></msub><mo>&ne;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t_M \neq +\infty</annotation></semantics></math>,
alors en intégrant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>y&apos;</annotation></semantics></math> qui est borné sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>t</mi> <mi>M</mi></msub><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>[t_0,t_M[</annotation></semantics></math> 
on obtient une valeur finie pour la limite en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>t</mi> <mi>M</mi></msub></mrow><annotation encoding='application/x-tex'>t_M</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math>,
on peut alors prolonger <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(t)</annotation></semantics></math> autour de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>t</mi> <mi>M</mi></msub></mrow><annotation encoding='application/x-tex'>t_M</annotation></semantics></math>
en appliquant le théorème de Cauchy-Lipschitz en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><msub><mi>t</mi> <mi>M</mi></msub></mrow><annotation encoding='application/x-tex'>t=t_M</annotation></semantics></math>,
ce qui est contradictoire avec l’hypothèse de maximalité. 
Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>t</mi> <mi>M</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t_M=+\infty</annotation></semantics></math> et de même <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>t</mi> <mi>m</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>t_m=&#x2d;\infty</annotation></semantics></math></div></dd><dt class="dt-thefootnotes"><a id="note24" href="#text24">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">On peut
d’ailleurs démontrer que certaines équations ne sont pas résolubles de
cette manière, cf. la théorie de Galois différentielle</div></dd><dt class="dt-thefootnotes"><a id="note25" href="#text25">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Cela vient du fait que
les puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> forment une famille d’un
espace vectoriel de dimension finie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>n^2</annotation></semantics></math>, donc la famille est liée
à partir de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n^2+1</annotation></semantics></math> éléments, en fait on peut montrer
que c’est le cas si on considère <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>,</mo><mi>A</mi><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>A</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>I,A,...,A^n</annotation></semantics></math>.</div></dd><dt class="dt-thefootnotes"><a id="note26" href="#text26">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">On peut prouver l’existence globale de la solution
exactement comme pour l’exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y&apos;=y(1&#x2d;y)</annotation></semantics></math> de la section 
<a href="#sec%3Aexistence">14.2</a></div></dd><dt class="dt-thefootnotes"><a id="note27" href="#text27">5</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Pour une méthode à pas variable,
le pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> peut dépendre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math></div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec136" Introduction au calcul variationnel-->
</html>
