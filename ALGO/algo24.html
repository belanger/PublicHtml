<!DOCTYPE html>
<html >
<head>
<h1 id="sec278" class="chapter">Chapitre 24  Développement de Taylor, asymptotiques, 
séries entières, fonctions usuelles</h1><!--SEC END --><p>
<a id="sec:series"></a>
<a id="hevea_default324"></a>
Pour approcher les fonctions classiques (exponentielle, sinus,
cosinus, log nepérien), on peut utiliser les développements en séries 
classiques, le polynôme de Taylor en un point donne
une bonne approximation près du point, l’équivalent
en l’infini appelé développement asymptotique donne
une bonne approximation loin de 0, et
les approximants de Padé 
où on approche par le quotient de 2 polynômes (ceci
donne parfois de très bons résultats comme pour la fonction
exponentielle près de 0 par exemple).</p><p>Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> une fonction indéfiniment dérivable sur un intervalle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>&Element;</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>x_0 \in I</annotation></semantics></math>. On peut alors effectuer le développement de Taylor de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math> à l’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><a id="hevea_default325"></a>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mfrac><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> T_n(f)(x)= f(x_0) + (x&#x2d;x_0) f&apos;(x_0) + ... + 
(x&#x2d;x_0)^n \frac{f^{[n]}(x_0)}{n!}  </annotation></semantics></math>
et se demander si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_n(f)</annotation></semantics></math> converge lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tend vers
l’infini, si la limite est égale à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math> et si on peut facilement
majorer la différence entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_n(f)(x)</annotation></semantics></math>. Si c’est le
cas, on pourra utiliser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_n(f)(x)</annotation></semantics></math> comme valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math>.</p><p>On peut parfois répondre à ces questions simultanément en regardant le
développement de Taylor de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> avec reste : il existe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&theta;</mi></mrow><annotation encoding='application/x-tex'>\theta</annotation></semantics></math> compris
entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>R</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mfrac><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> R_n(x) := f(x)&#x2d; T_n(f)(x) = (x&#x2d;x_0)^{n+1}\frac{f^{[n+1]}(\theta)}{(n+1)!}  </annotation></semantics></math>
C’est le cas pour la fonction exponentielle que nous allons
détailler, ainsi que les fonctions sinus et cosinus.</p>
<!--TOC section id="sec279" La fonction exponentielle-->
<h2 id="sec279" class="section">24.1  La fonction exponentielle</h2><!--SEC END --><p><a id="hevea_default326"></a><a id="hevea_default327"></a>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>exp</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)=\exp(x)</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>x_0=0</annotation></semantics></math>, la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>-ième de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> 
est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>exp</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\exp(x)</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>exp</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>R_n(x)=\exp(\theta)x^{n+1}/(n+1)!</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&theta;</mi></mrow><annotation encoding='application/x-tex'>\theta</annotation></semantics></math>
compris entre 0 et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>, ainsi si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est positif 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>R</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mi>e</mi> <mi>x</mi></msup><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>|R_n(x)| \leq e^x x^{n+1}/(n+1)!</annotation></semantics></math> et si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est négatif,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>R</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>|R_n(x)| \leq x^{n+1}/(n+1)!</annotation></semantics></math>. Dans les deux cas, la limite de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>R_n</annotation></semantics></math>
est 0 lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tend vers l’infini, car pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&geq;</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding='application/x-tex'>n \geq 2x</annotation></semantics></math>, on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><msup><mi>x</mi> <mi>n</mi></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><mfrac><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>&leq;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mfrac><mrow><msup><mi>x</mi> <mi>n</mi></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \frac{x^{n+1}}{(n+1)!} = \frac{x^n}{n!} \frac{x}{n+1}\leq 
\frac{1}{2}\frac{x^n}{n!} </annotation></semantics></math>
on a donc pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> réel
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>e</mi> <mi>x</mi></msup><mo>=</mo><munder><mi>lim</mi> <mrow><mi>n</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></munder><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mi>lim</mi> <mrow><mi>n</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></munder><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mfrac><mrow><msup><mi>x</mi> <mi>k</mi></msup></mrow><mrow><mi>k</mi><mo>!</mo></mrow></mfrac><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mfrac><mrow><msup><mi>x</mi> <mi>k</mi></msup></mrow><mrow><mi>k</mi><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> e^x = \lim_{n \rightarrow +\infty} T_n(f)(x)
= \lim_{n \rightarrow +\infty} \sum_{k=0}^n \frac{x^k}{k!}
= \sum_{k=0}^\infty \frac{x^k}{k!}  </annotation></semantics></math></p><p>Comment en déduire une valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mi>x</mi></msup></mrow><annotation encoding='application/x-tex'>e^x</annotation></semantics></math>? Il suffira d’arrêter
la sommation lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo>:</mo><mo>=</mo><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>R:=x^{n+1}/(n+1)!</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>&lt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>x&amp;lt;0</annotation></semantics></math> ou lorsque
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo>:</mo><mo>=</mo><msup><mi>e</mi> <mi>x</mi></msup><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>R:=e^x x^{n+1}/(n+1)!</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>x&amp;gt;0</annotation></semantics></math> est inférieur à 
l’erreur absolue souhaitée, le plus tôt étant le mieux pour des
raisons d’efficacité et pour éviter l’accumulation d’erreurs
d’arrondi. 
Si on veut connaitre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mi>x</mi></msup></mrow><annotation encoding='application/x-tex'>e^x</annotation></semantics></math> à une erreur relative <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math> donnée
(par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mo>=</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>\varepsilon=2^{&#x2d;53}</annotation></semantics></math> pour stocker le résultat dans un double)
il suffit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo stretchy="false">/</mo><msup><mi>e</mi> <mi>x</mi></msup><mi>&lt;</mi><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>R/e^x &amp;lt; \varepsilon</annotation></semantics></math>, donc si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est positif, il suffit
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><mi>&lt;</mi><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>x^{n+1}/(n+1)!&amp;lt;\varepsilon</annotation></semantics></math>, on peut donc arrêter la sommation
lorsque le terme suivant est plus petit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math>.</p><p>On observe que plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est grand, plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> devra
être grand pour réaliser le test d’arrêt, ce qui est facheux
pour le temps de calcul.
De plus, le résultat final peut être petit alors que les termes
intermédiaires calculés dans la somme peuvent être grands, ce qui
provoque une perte de précision relative, par exemple si on
veut calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>10</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{&#x2d;10}</annotation></semantics></math> ou plus généralement l’exponentielle
d’un nombre négatif de grande valeur absolue.</p><p>Exercice : combien de termes faut-il calculer dans le développement
de l’exponentielle de -10 pour que le reste soit plus petit
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;53}</annotation></semantics></math> ? Quel est la valeur du plus grand terme rencontré dans
la suite ? Quelle est la perte de précision relative occasionné
par cette méthode de calcul ?</p><p>On peut utiliser les propriétés de la fonction exponentielle
pour éviter ce problème. Pour les nombres négatifs, on peut
utiliser l’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><msup><mi>e</mi> <mi>x</mi></msup></mrow><annotation encoding='application/x-tex'>e^{&#x2d;x}=1/e^x</annotation></semantics></math> (ne change pas l’erreur relative). 
Pour les grands réels, on peut utiliser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mn>2</mn><mi>x</mi></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>e</mi> <mi>x</mi></msup><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>e^{2x}=(e^x)^2</annotation></semantics></math>
(multiplie par 2 l’erreur relative).
On peut aussi, si on connait une valeur approchée
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(2)</annotation></semantics></math>, effectuer la division euclidienne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(2)</annotation></semantics></math> 
avec reste symétrique :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>r</mi><mo>,</mo><mspace width="1em"/><mi>a</mi><mo>&Element;</mo><mi>&Zopf;</mi><mo>,</mo><mo stretchy="false">&vert;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> x = a \ln(2) + r, \quad a \in \mathbb{Z}, |r| \leq \frac{ln(2)}{2}  </annotation></semantics></math>
puis si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> est positif, on somme la série de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T(f)(r)</annotation></semantics></math>, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>
est négatif, on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T(f)(&#x2d;r)</annotation></semantics></math> et on inverse, on applique alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>e</mi> <mi>x</mi></msup><mo>=</mo><msup><mn>2</mn> <mi>a</mi></msup><msup><mi>e</mi> <mi>r</mi></msup></mrow><annotation encoding='application/x-tex'> e^x = 2^a e^r  </annotation></semantics></math></p><p>Il faut toutefois noter que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(2)</annotation></semantics></math> n’étant pas connu exactement,
on commet une erreur d’arrondi absolu sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>&eta;</mi></mrow><annotation encoding='application/x-tex'>a \eta</annotation></semantics></math>,
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&eta;</mi></mrow><annotation encoding='application/x-tex'>\eta</annotation></semantics></math> est l’erreur relative sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(2)</annotation></semantics></math>,
il faut donc ajouter une erreur d’arrondi relative de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo stretchy="false">/</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mi>&eta;</mi></mrow><annotation encoding='application/x-tex'>x/\ln(2) \eta</annotation></semantics></math>
qui peut devenir grande si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est grand. Puis il faut ajouter
la somme des erreurs d’arrondi due au calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mi>r</mi></msup></mrow><annotation encoding='application/x-tex'>e^r</annotation></semantics></math>, que l’on
peut minimiser en utilisant la méthode de Horner pour évaluer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_n(f)(r)</annotation></semantics></math> (car elle commence par sommer les termes de plus haut degré
qui sont justement les plus petits termes de la somme). 
Les coprocesseurs arithmétiques qui implémentent la fonction exponentielle
ont un format de représentation interne des double avec une mantisse
plus grande que celle des double (par exemple 64 bits au lieu de 53),
et une table contenant des constantes dont <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(2)</annotation></semantics></math> avec cette précision,
le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mi>x</mi></msup></mrow><annotation encoding='application/x-tex'>e^x</annotation></semantics></math> par cette méthode entraine donc seulement une erreur
relative d’arrondi au plus proche sur le résultat converti en double 
(donc de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;53}</annotation></semantics></math>).</p><p>Notons que en général <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> lui-même
a déjà été arrondi ou n’est connu qu’avec une précision relative.
Or si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>x&amp;gt;0</annotation></semantics></math> est connu avec une erreur relative de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math>
(donc une erreur absolue de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\varepsilon |x|</annotation></semantics></math>, alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>e</mi> <mrow><mi>x</mi><mo>+</mo><mi>&#x03B5;</mi><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow></msup><mo>=</mo><msup><mi>e</mi> <mi>x</mi></msup><msup><mi>e</mi> <mrow><mi>&#x03B5;</mi><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow></msup></mrow><annotation encoding='application/x-tex'> e^{x+\varepsilon |x|}= e^x e^{\varepsilon |x|}  </annotation></semantics></math>
donc on ne peut pas espérer mieux qu’une erreur relative de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>&#x03B5;</mi><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>e^{\varepsilon |x|}&#x2d;1</annotation></semantics></math> sur l’exponentielle de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>\varepsilon x</annotation></semantics></math> est petit
cette erreur relative (impossible à éviter, quel que soit
l’algorithme utilisé pour calculer l’exponentielle) 
est d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\varepsilon |x|</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>\varepsilon x</annotation></semantics></math> est 
grand alors l’erreur relative devient de l’ordre de 1, et la valeur
de l’exponentielle calculée peut être très éloignée de la valeur
réelle! Notons que pour les double, il y aura dans ce cas débordement 
soit vers l’infini soit vers 0
(par exemple si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est supérieur à 709, l’exponentielle renvoie infini).</p><p>Exercice : refaire les mêmes calculs pour les fonction sinus ou cosinus.
On utilise par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>&pi;</mi><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sin(x+\pi)=&#x2d;sin(x)</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>sin</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sin(&#x2d;x)=&#x2d;\sin(x)</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mo stretchy="false">/</mo><mn>2</mn><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sin(x)=\cos(\pi/2&#x2d;x)</annotation></semantics></math> pour se ramener au calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sin(x)</annotation></semantics></math> 
ou de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>cos</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\cos(x)</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>&pi;</mi><mo stretchy="false">/</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,\pi/4]</annotation></semantics></math>.<a id="hevea_default328"></a><a id="hevea_default329"></a>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mfrac><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo>,</mo><mspace width="1em"/><mi>cos</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mfrac><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \sin(x)=\sum_{n=0}^\infty (&#x2d;1)^n \frac{x^{2n+1}}{(2n+1)!},
\quad \cos(x)=\sum_{n=0}^\infty (&#x2d;1)^n \frac{x^{2n}}{(2n)!}  </annotation></semantics></math></p><p>Cette méthode a toutefois ces limites, car il peut devenir impraticable
de calculer la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>-ième d’une fonction (par exemple avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>tan</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\tan(x)</annotation></semantics></math>),
et encore plus de la majorer. D’où l’intérêt de développer une théorie
des fonctions qui sont égales à leur développement de Taylor à l’infini
d’une part, et d’avoir d’autres méthodes pour majorer le reste, nous
présentons ici le cas des séries alternées.</p>
<!--TOC section id="sec280" Séries entières.-->
<h2 id="sec280" class="section">24.2  Séries entières.</h2><!--SEC END --><p><a id="hevea_default330"></a>
Les séries de type prendre la limite lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tend vers
l’infini du développement de Taylor en x=0 sont de la forme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>n</mi></msup><mo>:</mo><mo>=</mo><munder><mi>lim</mi> <mrow><mi>k</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></munder><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mi>k</mi></munderover><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>n</mi></msup><mo>,</mo><msub><mi>a</mi> <mi>n</mi></msub><mo>=</mo><mfrac><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \sum_{n=0}^\infty a_n x^n := \lim_{ k \rightarrow +\infty} 
\sum_{n=0}^k a_n x^n, a_n=\frac{f^{[n]}(0)}{n!}
 </annotation></semantics></math>
On peut s’intéresser plus généralement à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></msubsup><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\sum_{n=0}^\infty a_n x^n</annotation></semantics></math>
lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>a_n</annotation></semantics></math> est un complexe quelconque, 
c’est ce qu’on appelle une série entière, on peut aussi les voir comme
des polynômes généralisés. </p><p>S’il existe un point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math> tel que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>n</mi></msub><msubsup><mi>x</mi> <mn>0</mn> <mi>n</mi></msubsup><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|a_n x_0^n|</annotation></semantics></math> est borné (ce sera le cas en particulier 
si la série converge en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math>), alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>n</mi></msup><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>n</mi></msub><msubsup><mi>x</mi> <mn>0</mn> <mi>n</mi></msubsup><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mfrac><mi>x</mi><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac><msup><mo stretchy="false">&vert;</mo> <mi>n</mi></msup><mo>&leq;</mo><mi>M</mi><mo stretchy="false">&vert;</mo><mfrac><mi>x</mi><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac><msup><mo stretchy="false">&vert;</mo> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'> |a_n x^n| = |a_n x_0^n| |\frac{x}{x_0}|^n \leq 
M |\frac{x}{x_0}|^n
 </annotation></semantics></math>
la série converge donc en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x|&amp;lt;|x_0|</annotation></semantics></math> et on 
peut majorer le reste de la série au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>R</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>M</mi><mfrac><mrow><mo stretchy="false">&vert;</mo><mfrac><mi>x</mi><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac><msup><mo stretchy="false">&vert;</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mn>1</mn><mo>&minus;</mo><mo stretchy="false">&vert;</mo><mfrac><mi>x</mi><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac><mo stretchy="false">&vert;</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> |R_n| \leq M \frac{ |\frac{x}{x_0}|^{n+1}} {1&#x2d;|\frac{x}{x_0}|} 
 </annotation></semantics></math>
la vitesse de convergence est donc du même type que pour le
théorème du point fixe (le nombre de termes à calculer
pour trouver une valeur approchée avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> décimales 
dépend linéairement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, les constantes sont d’autant
plus grandes que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x|</annotation></semantics></math> est grand).</p><div class="theorem"><span style="font-weight:bold">Théorème 60</span>  <em>
S’il existe un rang </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>n_0</annotation></semantics></math><em>, un réel </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>M&amp;gt;0</annotation></semantics></math><em> et un complexe </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math><em> tels que 
pour </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&gt;</mi><msub><mi>n</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>n&amp;gt;n_0</annotation></semantics></math><em>, on ait :
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>n</mi></msub><msub><mi>x</mi> <mn>0</mn></msub><msup><mo stretchy="false">&vert;</mo> <mi>n</mi></msup><mo>&leq;</mo><mi>M</mi></mrow><annotation encoding='application/x-tex'> |a_n x_0|^n \leq M </annotation></semantics></math><em>
alors la série converge pour </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x|&amp;lt;|x_0|</annotation></semantics></math><em>
et pour </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&geq;</mo><msub><mi>n</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>n\geq n_0</annotation></semantics></math><em>, on a :
</em><a id="eqref_54"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>R</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>M</mi><mfrac><mrow><mo stretchy="false">&vert;</mo><mfrac><mi>x</mi><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac><msup><mo stretchy="false">&vert;</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mn>1</mn><mo>&minus;</mo><mo stretchy="false">&vert;</mo><mfrac><mi>x</mi><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac><mo stretchy="false">&vert;</mo></mrow></mfrac><mspace width="2em"/><mo stretchy="false">(</mo><mn>54</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
|R_n| \leq M \frac{ |\frac{x}{x_0}|^{n+1}} {1&#x2d;|\frac{x}{x_0}|} 
\qquad (54) </annotation></semantics></math><em>
</em></div><p>On en déduit qu’il existe un réel
positif <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>R\geq 0</annotation></semantics></math> éventuellement égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>+\infty</annotation></semantics></math> tel que 
la série converge (la limite de la somme jusqu’à l’infini existe) 
lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>|x|&amp;lt;R</annotation></semantics></math> et n’existe pas lorsque
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&gt;</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>|x|&amp;gt;R</annotation></semantics></math>, ce réel est appelé <span style="font-weight:bold">rayon de convergence</span> de la série.
Par exemple ce rayon vaut <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>+\infty</annotation></semantics></math> pour l’exponentielle, le sinus
ou le cosinus. Il
est égal à 1 pour la série géométrique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo><msup><mi>x</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\sum x^n</annotation></semantics></math> (car elle diverge
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>|x|&amp;gt;1</annotation></semantics></math> et converge si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>|x|&amp;lt;1</annotation></semantics></math>). 
On ne peut pas dire ce qui se passe génériquement lorsqu’on
est à la limite, c’est-à-dire lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>=</mo><mi>R</mi></mrow><annotation encoding='application/x-tex'>|x|=R</annotation></semantics></math> (si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo>&ne;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>R\neq
+\infty</annotation></semantics></math>). Mais cela n’a en fait pas trop d’importance en pratique
car même si la série converge, elle converge souvent trop lentement
pour donner de bonnes approximations. En fait, la vitesse de
convergence d’une série entière de rayon <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo>&ne;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>R\neq +\infty</annotation></semantics></math> est
en gros la même que celle d’une série géométrique de raison <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mi>R</mi></mrow><annotation encoding='application/x-tex'>|x|/R</annotation></semantics></math>.</p><p>Lorsque 2 séries ont un rayon de convergence non nul, alors on
peut effectuer leur somme, leur produit comme des polynômes et la
série somme/produit a un rayon de convergence au moins égal au plus
petit des 2 rayons de convergence des arguments. On peut inverser une série
entière non nulle en 0 en appliquant 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>1</mn><mo>&minus;</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'> (1+x)^{&#x2d;1} = 1&#x2d;x+x^2&#x2d;x^3+...  </annotation></semantics></math>
et on obtient une série entière de rayon de
convergence non nul. On peut aussi composer deux séries entières
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>&SmallCircle;</mo><mi>f</mi></mrow><annotation encoding='application/x-tex'>g\circ f</annotation></semantics></math> (avec les règles de calcul de composition
des polynômes) si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(0)=0</annotation></semantics></math>. On peut enfin dériver
et intégrer une série entière terme à terme dans son rayon de convergence.</p><p>On dit qu’une fonction est développable en série entière en 0 si
elle est égale à son développement de Taylor en 0 sommé jusqu’en l’infini
dans un disque de centre 0 et de rayon non nul. Les fonctions
exponentielle, sinus, cosinus sont donc développables en série entière en 0.
La fonction tangente également car le dénominateur cosinus est non nul en 0,
mais son rayon de convergence n’est pas l’infini et le calcul des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>a_n</annotation></semantics></math>
est assez complexe.
La fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mi>&alpha;</mi></msup></mrow><annotation encoding='application/x-tex'>(1+x)^\alpha</annotation></semantics></math> est développable en séries entières
pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>&Element;</mo><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\alpha \in \mathbb{R}</annotation></semantics></math> avec un rayon de convergence 1 (ou l’infini
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha </annotation></semantics></math> entier positif). 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mi>&alpha;</mi></msup><mo>=</mo><mn>1</mn><mo>+</mo><mi>&alpha;</mi><mi>x</mi><mo>+</mo><mfrac><mrow><mi>&alpha;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn><mo>!</mo></mrow></mfrac><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mfrac><mrow><mi>&alpha;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>&minus;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>x</mi> <mi>n</mi></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'> (1+x)^\alpha = 1 + \alpha x + \frac{\alpha (\alpha&#x2d;1)}{2!} x^2 +
... + \frac{\alpha (\alpha&#x2d;1) ... (\alpha &#x2d;n +1)}{n!} x^n + ... </annotation></semantics></math>
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\alpha=&#x2d;1</annotation></semantics></math>, c’est la série 
géométrique de raison <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>&#x2d;x</annotation></semantics></math>, en effet si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>|x|&amp;lt;1</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mi>k</mi></munderover><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mo>=</mo><mfrac><mrow><mn>1</mn><mo>&minus;</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mn>1</mn><mo>+</mo><mi>x</mi></mrow></mfrac><msub><mo>&rightarrow;</mo> <mrow><mi>k</mi><mo>&rightarrow;</mo><mn>&infin;</mn></mrow></msub><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mi>x</mi></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \sum_{n=0}^k (&#x2d;x)^n = \frac{1&#x2d;(&#x2d;x)^{k+1}}{1+x} 
\rightarrow_{k\rightarrow \infty} \frac{1}{1+x}
 </annotation></semantics></math>
En intégrant par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>, on obtient que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(1+x)</annotation></semantics></math> est développable
en série entière en 0 de rayon de convergence 1 et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mfrac><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \ln(1+x) = \sum_{n=0}^\infty \frac{(&#x2d;x)^{n+1}}{n+1}  </annotation></semantics></math>
On peut calculer de manière analogue le développement en série entière
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>arctan</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\arctan(x)</annotation></semantics></math> en iintégrant celui de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>1/(1+x^2)</annotation></semantics></math>, de même pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>arccos</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\arccos(x)</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>arcsin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\arcsin(x)</annotation></semantics></math> en intégrant celui de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>(1&#x2d;x^2)^{&#x2d;1/2}</annotation></semantics></math>.<a id="hevea_default331"></a>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>arctan</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mfrac><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mo>,</mo></mrow><annotation encoding='application/x-tex'> \arctan(x)=\sum_{n=0}^\infty (&#x2d;1)^{n} \frac{x^{2n+1}}{2n+1},
 </annotation></semantics></math>
On peut donc calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi></mrow><annotation encoding='application/x-tex'>\ln</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>arctan</mi></mrow><annotation encoding='application/x-tex'>\arctan</annotation></semantics></math>, ... par ces formules, 
mais il faut répondre
à la question où arrête-t-on la somme pour obtenir une précision donnée? 
Dans le cas de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(1+x)</annotation></semantics></math>,
on pourrait répondre comme avec l’exponentielle en majorant la dérivée
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>-ième, mais ce n’est plus faisable pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>arctan</mi><mo>,</mo><mi>arcsin</mi><mo>,</mo><mi>arccos</mi></mrow><annotation encoding='application/x-tex'>\arctan, \arcsin, \arccos</annotation></semantics></math>.
On va donner un autre critère qui ne nécessite pas
de calculer cette dérivée mais utilise l’alternance des signes
dans la somme.</p>
<!--TOC section id="sec281" Série alternée-->
<h2 id="sec281" class="section">24.3  Série alternée</h2><!--SEC END --><p><a id="hevea_default332"></a>
</p><div class="theorem"><span style="font-weight:bold">Théorème 61</span>  <em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><msub><mi>u</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>S_n= \sum_{k=0}^n (&#x2d;1)^k u_k</annotation></semantics></math><em> la somme jusqu’au rang </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><em> d’une
série de réels tels que la suite des </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>u_k</annotation></semantics></math><em> décroit à partir
d’un rang </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>n_0</annotation></semantics></math><em> et tend vers 0
lorsque </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>k\rightarrow +\infty</annotation></semantics></math><em>. Alors </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>S_n</annotation></semantics></math><em> converge vers une limite
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math><em>. Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&geq;</mo><msub><mi>n</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>n\geq n_0</annotation></semantics></math><em>, la limite est comprise entre deux sommes
partielles succesives </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>S_n</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>S_{n+1}</annotation></semantics></math><em> et le reste est majoré par
la valeur absolue du premier terme non sommé :
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>R</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |R_n| \leq |u_{n+1}| </annotation></semantics></math><em>
</em></div><p>
Démonstration :<br>
on montre que les suites <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>S</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>v_n=S_{2n}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>S</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>w_n=S_{2n+1}</annotation></semantics></math> sont
adjacentes. On a 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>v</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>S</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><msub><mi>S</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup><msub><mi>u</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>+</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><msub><mi>u</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&leq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> v_{n+1}&#x2d;v_n= S_{2n+2}&#x2d;S_{2n}= (&#x2d;1)^{2n+2} u_{2n+2} + (&#x2d;1)^{2n+1}
u_{2n+1} = u_{2n+2}&#x2d;u_{2n+1} \leq 0 </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>v_n</annotation></semantics></math> est décroissante, de même <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>w_n</annotation></semantics></math> est croissante,
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>w</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>u</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_n&#x2d;w_n=u_{2n+1}</annotation></semantics></math> est positif et tend vers 0. On en déduit que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>v_n</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>w_n</annotation></semantics></math> convergent vers la même limite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math> telle que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub><mi>&gt;</mi><mi>S</mi><mi>&gt;</mi><msub><mi>w</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>v_n&amp;gt;S&amp;gt;w_n</annotation></semantics></math> et les inégalités du théorème s’en déduisent.</p><p><span style="font-weight:bold">Remarque</span><br>
lorsqu’on utilise une suite alternée pour
trouver une valeur approchée, il faut que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> tende assez
vite vers 0, sinon il y aura perte de précision sur la mantisse
lorsqu’on effectuera <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>u_{2n}&#x2d;u_{2n+1}</annotation></semantics></math>. On sommera aussi les termes
par ordre décroissant pour diminuer les erreurs d’arrondi.</p>
<!--TOC section id="sec282" La fonction logarithme-->
<h2 id="sec282" class="section">24.4  La fonction logarithme</h2><!--SEC END --><p><a id="hevea_default333"></a><a id="hevea_default334"></a>
Si nous voulons calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(1+x)</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>x \in [0,1[</annotation></semantics></math> avec une
précision <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math>, il suffit de calculer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mfrac><mrow><msup><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \sum_{k=0}^n (&#x2d;1)^k \frac{x^{k+1}}{k+1} </annotation></semantics></math>
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tel que la valeur absolue du terme suivant soit plus petit 
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>n</mi><mtext> tel que </mtext><mfrac><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mi>&lt;</mi><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'> n \mbox{ tel que } \frac{x^{n+1}}{n+1} &amp;lt; \varepsilon  </annotation></semantics></math>
en effet, les signes sont alternés et la suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mrow><msup><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{x^{k+1}}{k+1}</annotation></semantics></math>
décroit vers 0.</p><p>Si la suite décroit lentement vers 0, cette méthode est
mauvaise numériquement et en temps de calcul
car il y a presque compensation entre
termes successifs donc perte de précision sur la mantisse et il
y a beaucoup de termes à calculer. C’est le cas pour le logarithme,
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est voisin de 1, il faut calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> termes pour avoir une
précision en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>1/n</annotation></semantics></math>, par exemple 1 million de termes pour avoir
une précision de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>6</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;6</annotation></semantics></math> (sans tenir compte des erreurs d’arrondi). 
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>1/2</annotation></semantics></math> il faut de l’ordre
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>&#x03B5;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;\ln(\varepsilon)/\ln(2)</annotation></semantics></math> termes ce qui est mieux, mais encore
relativement grand (par exemple
50 termes environ pour une précision en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>16</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;16</annotation></semantics></math>,
13 termes pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;4</annotation></semantics></math>).
On a donc intérêt à se
ramener si possible à calculer la fonction en un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> où la
convergence est plus rapide (donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x|</annotation></semantics></math> le plus petit possible).
Par exemple pour le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(1+x)</annotation></semantics></math> on peut :
</p><ul class="itemize"><li class="li-itemize">
utiliser la racine carrée
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><msqrt><mrow><mn>1</mn><mo>+</mo><mi>x</mi></mrow></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> ln(1+x)= 2 ln(\sqrt{1+x}) </annotation></semantics></math>
on observe que :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>X</mi><mo>=</mo><msqrt><mrow><mn>1</mn><mo>+</mo><mi>x</mi></mrow></msqrt><mo>&minus;</mo><mn>1</mn><mo>=</mo><mfrac><mi>x</mi><mrow><mn>1</mn><mo>+</mo><msqrt><mrow><mn>1</mn><mo>+</mo><mi>x</mi></mrow></msqrt></mrow></mfrac><mo>&leq;</mo><mfrac><mi>x</mi><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> X=\sqrt{1+x}&#x2d;1 = \frac{x}{1+\sqrt{1+x}} \leq \frac{x}{2}  </annotation></semantics></math>
il faut toutefois faire attention à la perte de précision sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est petit.
</li><li class="li-itemize">utiliser l’inverse
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow><mrow><mn>1</mn><mo>+</mo><mi>x</mi></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \ln(1+x)=&#x2d;\ln(1/(1+x))=&#x2d;\ln(1 + \frac{&#x2d;x}{1+x})  </annotation></semantics></math>
lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est proche de 1, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;x/(1+x)</annotation></semantics></math> est proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>&#x2d;x/2</annotation></semantics></math>, on
a presque divisé par 2. Attention toutefois, on se retrouve alors
avec une série non alternée, mais on peut utiliser 
(<a href="#eqref_54">54</a>) pour majorer le reste dans ce cas.
</li><li class="li-itemize">trouver une valeur approchée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>y_0</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(1+x)</annotation></semantics></math> à une précision
faible, par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;4</annotation></semantics></math>, et utiliser la méthode de Newton pour
améliorer la précision. Soit en effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y=\ln(1+x)</annotation></semantics></math>, alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mi>y</mi></msup><mo>=</mo><mn>1</mn><mo>+</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>e^y=1+x</annotation></semantics></math>, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi> <mi>y</mi></msup><mo>&minus;</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(y)=e^y&#x2d;(1+x)</annotation></semantics></math>, on utilise la suite itérative
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>y</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>y</mi> <mi>n</mi></msub><mo>&minus;</mo><mfrac><mrow><msup><mi>e</mi> <mrow><msub><mi>y</mi> <mi>n</mi></msub></mrow></msup><mo>&minus;</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><msup><mi>e</mi> <mrow><msub><mi>y</mi> <mi>n</mi></msub></mrow></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> y_{n+1} = y_n &#x2d; \frac{e^{y_n}&#x2d;(1+x)}{e^{y_n}}   </annotation></semantics></math>
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>y_0</annotation></semantics></math> est proche à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;4</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>, on peut espérer avoir
une valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>16</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;16</annotation></semantics></math> en 2 itérations. Notez
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> est proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn></mrow><annotation encoding='application/x-tex'>0</annotation></semantics></math>, on est dans un domaine où le calcul
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mi>y</mi></msup></mrow><annotation encoding='application/x-tex'>e^y</annotation></semantics></math> est rapide et précis et de plus la méthode de Newton
“corrige” les erreurs intermédiaires.
</li></ul><p>Nous sommes donc en mesure de calculer précisément le logarithme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(1+x)</annotation></semantics></math> pour disons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>|x|&amp;lt;1/2</annotation></semantics></math>. Pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mi>n</mi></mrow><annotation encoding='application/x-tex'>ln</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mo>+</mo></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^+</annotation></semantics></math>,
on se ramène à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[1,2]</annotation></semantics></math> en utilisant l’écriture
mantisse-exposant, puis si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>x\in[3/2,2]</annotation></semantics></math> on peut en prendre la racine
carrée pour se retrouver dans l’intervalle souhaité.
On peut aussi effectuer une division par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math>.</p><p>Remarquons que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est connu à une erreur relative <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math>
près, comme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&pm;</mo><mi>&#x03B5;</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&pm;</mo><mi>&#x03B5;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \ln(x(1 \pm \varepsilon))=\ln(x) + \ln(1 \pm \varepsilon)  </annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(x)</annotation></semantics></math> est connu à une erreur absolue de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&pm;</mo><mi>&#x03B5;</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&approx;</mo><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>|\ln(1 \pm \varepsilon)| \approx \varepsilon</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(x)</annotation></semantics></math> est proche
de 0, on a une grande perte de précision relative.</p><p>Finalement, nous savons calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi></mrow><annotation encoding='application/x-tex'>\ln</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>exp</mi></mrow><annotation encoding='application/x-tex'>\exp</annotation></semantics></math> sous réserve
d’avoir dans une table la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(2)</annotation></semantics></math>. Pour calculer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(2)</annotation></semantics></math> précisément, on peut utiliser
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \ln(2)=&#x2d;ln(1/2)=&#x2d;ln(1&#x2d;1/2)  </annotation></semantics></math>
et le développement en série calculé en mode exact avec des
fractions à un ordre suffisant, on majore le reste en utilisant 
que le terme général de la série <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(1+x)</annotation></semantics></math> est borné par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>M=1</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x=1</annotation></semantics></math>, donc d’après (<a href="#eqref_54">54</a>) :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>R</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mn>1</mn><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> |R_n| \leq \frac{1}{2^n} </annotation></semantics></math>
(on peut même obtenir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><msup><mn>2</mn> <mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>1/(n2^n)</annotation></semantics></math> car on a besoin de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> uniquement
pour les termes d’ordre plus grand que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, on peut donc prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>M=1/n</annotation></semantics></math>).
Par exemple, pour avoir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(2)</annotation></semantics></math> avec une mantisse de 80 bits,
on effectue une fois pour toutes avec un logiciel
de calcul formel :<br>
<code>a:=sum((1/2)^k/k,k=1..80)</code>|<br>
puis la division en base 2 avec 81 bits de précision
<code>iquo(numer(a)*2^81,denom(a))</code></p><p>Exercice : pour les fonctions trigonométriques, il faut une
méthode de calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&pi;</mi></mrow><annotation encoding='application/x-tex'>\pi</annotation></semantics></math>. On peut par exemple faire le calcul
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>16</mn><mi>arctan</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">/</mo><mn>5</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mn>4</mn><mi>arctan</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">/</mo><mn>239</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>16 \arctan(1/5)&#x2d;4\arctan(1/239)</annotation></semantics></math> en utilisant le développement
de la fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>arctan</mi></mrow><annotation encoding='application/x-tex'>\arctan</annotation></semantics></math> à un ordre suffisant.</p>
<!--TOC section id="sec283" Approximants de Padé.-->
<h2 id="sec283" class="section">24.5  Approximants de Padé.</h2><!--SEC END --><p><a id="hevea_default335"></a>
Soit une fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math> dont on connait le développement
de Taylor <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> en 0 à l’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, on souhaiterait plutot
approcher <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> par une fraction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">/</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>P/Q</annotation></semantics></math> avec degré<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>(P) \leq d</annotation></semantics></math>
et degré<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>(Q) \leq n&#x2d;d</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo>=</mo><mi>B</mi><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>P</mi><mi>Q</mi></mfrac><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f=B+O(x^{n+1})=\frac P Q +O(x^{n+1})  </annotation></semantics></math>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>Q(0)=0</annotation></semantics></math>, ceci équivaut à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>B</mi><mi>Q</mi><mo>+</mo><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>S</mi></mrow><annotation encoding='application/x-tex'>P=BQ+x^{n+1} S</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi><mo>,</mo><mi>P</mi><mo>,</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>S, P,Q</annotation></semantics></math> sont
des polynômes inconnus. On reconnait une identité de type
Bézout pour les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A=x^{n+1}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>.
On déroule l’algorithme d’Euclide itératif pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>, on définit
donc 3 suites <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>U</mi> <mi>k</mi></msub><mo>,</mo><msub><mi>V</mi> <mi>k</mi></msub><mo>,</mo><msub><mi>R</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>U_k, V_k, R_k</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>R_k</annotation></semantics></math> est la suite des restes d’Euclide
de degrés strictement décroissants
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>R</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>R</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>R</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mspace width="mediummathspace"/><msub><mi>U</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>U</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>U</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>V</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>V</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>V</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>R_{k+2}=R_k &#x2d; Q_k R_{k+1},\ U_{k+2}=U_k &#x2d; Q_k U_{k+1}, V_{k+2}=V_k &#x2d; Q_k V_{k+1}  </annotation></semantics></math>
et les initialisations :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>U</mi> <mn>0</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>U</mi> <mn>1</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>V</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>V</mi> <mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>R</mi> <mn>0</mn></msub><mo>=</mo><mi>A</mi><mo>,</mo><msub><mi>R</mi> <mn>1</mn></msub><mo>=</mo><mi>B</mi></mrow><annotation encoding='application/x-tex'>U_0=1, U_1=0, V_0=0, V_1=1, R_0=A, R_1=B </annotation></semantics></math>
On s’arrête au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>N+1</annotation></semantics></math> tel que degré<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi> <mi>N</mi></msub><mo stretchy="false">)</mo><mi>&gt;</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>(R_N)&amp;gt;d</annotation></semantics></math> et degré<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi> <mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>&leq;</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>(R_{N+1}) \leq d</annotation></semantics></math>.
Rappelons qu’on montre par récurrence que :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>V</mi> <mi>k</mi></msub><msub><mi>R</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>V</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>R</mi> <mi>k</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><msup><mi>X</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>V_k R_{k+1} &#x2d; V_{k+1} R_k = (&#x2d;1)^{k+1} X^{n+1}  </annotation></semantics></math>
D’autre part la suite des degrés des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>V</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>V_k</annotation></semantics></math> est strictement croissante
à partir du rang 1 (car degré<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>Q</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>(Q_k)&amp;gt;0</annotation></semantics></math>), on en déduit que
degré<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>V</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(V_{k+1})</annotation></semantics></math>+degré<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>(R_k)=n+1</annotation></semantics></math> donc degré<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>V</mi> <mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>(V_{N+1}) \leq n&#x2d;d</annotation></semantics></math>.
On pose alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>R</mi> <mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P=R_{N+1}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><msub><mi>V</mi> <mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>Q=V_{N+1}</annotation></semantics></math>, qui vérifient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>B</mi><mi>Q</mi><mo>+</mo><mi>A</mi><msub><mi>U</mi> <mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P=BQ+AU_{N+1}</annotation></semantics></math>.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>Q(0) \neq 0</annotation></semantics></math> on a existence d’une solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">/</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>P/Q</annotation></semantics></math>, 
et cette solution est alors
unique, car si on a 2 triplets solutions
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>=</mo><mi>B</mi><mi>Q</mi><mo>+</mo><mi>A</mi><mi>S</mi><mo>,</mo><mspace width="mediummathspace"/><mi>P</mi><mo>&prime;</mo><mo>=</mo><mi>B</mi><mi>Q</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>A</mi><mi>S</mi><mo>&prime;</mo><mo>,</mo><mspace width="1em"/><mi>A</mi><mo>=</mo><msup><mi>X</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>P=BQ+AS, \ P&apos;=BQ&apos;+AS&apos;, \quad A=X^{n+1} </annotation></semantics></math>
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mi>Q</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>P</mi><mo>&prime;</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>PQ&apos;&#x2d;P&apos;Q</annotation></semantics></math> est un multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>X^{n+1}</annotation></semantics></math> donc nul pour des raisons
de degré, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">/</mo><mi>Q</mi><mo>=</mo><mi>P</mi><mo>&prime;</mo><mo stretchy="false">/</mo><mi>Q</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P/Q=P&apos;/Q&apos;</annotation></semantics></math>.</p><p>Par exemple, pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi> <mi>x</mi></msup></mrow><annotation encoding='application/x-tex'>f(x)=e^x</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>10</mn><mo>,</mo><mi>d</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>n=10, d=5</annotation></semantics></math>, <code>pade(e^x,x,10,6)</code>
renvoie le quotient de deux polynômes de degré 5
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><msub><mi>P</mi> <mn>2</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub></mrow><mrow><msub><mi>P</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>P</mi> <mn>1</mn></msub></mrow></mfrac><mo>,</mo><mspace width="mediummathspace"/><msub><mi>P</mi> <mn>2</mn></msub><mo>=</mo><mn>30240</mn><mo>+</mo><mn>3360</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>30</mn><msup><mi>x</mi> <mn>4</mn></msup><mo>,</mo><mspace width="mediummathspace"/><msub><mi>P</mi> <mn>1</mn></msub><mo>=</mo><mi>x</mi><mo stretchy="false">(</mo><mn>15120</mn><mo>+</mo><mn>420</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\frac{P_2+P_1}{P_2&#x2d;P_1}, \ P_2=30240+3360x^2+30x^4,\ P_1=x(15120+420x^2+x^4) </annotation></semantics></math>
fraction que l’on peut évaluer en 12 opérations (5 additions, 1
soustraction, 5 multiplications et 1 division)
et qui donne une approximation de meilleure qualité que le
développement de Taylor à l’ordre 10.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;height:40px;font-style:large">x:=0.5; X:=x*x; a:=(30X+3360)*X+30240;
b:=x*((X+420)*X+15120); (a+b)/(a-b); exp(0.5); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
Pour démontrer des estimations sur l’erreur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>P</mi><mo stretchy="false">/</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>f(x)&#x2d;P/Q</annotation></semantics></math>, il n’existe
pas à ma connaissance de résultat explicite général. 
Pour la fonction exponentielle, on peut calculer l’erreur relative
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>&minus;</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup><mi>P</mi><mo stretchy="false">/</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>g(x)=1&#x2d;e^{&#x2d;x}P/Q</annotation></semantics></math>
puis étudier la fonction.
</p><pre class="verbatim">P,Q:=fxnd(pade(exp(x),x,10,6));
g:=1-exp(-x)*P/Q; factor(g');
</pre><p>
On en déduit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> est une fonction décroissante
(nulle en l’origine), son maximum en valeur absolue
est donc atteint aux bornes de l’intervalle d’étude, par
exemple sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>4</mn><mo>,</mo><mn>1</mn><mo stretchy="false">/</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1/4,1/4]</annotation></semantics></math>, l’erreur relative est majorée
par <code>3e-17</code>, il faudrait aller à l’ordre 12 pour
avoir la même précision avec Taylor donc faire 23 opérations,
quasiment le double. Visuellement, le graphe de l’exponentielle et de
l’approximation de Padé sont encore très proches pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>x=5</annotation></semantics></math>.
</p><pre class="verbatim">f(x):={
  local P1,P2,x2;
  x2:=x*x;
  P2:=30240+x2*(3360+30*x2);
  P1:=x*(15120+x2*(420+x2));
  retourne (P2+P1)/(P2-P1);
}:;
plot([f(x),exp(x)],x=-6..6,color=[blue,red]);
</pre>
<!--TOC section id="sec284" Autres applications-->
<h2 id="sec284" class="section">24.6  Autres applications</h2><!--SEC END --><p>
On peut calculer certaines intégrales de la même manière,
par exemple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow></msubsup><mfrac><mn>1</mn><msqrt><mrow><mn>1</mn><mo>+</mo><msup><mi>x</mi> <mn>3</mn></msup></mrow></msqrt></mfrac></mrow><annotation encoding='application/x-tex'> \int _0^{1/2} \frac{1}{\sqrt{1+x^3}} </annotation></semantics></math>
mais aussi des fonctions définies par des intégrales (cas de nombreuses
fonctions spéciales).</p>
<!--TOC subsection id="sec285" Exemple : la fonction d’erreur (error fonction, <span style="font-family:monospace">erf</span>)-->
<h3 id="sec285" class="subsection">24.6.1  Exemple : la fonction d’erreur (error fonction, <span style="font-family:monospace">erf</span>)</h3><!--SEC END --><p><a id="hevea_default336"></a><a id="hevea_default337"></a>
Cette fonction est définie à une constante multiplicative près par :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>x</mi></msubsup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>t</mi> <mn>2</mn></msup></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'> f(x)=\int_0^x e^{&#x2d;t^2} \ dt  </annotation></semantics></math>
On peut développer en séries entières l’intégrand (rayon
de convergence <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>+\infty</annotation></semantics></math>), puis intégrer terme
à terme, on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></munderover><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mfrac><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msup></mrow><mrow><mi>n</mi><mo>!</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> f(x)= \sum_{n=0}^{+\infty} (&#x2d;1)^n \frac{x^{2n}}{n! (2n+1)} </annotation></semantics></math>
Ce développement converge très rapidement pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>|x|\leq 1</annotation></semantics></math>.
Par contre, pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x|</annotation></semantics></math> grand, il faut calculer beaucoup de termes
avant que le reste soit suffisamment petit pour être négligeable,
et certains termes intermédiaires sont grands, ce qui provoque
une perte de précision qui peut rendre le résultat calculé
complètement faux. Contrairement à la fonction exponentielle,
il n’y a pas de possibilité de réduire l’argument à une plage
où la série converge vite. Il faut donc
</p><ul class="itemize"><li class="li-itemize">
soit utiliser des flottants multiprécision, avec une précision
augmentée de la quantité nécessaire pour avoir un résultat fiable
</li><li class="li-itemize">soit, pour les grandes valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>, utiliser un développement
asymptotique (en puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>1/x</annotation></semantics></math>) de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>t</mi> <mn>2</mn></msup></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'> \int_x^{+\infty} e^{&#x2d;t^2} \ dt  </annotation></semantics></math>
ainsi que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>t</mi> <mn>2</mn></msup></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mfrac><msqrt><mi>&pi;</mi></msqrt><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> \int_0^{+\infty} e^{&#x2d;t^2} \ dt =\frac{\sqrt{\pi }}{2}  </annotation></semantics></math>
Le développement asymptotique
s’obtient par exemple en changeant de variable
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>=</mo><msup><mi>t</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>u=t^2</annotation></semantics></math> et en effectuant des intégrations par parties répétées
en intégrant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>u</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{&#x2d;u}</annotation></semantics></math> et en dérivant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>u</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>u^{&#x2d;1/2}</annotation></semantics></math> et ses dérivées
successives. Ce type de développement asymptotique a la propriété
inverse du développement en 0: les termes successifs commencent
par décroitre avant de croitre et de tendre vers l’infini. Il faut
donc arrêter le développement à un rang donné (dépendant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>)
et il est impossible d’obtenir une précision meilleure pour cette
valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> par un développement asymptotique (on parle parfois de
développement des astronomes).
</li></ul><p><span style="font-weight:bold">Exercice </span>: donner une valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(1)</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>16</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;16</annotation></semantics></math> près.
Combien de termes faut-il calculer dans la somme pour trouver
une valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(7)</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>16</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;16</annotation></semantics></math> près ? Comparer la valeur
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(7)</annotation></semantics></math> et la valeur absolue du plus grand terme de la série,
quelle est la perte de précision relative si on effectue les
calculs en virgule flottante ? Combien de chiffres significatifs
faut-il utiliser pour assurer une précision finale de 16 chiffres
en base 10 ? Calculer le développement asymptotique en l’infini
et déterminer un encadrement de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(7)</annotation></semantics></math> par ce développement. Combien
de termes faut-il calculer pour déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(10)</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>16</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;16</annotation></semantics></math> près
par le développement asymptotique et par le développement en séries ?
Quelle est la meilleure méthode pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(10)</annotation></semantics></math> ?</p>
<!--TOC subsection id="sec286" Recherche de solutions d’équations différentielles-->
<h3 id="sec286" class="subsection">24.6.2  Recherche de solutions d’équations différentielles</h3><!--SEC END --><p>
On peut aussi appliquer les techniques ci-dessus pour calculer
des solutions de certaines équations différentielles dont les
solutions ne s’expriment pas à l’aide des fonctions usuelles,
on remplace dans l’équation la fonction inconnue par son 
développement en séries et on cherche une relation de récurrence
entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{n+1}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>a_n</annotation></semantics></math>. Si on arrive à montrer par exemple
qu’il y a une solution ayant un développement alternée, 
ou plus généralement,
si on a une majoration <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">/</mo><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>C</mi></mrow><annotation encoding='application/x-tex'>|a_{n+1}/a_n|&amp;lt;C</annotation></semantics></math>, alors le reste de la
série entière est majoré par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>n</mi></msup><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mo stretchy="false">&vert;</mo><mi>C</mi><mi>x</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>|a_nx^n|/(1&#x2d;|Cx|)</annotation></semantics></math> lorsque
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mn>1</mn><mo stretchy="false">/</mo><mi>C</mi></mrow><annotation encoding='application/x-tex'>|x|&amp;lt;1/C</annotation></semantics></math>, on peut alors calculer des valeurs approchées
de la fonction solution à la précision souhaitée en utilisant
le développement en séries entières.</p>
<!--TOC subsection id="sec287" Exemple : fonctions de Bessel d’ordre entier-->
<h3 id="sec287" class="subsection">24.6.3  Exemple : fonctions de Bessel d’ordre entier</h3><!--SEC END --><p><a id="hevea_default338"></a>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> un entier positif fixé, on considère l’équation
différentielle
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mi>y</mi><mo>&prime;</mo><mo>&prime;</mo><mo>+</mo><mi>x</mi><mi>y</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><msup><mi>m</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> x^2 y&apos;{&apos;} + x y&apos; + (x^2&#x2d;m^2)y=0  </annotation></semantics></math>
dont on cherche une solution série entière 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></msubsup><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>y=\sum_{k=0}^\infty a_k x^k </annotation></semantics></math>. En remplacant dans l’équation, si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est dans le rayon de convergence de la série (rayon supposé
non nul), on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup><mo>+</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mi>k</mi><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup><mo>+</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><msup><mi>m</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> 
\sum_{k=0}^\infty k(k&#x2d;1)a_k x^k + \sum_{k=0}^\infty k a_k x^k 
+ \sum_{k=0}^\infty (x^2&#x2d;m^2) a_k x^k =0
 </annotation></semantics></math>
soit encore
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mn>0</mn></mtd> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mo stretchy="false">(</mo><msup><mi>k</mi> <mn>2</mn></msup><mo>&minus;</mo><msup><mi>m</mi> <mn>2</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>m</mi> <mn>2</mn></msup><msub><mi>a</mi> <mn>0</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msup><mi>m</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><msub><mi>a</mi> <mn>1</mn></msub><mi>x</mi><mo>+</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow> <mn>&infin;</mn></munderover><mo stretchy="false">[</mo><mo stretchy="false">(</mo><msup><mi>k</mi> <mn>2</mn></msup><mo>&minus;</mo><msup><mi>m</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><msub><mi>a</mi> <mi>k</mi></msub><mo>+</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">]</mo><msup><mi>x</mi> <mi>k</mi></msup></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
0 &amp;=&amp; \sum_{k=0}^\infty (k^2&#x2d;m^2+x^2) a_k x^k  \\
 &amp;=&amp; &#x2d;m^2 a_0 + (1&#x2d;m^2)a_1 x + \sum_{k=2}^\infty [(k^2&#x2d;m^2) a_k +a_{k&#x2d;2}]x^k 
 \end{matrix} </annotation></semantics></math>
Par exemple, prenons le cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>m=0</annotation></semantics></math>. On a alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>a_0</annotation></semantics></math> quelconque, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>a_1</annotation></semantics></math>
nul et pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&geq;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>k\geq 2</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mi>k</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><msub><mi>a</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow><mrow><msup><mi>k</mi> <mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> a_k = &#x2d; \frac{a_{k&#x2d;2}}{k^2} </annotation></semantics></math>
Donc tous les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> d’indice impair sont nuls. Les pairs sont non nuls
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>a_0\neq 0</annotation></semantics></math>, et ils sont de signe alterné.
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> fixé, on observe que pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>k</mi><mi>&gt;</mi><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>2k &amp;gt; |x|</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub><msup><mi>x</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><msup><mi>x</mi> <mrow><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>2</mn></mrow></msup><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |a_{2k} x^{2k}| &amp;lt; |a_{2k&#x2d;2} x^{2k&#x2d;2}|  </annotation></semantics></math>
donc la série <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></msubsup><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>\sum_{k=0}^\infty a_k x^k</annotation></semantics></math> est alternée à partir
du rang partie entière de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x|</annotation></semantics></math> plus un. Donc elle converge pour
tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> (le rayon de convergence de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>+\infty</annotation></semantics></math>) 
et le reste de la somme jusqu’à l’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding='application/x-tex'>2n</annotation></semantics></math> est
inférieur en valeur absolue à :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>R</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><msup><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |R_{2n}(x)| \leq |a_{2n+2} x^{2n+2}|  </annotation></semantics></math>
Par exemple, pour avoir une valeur approchée à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>1e&#x2d;10</annotation></semantics></math> près de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y(x)</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a_0=1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>|x|\leq 1</annotation></semantics></math>, on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mn>2</mn><mi>n</mi></mrow></msubsup><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>y=\sum_{k=0}^{2n} a_k x^k </annotation></semantics></math>,
on s’arrête au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tel que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><msup><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mn>10</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>10</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> |a_{2n+2} x^{2n+2}| \leq |a_{2n+2}| \leq 10^{&#x2d;10}  </annotation></semantics></math>
On remarque que :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msub><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup></mrow><mrow><msup><mn>2</mn> <mn>2</mn></msup><msup><mn>4</mn> <mn>2</mn></msup><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup></mrow><mrow><msup><mn>2</mn> <mrow><mn>2</mn><mi>n</mi></mrow></msup><mi>n</mi><msup><mo>!</mo> <mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> a_{2n} = \frac{(&#x2d;1)^n}{2^2 4^2 ... (2n)^2} = \frac{(&#x2d;1)^n}{2^{2n} n!^2}  </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>7</mn></mrow><annotation encoding='application/x-tex'>n=7</annotation></semantics></math> convient.</p><p>Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>m \neq 0</annotation></semantics></math>, on peut faire un raisonnement analogue (les
calculs sont un peu plus compliqués).</p><p>On a ainsi trouvé une solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>y_0</annotation></semantics></math> de l’équation
différentielle de départ dont on peut facilement calculer
une valeur approchée (aussi facilement que par exemple la fonction sinus
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>|x| \leq 1</annotation></semantics></math>), 
on peut alors trouver toutes les solutions de l’équation
différentielle (en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>y</mi> <mn>0</mn></msub><mi>z</mi></mrow><annotation encoding='application/x-tex'>y=y_0 z</annotation></semantics></math> et en cherchant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>).</p><p><span style="font-weight:bold">Exercice :</span> faire de même pour les solutions de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>&prime;</mo><mo>&prime;</mo><mo>&minus;</mo><mi>x</mi><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y&apos;{&apos;}&#x2d;xy=0</annotation></semantics></math> (fonctions de Airy).</p>
<!--TOC section id="sec288" Développements asymptotiques et séries
divergentes-->
<h2 id="sec288" class="section">24.7  Développements asymptotiques et séries
divergentes</h2><!--SEC END --><p><a id="hevea_default339"></a>
Un développement asymptotique est une généralisation d’un développement de Taylor, par exemple
lorsque le point de développement est en l’infini. De nombreuses fonctions ayant
une limite en l’infini admettent un développement asymptotique en l’infini, mais ces
développements sont souvent des séries qui semblent commencer par converger
mais sont divergentes. Ce type de développement s’avère néanmoins très utile lorsqu’on
n’a pas besoin d’une trop grande précision sur la valeur de la fonction.</p><p>Nous allons illustrer ce type de développement sur un exemple, la fonction 
<span style="font-weight:bold">exponentielle intégrale</span><a id="hevea_default340"></a><a id="hevea_default341"></a>, 
définie à une constante près par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'> f(x)=\int_x^{+\infty} \frac{e^{&#x2d;t}}{t} \ dt  </annotation></semantics></math>
On peut montrer que l’intégrale existe bien, car l’intégrand est positif et inférieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{&#x2d;t}</annotation></semantics></math>
(qui admet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>&#x2d;e^{&#x2d;t}</annotation></semantics></math> comme primitive, cette primitive ayant une limite en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>+\infty</annotation></semantics></math>).
Pour trouver le développement asymptotique de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>+\infty</annotation></semantics></math>, on effectue des intégrations
par parties répétées, en intégrant l’exponentielle et en dérivant la fraction rationnelle
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">[</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mi>t</mi></mfrac><msubsup><mo stretchy="false">]</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>t</mi> <mn>2</mn></msup></mrow></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup></mrow><mi>x</mi></mfrac><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mrow><msup><mi>t</mi> <mn>2</mn></msup></mrow></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup></mrow><mi>x</mi></mfrac><mo>&minus;</mo><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mrow><msup><mi>t</mi> <mn>2</mn></msup></mrow></mfrac><msubsup><mo stretchy="false">]</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>t</mi> <mn>3</mn></msup></mrow></mfrac><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup></mrow><mi>x</mi></mfrac><mo>&minus;</mo><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup></mrow><mrow><msup><mi>x</mi> <mn>2</mn></msup></mrow></mfrac><mo>+</mo><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><mn>2</mn><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mrow><msup><mi>t</mi> <mn>3</mn></msup></mrow></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup><mrow><mo>(</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><mo>&minus;</mo><mfrac><mn>1</mn><mrow><msup><mi>x</mi> <mn>2</mn></msup></mrow></mfrac><mo>+</mo><mfrac><mn>2</mn><mrow><msup><mi>x</mi> <mn>3</mn></msup></mrow></mfrac><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mfrac><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mi>n</mi><mo>!</mo></mrow><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo>)</mo></mrow><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mrow><msup><mi>t</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 f(x)&amp;=&amp;[\frac{&#x2d;e^{&#x2d;t}}{t}]_x^{+\infty} &#x2d; \int_x^{+\infty} \frac{&#x2d;e^{&#x2d;t}}{&#x2d;t^2} \ dt \\
&amp;=&amp; \frac{e^{&#x2d;x}}{x} &#x2d; \int_x^{+\infty} \frac{e^{&#x2d;t}}{t^2} \ dt \\
&amp;=&amp; \frac{e^{&#x2d;x}}{x} &#x2d; ([\frac{&#x2d;e^{&#x2d;t}}{t^2}]_x^{+\infty} &#x2d; \int_x^{+\infty} \frac{&#x2d;2e^{&#x2d;t}}{&#x2d;t^3}) \\
&amp;=&amp; \frac{e^{&#x2d;x}}{x} &#x2d; \frac{e^{&#x2d;x}}{x^2} + \int_x^{+\infty} \frac{2e^{&#x2d;t}}{t^3} \ dt \\
&amp;=&amp; ... \\
&amp;=&amp; e^{&#x2d;x}\left(\frac{1}{x} &#x2d; \frac{1}{x^2} + \frac{2}{x^3} + ... + \frac{(&#x2d;1)^n n!}{x^{n+1}}\right)
&#x2d; \int_x^{+\infty} \frac{(&#x2d;1)^n (n+1)!e^{&#x2d;t}}{t^{n+2}} \ dt \\
&amp;=&amp; S(x) + R(x)
 \end{matrix} </annotation></semantics></math>
où
<a id="eqref_55"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup><mrow><mo>(</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><mo>&minus;</mo><mfrac><mn>1</mn><mrow><msup><mi>x</mi> <mn>2</mn></msup></mrow></mfrac><mo>+</mo><mfrac><mn>2</mn><mrow><msup><mi>x</mi> <mn>3</mn></msup></mrow></mfrac><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mfrac><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mi>n</mi><mo>!</mo></mrow><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo>)</mo></mrow><mo>,</mo><mspace width="1em"/><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mrow><msup><mi>t</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mspace width="2em"/><mo stretchy="false">(</mo><mn>55</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 S(x)=e^{&#x2d;x}
\left(\frac{1}{x} &#x2d; \frac{1}{x^2} + \frac{2}{x^3} + ... + \frac{(&#x2d;1)^n n!}{x^{n+1}}\right), 
\quad R(x)=&#x2d; \int_x^{+\infty} \frac{(&#x2d;1)^n (n+1)!e^{&#x2d;t}}{t^{n+2}} \ dt 
\qquad (55) </annotation></semantics></math>
Le développement en séries est divergent puisque pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>x&amp;gt;0</annotation></semantics></math> fixé et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tendant vers l’infini
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munder><mi>lim</mi> <mrow><mi>n</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></munder><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'> \lim_{n\rightarrow +\infty} \frac{n!}{x^{n+1}} = +\infty </annotation></semantics></math>
mais si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est grand, au début la série semble converger, de manière très rapide :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mi>x</mi></mfrac><mi>&gt;</mi><mi>&gt;</mi><mfrac><mn>1</mn><mrow><msup><mi>x</mi> <mn>2</mn></msup></mrow></mfrac><mi>&gt;</mi><mi>&gt;</mi><mfrac><mn>2</mn><mrow><msup><mi>x</mi> <mn>3</mn></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \frac{1}{x} &amp;gt;&amp;gt; \frac{1}{x^2} &amp;gt;&amp;gt; \frac{2}{x^3}  </annotation></semantics></math>
On peut utiliser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>S(x)</annotation></semantics></math> comme valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> grand si on sait majorer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>R(x)</annotation></semantics></math> par un nombre suffisamment petit. On a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup></mrow><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> | R(x) | \leq \int_x^{+\infty} \frac{(n+1)!e^{&#x2d;t}}{x^{n+2}}
= \frac{(n+1)!e^{&#x2d;x}}{x^{n+2}}  </annotation></semantics></math>
On retrouve une majoration du type de celle des séries alternées, 
l’erreur relative est inférieure
à la valeur absolue du dernier terme sommé divisé par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup><mo stretchy="false">/</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>e^{&#x2d;x}/x</annotation></semantics></math>. 
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> fixé assez grand, il 
faut donc trouver un rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, s’il en existe un, 
tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo><mo stretchy="false">/</mo><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>&lt;</mi><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>(n+1)!/x^{n+1}&amp;lt;\epsilon</annotation></semantics></math> où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>\epsilon</annotation></semantics></math> est la précision relative que l’on s’est fixée.
Par exemple, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&geq;</mo><mn>100</mn></mrow><annotation encoding='application/x-tex'>x\geq 100</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>11</mn></mrow><annotation encoding='application/x-tex'>n=11</annotation></semantics></math> convient pour 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo>=</mo><mn>12</mn><mo>!</mo><mo stretchy="false">/</mo><msup><mn>100</mn> <mn>12</mn></msup><mo>=</mo><mn>5</mn><mi>e</mi><mo>&minus;</mo><mn>16</mn></mrow><annotation encoding='application/x-tex'>\epsilon=12!/100^{12}=5e&#x2d;16</annotation></semantics></math> (à peu près
la précision relative d’un “double”).
Ceci permet d’avoir une approximation de la fonction avec une bonne
précision et peu de calculs, mais contrairement aux séries entières,
il n’est pas possible d’améliorer cette précision de manière
arbitraire en poussant le développement plus loin, il y a une
précision maximale possible (qui dépend de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>).</p><p>Ce type de développement asymptotique peut être effectué pour
d’autres fonctions du même type, par exemple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>t</mi> <mn>2</mn></msup></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>,</mo><mspace width="1em"/><msubsup><mo>&Integral;</mo> <mi>x</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>,</mo><mspace width="1em"/><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'> \int_x^{+\infty} e^{&#x2d;t^2} \ dt, \quad \int_x^{+\infty} \frac{\sin(t)}{t} \ dt, \quad ...  </annotation></semantics></math></p><p><span style="font-weight:bold">Digression: calcul approché de la constante d’Euler
</span><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>\gamma</annotation></semantics></math><a id="hevea_default342"></a><br>
On peut montrer que
<a id="eqref_56"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munder><mi>lim</mi> <mrow><mi>n</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></munder><msub><mi>u</mi> <mi>n</mi></msub><mo>,</mo><mspace width="1em"/><msub><mi>u</mi> <mi>n</mi></msub><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mfrac><mn>1</mn><mi>k</mi></mfrac><mo>&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>56</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 \lim_{n\rightarrow +\infty} u_n, \quad u_n=\sum_{k=1}^{n}\frac{1}{k} &#x2d; \ln(n) 
\qquad (56) </annotation></semantics></math>
existe (par exemple en cherchant un équivalent de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_{n+1}&#x2d;u_n</annotation></semantics></math> qui vaut 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><mrow><mn>2</mn><msup><mi>n</mi> <mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{&#x2d;1}{2n^2}</annotation></semantics></math>)
et on définit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>\gamma</annotation></semantics></math> comme sa limite. Malheureusement, la convergence
est très lente et cette définition n’est pas applicable pour obtenir la valeur
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>\gamma</annotation></semantics></math> avec une très grande précision.
Il y a un lien entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>\gamma</annotation></semantics></math> et la fonction exponentielle intégrale, plus précisément
lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&rightarrow;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>x\rightarrow 0</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math> admet une singularité en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;\ln(x)</annotation></semantics></math>,
plus précisément <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)+\ln(x)</annotation></semantics></math>
admet un développement en séries (de rayon de convergence <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>+\infty</annotation></semantics></math>), car :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mi>x</mi> <mn>1</mn></msubsup><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>x</mi></msubsup><mfrac><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 f(x)+\ln(x)&amp;=&amp;\int_x^{1}\frac{e^{&#x2d;t}&#x2d;1}{t} \ dt + \int_1^{+\infty} \frac{e^{&#x2d;t}}{t} \ dt \\
&amp;=&amp; \int_0^{1}\frac{e^{&#x2d;t}&#x2d;1}{t} \ dt + \int_1^{+\infty} \frac{e^{&#x2d;t}}{t} \ dt
&#x2d; \int_0^{x} \frac{e^{&#x2d;t}&#x2d;1}{t} \ dt
 \end{matrix} </annotation></semantics></math>
Que vaut la constante du membre de droite :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>C</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mo stretchy="false">(</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mfrac><mn>1</mn><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'> C=\int_0^{1}(e^{&#x2d;t}&#x2d;1)\frac{1}{t} \ dt + \int_1^{+\infty} e^{&#x2d;t} \frac{1}{t} \ dt  </annotation></semantics></math>
Il se trouve que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>C=&#x2d;\gamma</annotation></semantics></math> (voir plus bas une démonstration condensée) et donc :
<a id="eqref_57"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&gamma;</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>x</mi></msubsup><mfrac><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>57</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 \gamma= \int_0^{x} \frac{1&#x2d;e^{&#x2d;t}}{t} \ dt &#x2d;f(x)&#x2d;\ln(x)
\qquad (57) </annotation></semantics></math>
Pour obtenir une valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>\gamma</annotation></semantics></math>, il suffit donc de prendre un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> assez grand
pour pouvoir calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math> par son développement asymptotique à la précision requise,
puis de calculer l’intégrale du membre de droite par le développement en séries en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>x=0</annotation></semantics></math>
(en utilisant une précision intermédiaire plus grande puisque ce développement en séries
va sembler diverger au début avant de converger pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> suffisamment grand).
Par exemple, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>13</mn></mrow><annotation encoding='application/x-tex'>x=13</annotation></semantics></math>, on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(13)</annotation></semantics></math> par (<a href="#eqref_55">55</a>)
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>13</mn></mrow><annotation encoding='application/x-tex'>n=13</annotation></semantics></math> (qui correspond au moment où le terme général
de la série est minimum puisque le rapport de deux termes successifs
est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo stretchy="false">/</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>n/x</annotation></semantics></math>)
et une erreur absolue inférieure à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>13</mn></mrow></msup><mn>13</mn><mo>!</mo><mo stretchy="false">/</mo><msup><mn>13</mn> <mn>14</mn></msup><mo>=</mo><mn>4</mn><mi>e</mi><mo>&minus;</mo><mn>12</mn></mrow><annotation encoding='application/x-tex'>e^{&#x2d;13} 13!/13^{14}=4e&#x2d;12</annotation></semantics></math>
</p><div class="center">
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>13</mn><mo stretchy="false">)</mo><mo>&approx;</mo></mrow><annotation encoding='application/x-tex'>f(13) \approx</annotation></semantics></math> <code>exp(-13)*sum((-1)^n*n!/13.^(n+1),n=0..13)</code>
</div><p>
puis on remplace dans (<a href="#eqref_57">57</a>), avec 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>x</mi></msubsup><mfrac><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mfrac><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \int_0^{x} \frac{1&#x2d;e^{&#x2d;t}}{t} \ dt = 
\sum_{n=0}^{\infty} (&#x2d;1)^n \frac{x^{n+1}}{(n+1) (n+1)!} </annotation></semantics></math>
dont on obtient une valeur approchée, 
en faisant la somme jusqu’au rang 49 (pour lequel
le terme général est de l’ordre de <code>1e-12</code>),
le reste de cette somme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>50</mn></msub></mrow><annotation encoding='application/x-tex'>R_{50}</annotation></semantics></math> est positif et est inférieur à
<span style="font-family:monospace">(-1)</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">50*13.</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">51/51/51!)</span> qui est de l’ordre de 
<code>8e-12</code>
</p><div class="center">
<code>evalf(sum((-1)^n*13^(n+1)/(n+1)/(n+1)!,n=0..49))</code>
</div><p>
La somme argument de <code>evalf</code>
étant exacte, il n’y a pas de problèmes de perte de précision,
on peut aussi faire les calculs intermédiaires en arithmétique approchée,
on doit alors prendre 4 chiffres significatifs de plus
pour tenir compte de la valeur du plus grand terme
sommé dans la série, terme que l’on détermine par exemple par
</p><div class="center">
<span style="font-family:monospace">seq(13.</span><code><span style="font-family:monospace">^</span></code><span style="font-family:monospace">(n+1)/(n+1)/(n+1)!,n=0..20)</span>
</div><p> 
ce terme vaut <code>13^11/11/11!</code> soit 4000 environ)
</p><div class="center">
<code>Digits:=16; sum((-1)^n*13.^(n+1)/(n+1)/(n+1)!,n=0..49)</code>
</div><p>
On obtient finalement comme valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>\gamma</annotation></semantics></math>
</p><div class="center">
<code>-exp(-13)*sum((-1)^n*n!/13.^(n+1),n=0..13)-ln(13)+</code><br>
<code>  sum((-1)^n*13^(n+1)/(n+1)/(n+1)!,n=0..49)</code>
</div><p>
soit <code>0.577215664897</code> avec une erreur inférieure à <code>1.2e-11</code>.
Bien entendu, cette méthode est surtout intéressante si on veut calculer
un grand nombre de décimales de la constante d’Euler, sinon
on peut par exemple appliquer la méthode d’accélération de Richardson à
la suite convergente (<a href="#eqref_56">56</a>) qui définit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>\gamma</annotation></semantics></math>
ou d’autres méthodes d’accélération (en transformant par
exemple la série en série alternée). On calcule alors
de deux manières différentes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> plus grand (déterminé
par la précision qu’on peut obtenir par le développement
aymptotique de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>).</p><p>On peut calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&pi;</mi></mrow><annotation encoding='application/x-tex'>\pi</annotation></semantics></math> de la même manière avec le développement 
en séries et asymptotique
de la fonction <span style="font-weight:bold">sinus intégral</span><a id="hevea_default343"></a><a id="hevea_default344"></a> (on remplace exponentielle par sinus dans
la définition de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>) et l’égalité (dont un schéma de preuve est aussi
donné plus bas)
<a id="eqref_58"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mfrac><mi>&pi;</mi><mn>2</mn></mfrac><mspace width="2em"/><mo stretchy="false">(</mo><mn>58</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 \int_0^{+\infty} \frac{\sin(t)}{t} \ dt = \frac{\pi}{2}
\qquad (58) </annotation></semantics></math></p><p><span style="font-weight:bold">Calcul de </span><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math><span style="font-weight:bold"> (et preuve de (</span><a href="#eqref_58">58</a><span style="font-weight:bold">))</span>:<br>
Pour cela on effectue une intégration par parties, cette fois en intégrant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>1/t</annotation></semantics></math>
et en dérivant l’exponentielle (moins 1 dans la première intégrale).
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>C</mi></mtd> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mo stretchy="false">(</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mfrac><mn>1</mn><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">[</mo><mo stretchy="false">(</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msubsup><mo stretchy="false">]</mo> <mn>0</mn> <mn>1</mn></msubsup><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><mo stretchy="false">[</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msubsup><mo stretchy="false">]</mo> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 C&amp;=&amp;\int_0^{1}(e^{&#x2d;t}&#x2d;1)\frac{1}{t} \ dt + \int_1^{+\infty} e^{&#x2d;t} \frac{1}{t} \ dt\\
&amp;=&amp;[(e^{&#x2d;t}&#x2d;1)\ln(t)]_0^1 +\int_0^1 \ln(t) e^{&#x2d;t} \ dt + [e^{&#x2d;t} \ln(t)]_1^{+\infty}
+\int_1^{+\infty} \ln(t) e^{&#x2d;t} \ dt \\
&amp;=&amp; \int_0^{+\infty} \ln(t) e^{&#x2d;t} \ dt
 \end{matrix} </annotation></semantics></math>
Pour calculer cette intégrale, on utilise
l’égalité (qui se démontre par récurrence en faisant une 
intégration par parties) :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>n</mi><mo>!</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>t</mi> <mi>n</mi></msup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'> n!= \int_0^{+\infty}t^n e^{&#x2d;t} \ dt  </annotation></semantics></math>
On va à nouveau intégrer par parties,
on intègre un facteur multiplicatif 1 
et on dérive l’intégrand, on simplifie, puis
on intègre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> et on dérive l’autre terme, puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>t</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>t^2/2</annotation></semantics></math>, etc. 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>C</mi></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">[</mo><mi>t</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msubsup><mo stretchy="false">]</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mi>t</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mfrac><mn>1</mn><mi>t</mi></mfrac><mo>&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mn>0</mn><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mi>t</mi><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>+</mo><mo stretchy="false">[</mo><mfrac><mrow><msup><mi>t</mi> <mn>2</mn></msup></mrow><mn>2</mn></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msubsup><mo stretchy="false">]</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><msup><mi>t</mi> <mn>2</mn></msup></mrow><mn>2</mn></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mfrac><mn>1</mn><mi>t</mi></mfrac><mo>&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mi>t</mi><mn>2</mn></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><msup><mi>t</mi> <mn>2</mn></msup></mrow><mn>2</mn></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><msup><mi>t</mi> <mn>2</mn></msup></mrow><mn>2</mn></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>&minus;</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>&minus;</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><msup><mi>t</mi> <mi>n</mi></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>&minus;</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>&minus;</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>+</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>I</mi> <mi>n</mi></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 C&amp;=&amp;[te^{&#x2d;t} \ln(t)]_0^{+\infty} &#x2d; \int_0^{+\infty} t e^{&#x2d;t}(\frac{1}{t}&#x2d;\ln(t)) \ dt \\
&amp;=&amp; 0 &#x2d; \int_0^{+\infty} e^{&#x2d;t} \ dt + \int_0^{+\infty} t e^{&#x2d;t} \ln(t) \ dt \\
&amp;=&amp; &#x2d;1 + [\frac{t^2}{2}e^{&#x2d;t} \ln(t)]_0^{+\infty} 
&#x2d; \int_0^{+\infty} \frac{t^2}{2} e^{&#x2d;t}(\frac{1}{t}&#x2d;\ln(t)) \ dt \\
&amp;=&amp; &#x2d;1 &#x2d; \int_0^{+\infty} \frac{t}{2} e^{&#x2d;t} +  \int_0^{+\infty} \frac{t^2}{2} e^{&#x2d;t} \ln(t) \ dt \\
&amp;=&amp; &#x2d;1 &#x2d; \frac{1}{2} +  \int_0^{+\infty} \frac{t^2}{2} e^{&#x2d;t} \ln(t) \ dt \\
&amp;=&amp; ...\\
&amp;=&amp; &#x2d;1 &#x2d; \frac{1}{2} &#x2d; ... &#x2d;  \frac{1}{n} + \int_0^{+\infty} \frac{t^n}{n!} e^{&#x2d;t} \ln(t) \ dt \\
&amp;=&amp; &#x2d;1 &#x2d; \frac{1}{2} &#x2d; ... &#x2d;  \frac{1}{n} + \ln(n) + I_n
 \end{matrix} </annotation></semantics></math>
où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>I</mi> <mi>n</mi></msub><mo>=</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><msup><mi>t</mi> <mi>n</mi></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mo stretchy="false">(</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'> I_n=\int_0^{+\infty} \frac{t^n}{n!} e^{&#x2d;t} (\ln(t)&#x2d;\ln(n)) \ dt  </annotation></semantics></math>
Pour déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>I</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>I_n</annotation></semantics></math> on fait le changement de variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mi>n</mi><mi>u</mi></mrow><annotation encoding='application/x-tex'>t=nu</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>I</mi> <mi>n</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><msup><mo stretchy="false">)</mo> <mi>n</mi></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>n</mi><mi>u</mi></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mi>n</mi><mspace width="mediummathspace"/><mi>d</mi><mi>u</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><msup><mi>n</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>u</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 I_n&amp;=&amp;\int_0^{+\infty} \frac{(nu)^n}{n!} e^{&#x2d;nu} \ln(u) n\ du \\
&amp;=&amp; \frac{n^{n+1}}{n!} \int_0^{+\infty} e^{n(ln(u)&#x2d;u)} \ln(u) \ du 
 \end{matrix} </annotation></semantics></math>
Or en faisant le même changement de variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mi>n</mi><mi>u</mi></mrow><annotation encoding='application/x-tex'>t=nu</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>n</mi><mo>!</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>t</mi> <mi>n</mi></msup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><msup><mi>n</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>u</mi></mrow><annotation encoding='application/x-tex'> n!= \int_0^{+\infty}t^n e^{&#x2d;t} \ dt = n^{n+1} \int_0^{+\infty} e^{n(ln(u)&#x2d;u)} \ du
 </annotation></semantics></math>
Donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>I</mi> <mi>n</mi></msub><mo>=</mo><mfrac><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>u</mi></mrow><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></msup><mspace width="mediummathspace"/><mi>d</mi><mi>u</mi></mrow></mfrac></mrow><annotation encoding='application/x-tex'> I_n= \frac{\int_0^{+\infty} e^{n(ln(u)&#x2d;u)} \ln(u) \ du}
{\int_0^{+\infty} e^{n(ln(u)&#x2d;u)} \ du}   </annotation></semantics></math>
Lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tend vers l’infini, on peut montrer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>I</mi> <mi>n</mi></msub><mo>&rightarrow;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>I_n \rightarrow 0</annotation></semantics></math>, en effet les intégrales
sont équivalentes à leur valeur sur un petit intervalle autour de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>u=1</annotation></semantics></math>, point où l’argument
de l’exponentielle est maximal, 
et comme l’intégrand du numérateur a une amplitude <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(u)</annotation></semantics></math> qui s’annule en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>u=1</annotation></semantics></math>, 
il devient négligeable devant le dénominateur. Finalement on a bien <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>C=&#x2d;\gamma</annotation></semantics></math>.</p><p>On peut remarquer qu’en faisant le même calcul que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> 
mais en remplacant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{&#x2d;t}</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&alpha;</mi><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{&#x2d;\alpha t}</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Re;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\Re(\alpha)&amp;gt;0</annotation></semantics></math>, donne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>lim</mi><msub><mi>I</mi> <mi>n</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\lim I_n=&#x2d;\ln(\alpha)</annotation></semantics></math> (car le point critique où la dérivée
de la phase s’annule est alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>1/\alpha</annotation></semantics></math>). Ceci peut aussi se vérifier
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> réel en faisant le changement de variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mi>t</mi><mo>=</mo><mi>u</mi></mrow><annotation encoding='application/x-tex'>\alpha t=u</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mo stretchy="false">(</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&alpha;</mi><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&alpha;</mi><mi>t</mi></mrow></msup><mfrac><mn>1</mn><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&gamma;</mi><mo>&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \int_0^{1}(e^{&#x2d;\alpha t}&#x2d;1)\frac{1}{t} \ dt + \int_1^{+\infty} e^{&#x2d;\alpha t} \frac{1}{t} \ dt 
= &#x2d;\gamma &#x2d;\ln(\alpha)  </annotation></semantics></math>
En faisant tendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>i</mi></mrow><annotation encoding='application/x-tex'>&#x2d;i</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;\ln(\alpha)</annotation></semantics></math> 
tend vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi><mfrac><mi>&pi;</mi><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'>\ln(i)=i\frac{\pi}{2}</annotation></semantics></math> et on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mo stretchy="false">(</mo><msup><mi>e</mi> <mrow><mi>i</mi><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mfrac><mn>1</mn><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msubsup><msup><mi>e</mi> <mrow><mi>i</mi><mi>t</mi></mrow></msup><mfrac><mn>1</mn><mi>t</mi></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&gamma;</mi><mo>+</mo><mi>i</mi><mfrac><mi>&pi;</mi><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> \int_0^{1}(e^{it}&#x2d;1)\frac{1}{t} \ dt + \int_1^{+\infty} e^{i t} \frac{1}{t} \ dt 
= &#x2d;\gamma + i \frac{\pi}{2}  </annotation></semantics></math>
dont la partie imaginaire nous donne (<a href="#eqref_58">58</a>), et la
partie réelle une autre identité sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&gamma;</mi></mrow><annotation encoding='application/x-tex'>\gamma</annotation></semantics></math> faisant intervenir
la fonction cosinus intégral.</p>
<!--TOC section id="sec289" Séries formelles.-->
<h2 id="sec289" class="section">24.8  Séries formelles.</h2><!--SEC END --><p><a id="hevea_default345"></a> <a id="hevea_default346"></a>
On peut aussi s’intéresser aux séries d’un point de vue purement
algébrique en mettant de coté tous
les aspects liés à la convergence. On parle alors de série
formelle. Si le corps de base est de caractéristique quelconque
on peut faire les opérations arithmétiques usuelles sur les
séries formelles <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>&geq;</mo><mn>0</mn></mrow></msub><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>\sum_{k\geq 0} a_k x^k</annotation></semantics></math>. Si la caractéristique
est nulle, on peut également calculer les fonctions usuelles.
Dans Xcas, on déclare la variable de série formelle par la commande
<code>series</code> avec en argument le caractère désignant la variable, 
par exemple <code>series("h")</code> utilisera <code>h</code> comme variable,
<code>series("h",8)</code> utilisera <code>h</code> comme variable
et fixera l’ordre par défaut pour les développements à 8. Si la
variable <code>O</code> n’est pas affectée, elle sera définie pour donner
l’ordre de la série. Ainsi <code>1+h+O(h^7)</code> sera une série
dont on connait les termes jusqu’à l’ordre 6 inclus.
Les opérations usuelles sont implémentées dans Xcas
</p><ul class="itemize"><li class="li-itemize">
addition <code>+</code>, opposé <code>-</code>, multiplication <code>*</code>
</li><li class="li-itemize">inverse <code>inv</code> 
si le coefficient de puissance 0 n’est pas inversible, 
Xcas renvoie une série de Laurent
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>&geq;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>N</mi></mrow></msub><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>\sum_{k\geq &#x2d;N} a_k x^k</annotation></semantics></math>.
</li><li class="li-itemize">composition de deux séries <code>@</code>
</li><li class="li-itemize">inverse pour la composition <code>revert</code>
</li><li class="li-itemize">les conversions se font avec la commande <code>convert</code>, par
exemple <code>a:=convert(sin(x),series,x=0,8)</code>,
<code>b:=convert(a,polynom)</code>.
</li></ul><p>
On peut aussi appliquer les fonctions usuelles en caractéristique 0, par
exemple
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">restart;series("h"); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a:=ln(1+h+O(h^8)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">exp(a); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

Pour travailler avec un autre corps de base, il suffit de donner des
coefficients dans ce corps. Si la caractéristique du corps est assez
grande, les fonctions usuelles sont aussi applicables.
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">GF(11,3); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a:=ln(1+g*h+O(h^6)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">exp(a); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>Les opérations sur les séries sont implémentées sans optimisation
particulière, leur utilisation principale dans Xcas étant le
calcul de développement de Taylor ou asymptotique sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Q}</annotation></semantics></math>.</p>
<!--TOC chapter id="sec290" La transformée de Fourier discrète.-->
</html>
