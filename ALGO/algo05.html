<!DOCTYPE html>
<html >
<head>
<h1 id="sec45" class="chapter">Chapitre 5  Le PGCD de polynômes.</h1><!--SEC END --><p> <a id="sec:pgcd"></a> <a id="hevea_default49"></a>
Lorsqu’on travaille avec polynômes en une variable
à coefficients sur un corps fini, 
l’algorithme d’Euclide est un algorithme efficace, pourvu que les
degrés ne soient pas trop grands (dans ce cas il faut utiliser
des algorithmes de type diviser pour régner, ici par exemple
l’algorithme halfgcd<a id="hevea_default50"></a> qui consiste en gros à calculer
d’abord l’identité de Bézout sous forme matricielle pour
les polynômes tronqués en enlevant les degrés les plus bas).
Mais l’algorithme d’Euclide est
inefficace pour calculer le pgcd de deux polynômes à coefficients entiers
ou à plusieurs variables. On
va présenter ici les algorithmes utilisés habituellement par les systèmes de
calcul formel: sous-résultant (PRS), modulaire (GCDMOD), <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-adique (EEZGD) et
heuristique (GCDHEU). Le premier est une adaptation de l’algorithme d’Euclide
et s’adapte à des coefficients assez génériques. Les trois autres ont en
commun d’évaluer une ou plusieurs variables du polynôme (dans ce dernier cas
il est nécessaire de bien distinguer le cas de polynômes à plusieurs
variables) et de reconstruire le pgcd par des techniques distinctes, la
plupart du temps ces algorithmes fonctionnent seulement si les coefficients
sont entiers.</p><p>Soit donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'> P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> deux polynômes à coefficients dans un corps. Le
pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> n’est défini qu’à une constante près. Mais lorsque les
coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> sont dans un anneau euclidien comme par exemple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> ou
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[ i ]</annotation></semantics></math>, on appellera pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> tel
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">/</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'>P / D</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">/</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'>Q / D</annotation></semantics></math> soient encore à coefficients dans l’anneau, et que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>
soit optimal, c’est-à-dire que si un multiple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&mu;</mi><mi>D</mi></mrow><annotation encoding='application/x-tex'>\mu D</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> vérifie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">/</mo><mi>&mu;</mi><mi>D</mi></mrow><annotation encoding='application/x-tex'>P / \mu
D</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">/</mo><mi>&mu;</mi><mi>D</mi></mrow><annotation encoding='application/x-tex'>Q / \mu D</annotation></semantics></math> sont à coefficients dans l’anneau, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&mu;</mi></mrow><annotation encoding='application/x-tex'>\mu</annotation></semantics></math> est
inversible. </p><p>La première étape d’un algorithme de calcul de pgcd consiste donc
à diviser par son contenu (pgcd des coefficients entiers) chaque polynôme.</p><p><span style="font-weight:bold">Exemple</span>: <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mn>4</mn><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>P = 4 X^2 &#x2d; 4</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><mn>6</mn><msup><mi>X</mi> <mn>2</mn></msup><mo>+</mo><mn>12</mn><mi>X</mi><mo>+</mo><mn>6</mn></mrow><annotation encoding='application/x-tex'>Q = 6 X^2 + 12 X + 6</annotation></semantics></math>. Le polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X + 1</annotation></semantics></math> est un pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> puisqu’il est de degré maximal divisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> mais le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>2 ( X + 1 )</annotation></semantics></math>. Remarquons qu’avec notre
définition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d; 2 ( X + 1 )</annotation></semantics></math> convient aussi. Par convention on appelera
pgcd dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math> le
polynôme ayant un coefficient dominant positif.</p><p><span style="font-weight:bold">Définition</span>: On appelle <span style="font-weight:bold">contenu</span><a id="hevea_default51"></a> <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c ( P )</annotation></semantics></math> d’un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> le
pgcd des coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. On définit alors la 
<span style="font-weight:bold">partie primitive</span><a id="hevea_default52"></a> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>:
pp<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">/</mo><mi>c</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>( P ) = P / c ( P )</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>c(P)=1</annotation></semantics></math>, on dit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est primitif.</p><p><span style="font-weight:bold">Proposition </span>: Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> sont primitifs alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding='application/x-tex'>AB</annotation></semantics></math> est
primitif.<br>
Sinon, on prend un facteur premier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> du contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding='application/x-tex'>AB</annotation></semantics></math>, 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>B</mi><mo>=</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>AB=0 \pmod p</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>A=0</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>B=0</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>, absurde.</p><p><span style="font-weight:bold">Proposition </span>: le contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding='application/x-tex'>AB</annotation></semantics></math> est le produit des contenus
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>.<br>
En effet le produit des contenus de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> divise le contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>B</mi></mrow><annotation encoding='application/x-tex'>AB</annotation></semantics></math>,
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>/contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est primitif, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>/contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> est primitif
donc le produit l’est,</p><p><span style="font-weight:bold">Proposition </span>: Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> sont primitifs et si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Q}[X]</annotation></semantics></math> alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo stretchy="false">/</mo><mi>B</mi><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>A/B \in \mathbb{Z}[X]</annotation></semantics></math>.</p><p><span style="font-weight:bold">Preuve </span>: Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><mi>A</mi><mo stretchy="false">/</mo><mi>B</mi><mo>&Element;</mo><mi>&Qopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>Q=A/B \in \mathbb{Q}[X]</annotation></semantics></math>. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mo>&Element;</mo><mi>&Nopf;</mi></mrow><annotation encoding='application/x-tex'>q \in \mathbb{N} </annotation></semantics></math> le PPCM des
dénominateurs des coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> et notons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>q</mi><mi>Q</mi><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>P=qQ \in \mathbb{Z}[X]</annotation></semantics></math>.
On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi><mi>Q</mi></mrow><annotation encoding='application/x-tex'>A=BQ</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mi>A</mi><mo>=</mo><mi>B</mi><mi>P</mi></mrow><annotation encoding='application/x-tex'>qA=BP</annotation></semantics></math> donc le contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mi>A</mi></mrow><annotation encoding='application/x-tex'>qA</annotation></semantics></math> est le produit 
du contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> par celui de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, donc le contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>q</mi><mi>Q</mi></mrow><annotation encoding='application/x-tex'>P=qQ</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math>,
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>Q \in \mathbb{Z}[X]</annotation></semantics></math>.</p><p>Donc le PGCD de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>, polynômes primitifs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math> est
obtenu en prenant un PGCD de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Q}[X]</annotation></semantics></math>, en multipliant
par le PPCM des dénominateurs et en rendant le polynôme obtenu
primitif (on change le signe du résultat si nécessaire pour avoir
un coefficient dominant positif).</p><p>On en déduit que :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>D</mi><mo>=</mo><mtext>pgcd</mtext><mo stretchy="false">(</mo><mi>P</mi><mo>,</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>pgcd</mtext><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>,</mo><mi>c</mi><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext>pgcd</mtext><mo stretchy="false">(</mo><mtext>pp</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>,</mo><mtext>pp</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> D = \mbox{pgcd} ( P, Q ) = \mbox{pgcd} ( c ( P ), c ( Q )) \mbox{pgcd} (
   \mbox{pp} ( P ), \mbox{pp} ( Q ))  </annotation></semantics></math></p>
<!--TOC section id="sec46" Le sous-résultant.-->
<h2 id="sec46" class="section">5.1  Le sous-résultant.</h2><!--SEC END --><p><a id="hevea_default53"></a></p><p>La première idée qui vient à l’esprit pour améliorer l’efficacité de
l’algorithme d’Euclide consiste à éviter les fractions qui sont créées par les
divisions euclidiennes. On utilise à cet effet la pseudo-division: au lieu de
prendre le reste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> de la division euclidienne du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, on
prend le reste de la division de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><msup><mi>q</mi> <mrow><mi>&delta;</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>P q^{\delta + 1}</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> désigne le
coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\delta</annotation></semantics></math> la différence entre le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.</p><p><span style="font-weight:bold">Exercice:</span> En utilisant votre système de calcul formel préféré,
calculez les restes intermédiaires générés dans l’algorithme d’Euclide
lorsqu’on utilise la pseudo-division par exemple pour les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>7</mn></msup><mo>&minus;</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>6</mn></msup></mrow><annotation encoding='application/x-tex'>P ( x ) =
( x + 1 )^7 &#x2d; ( x &#x2d; 1 )^6</annotation></semantics></math> et sa dérivée.</p><p><span style="font-weight:bold">Une solution avec giac/xcas</span>:

</p><pre class="verbatim">pgcd(a,b,prs):={ 
 local P,p,Q,q,R,g,h,d,res;
 res:=NULL;
 // convertit a et b en polynomes listes 
 // et extrait la partie primitive   
 P:=symb2poly(a);
 p:=lgcd(P); // pgcd des elements de la liste
 P:=P/p; 
 Q:=symb2poly(b);
 q:=lgcd(Q);
 Q:=Q/q; 
 if (size(P)&lt;size(Q)){ // echange P et Q
  R:=P; P:=Q; Q:=R; 
 } 
 // calcul du contenu du pgcd
 p:=gcd(p,q);
 g:=1;
 h:=1;
 while (size(Q)!=1){
  q:=Q[0]; // coefficient dominant
  d:=size(P)-size(Q);
  R:=rem(q^(d+1)*P,Q);
  if (size(R)==0) return(p*poly12symb(Q/lgcd(Q),x));
  P:=Q;
  Q:=R;
  if (prs==1) Q:=Q/content(Q);
  if (prs==2) Q:=R/(g*h^d);
  res:=res,Q;
  if (prs==2) g:=q; h:=q^d/h^(d-1);
 } 
 return(p,res);
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>



<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">P:=(x+1)^7-(x-1)^6; pgcd(P,P',0)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

On s’aperçoit que les coefficients croissent de manière exponentielle
(comparer avec ce qui se passe en mettant 1 comme dernier argument). La
deuxième idée qui vient naturellement est alors à chaque étape de rendre le
reste primitif, donc de diviser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> par le pgcd de ces coefficients. Cela
donne un algorithme plus efficace, mais encore assez peu efficace car à chaque
étape on doit calculer le pgcd de tous les coefficients, on peut imaginer le
temps que cela prendra en dimension 1 et à fortiori en dimension supérieure.
L’idéal serait de connaitre à l’avance une quantité suffisamment grande qui
divise tous les coefficients du reste.</p><p>C’est ici qu’intervient l’algorithme du sous-résultant : après chaque
pseudo-division euclidienne, on exhibe un coefficient "magique" qui divise les
coefficients du reste (pour tester mettre le dernier argument de pgcd
à 2). 
Ce coefficient n’est pas le pgcd mais il est
suffisamment grand pour qu’on évite la croissance exponentielle des
coefficients.</p><p><span style="font-weight:bold">Algorithme du sous-résultant</span></p><p>Arguments: 2 polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> primitifs. Valeur de retour: le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.</p><p>Pour calculer le coefficient "magique" on utilise 2 variables auxiliaires <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> initialisées a 1.</p><p>Boucle à effectuer tant que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est non nul:
</p><ul class="itemize"><li class="li-itemize">
on note <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi><mo>=</mo></mrow><annotation encoding='application/x-tex'>\delta =</annotation></semantics></math>degre(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>)-degre(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>) et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> le coefficient dominant
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math></li><li class="li-itemize">on effectue la division euclidienne (sans fraction) de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>q</mi> <mrow><mi>&delta;</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>P</mi></mrow><annotation encoding='application/x-tex'>q^{\delta + 1}
  P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> le reste</li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> est constant, on sort de l’algorithme en renvoyant 1 comme pgcd</li><li class="li-itemize">on recopie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>g</mi><msup><mi>h</mi> <mi>&delta;</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>R / ( g h^{\delta} )</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math></li><li class="li-itemize">on recopie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mrow><mn>1</mn><mo>&minus;</mo><mi>&delta;</mi></mrow></msup><msup><mi>q</mi> <mi>&delta;</mi></msup></mrow><annotation encoding='application/x-tex'>h^{1 &#x2d; \delta} q^{\delta}</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math>.
</li></ul><p>
Si on sort normalement de la boucle, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est nul, on renvoie donc la partie
primitive de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> qui est le pgcd cherché.</p><p>Pour tester l’algorithme avec <span style="font-family:monospace">xcas</span>, il suffit de décommenter les
deux lignes <span style="font-family:monospace">Q:=R/(g*h^d);</span> et <span style="font-family:monospace">g:=q; h:=q^d/h
(d-1);</span> ci-dessus.</p><p>La preuve de l’algorithme est un peu longue et par ailleurs bien expliquée
dans le 2ème tome de Knuth (The Art of Computer Programming, Semi-numerical
Algorithms), on y renvoie donc le lecteur intéressé. L’idée générale
(et l’origine du nom de l’algorithme) 
est de considérer la matrice de Sylvester des polynômes de
départ <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> (celle dont le déterminant est appelé résultant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>) et de traduire les pseudo-divisions qui permettent de calculer les restes
successifs du sous-résultant en opération de ligne sur ces matrices. On
démontre alors que les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> divisés par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><msup><mi>h</mi> <mi>&delta;</mi></msup></mrow><annotation encoding='application/x-tex'>g h^{\delta}</annotation></semantics></math> peuvent
être interprétés comme des déterminants de sous-matrices de la matrice de
Sylvester après réduction et c’est cela qui permet de conclure qu’ils sont
entiers.</p><p>Par exemple, supposons que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>R</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P=R_0</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q=R_1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>R_2</annotation></semantics></math>... diminuent de 1 en degré
à chaque division 
(c’est le cas générique dans le déroulement de l’algorithme
d’Euclide). Dans ce cas, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\delta=1</annotation></semantics></math>, il s’agit par exemple
de montrer que le reste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>R_3</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q=R_1</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>R_2</annotation></semantics></math> est divisible par le
carré du coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q=R_1</annotation></semantics></math>.
Voyons comment on obtient les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>R_3</annotation></semantics></math>
à partir de la matrice de Sylvester de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. 
Prenons la sous-matrice constituée des 2 premières lignes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
et des 3 premières lignes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> et réduisons-la sous forme
échelonnée sans introduire de dénominateur. 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center"><mtr><mtd><msub><mi>p</mi> <mi>n</mi></msub></mtd> <mtd><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>3</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>p</mi> <mi>n</mi></msub></mtd> <mtd><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>3</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>4</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>3</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>
\left( \begin{array}{ccccc}
p_n &amp; p_{n&#x2d;1} &amp; p_{n&#x2d;2} &amp; p_{n&#x2d;3} &amp; ... \\
0 &amp; p_n &amp; p_{n&#x2d;1} &amp; p_{n&#x2d;2} &amp;  ... \\
q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp; q_{n&#x2d;3} &amp; q_{n&#x2d;4} &amp; ... \\
0 &amp; q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp; q_{n&#x2d;3} &amp; ... \\
0 &amp; 0 &amp; q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp;  ...  
\end{array} 
\right)
 </annotation></semantics></math>
On effectue <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>1</mn></msub><mo>&leftarrow;</mo><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>L</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>p</mi> <mi>n</mi></msub><msub><mi>L</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>L_1 \leftarrow q_{n&#x2d;1} L_1 &#x2d; p_n L_3</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>2</mn></msub><mo>&leftarrow;</mo><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>L</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>p</mi> <mi>n</mi></msub><msub><mi>L</mi> <mn>4</mn></msub></mrow><annotation encoding='application/x-tex'>L_2 \leftarrow q_{n&#x2d;1} L_2 &#x2d; p_n L_4</annotation></semantics></math>, ce qui correspond à
l’élimination du terme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> du quotient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>p</mi> <mi>n</mi></msub><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>p</mi> <mi>n</mi></msub><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>3</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>4</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>3</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>
\left( \begin{array}{ccccc}
0 &amp; q_{n&#x2d;1} p_{n&#x2d;1} &#x2d; p_n q_{n&#x2d;2}  &amp; ... &amp; ... &amp; ... \\
0 &amp; 0 &amp; q_{n&#x2d;1} p_{n&#x2d;1} &#x2d; p_n q_{n&#x2d;2} &amp; ... &amp;  ... \\
q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp; q_{n&#x2d;3} &amp; q_{n&#x2d;4} &amp; ... \\
0 &amp; q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp; q_{n&#x2d;3} &amp; ... \\
0 &amp; 0 &amp; q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp;  ...  
\end{array} 
\right)
 </annotation></semantics></math>
on effectue ensuite 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>L</mi> <mn>1</mn></msub></mtd> <mtd><mo>&leftarrow;</mo></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>L</mi> <mn>1</mn></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>p</mi> <mi>n</mi></msub><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><msub><mi>L</mi> <mn>4</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>L</mi> <mn>2</mn></msub></mtd> <mtd><mo>&leftarrow;</mo></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>L</mi> <mn>2</mn></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>p</mi> <mi>n</mi></msub><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><msub><mi>L</mi> <mn>5</mn></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
L_1 &amp; \leftarrow &amp;q_{n&#x2d;1} L_1 &#x2d; (q_{n&#x2d;1} p_{n&#x2d;1} &#x2d; p_n q_{n&#x2d;2})  L_4 \\
L_2 &amp; \leftarrow &amp; q_{n&#x2d;1} L_2 &#x2d; (q_{n&#x2d;1} p_{n&#x2d;1} &#x2d; p_n q_{n&#x2d;2})  L_5
 \end{matrix} </annotation></semantics></math> 
ce qui correspond à l’élimination du terme constant du quotient
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><msub><mi>r</mi> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><msub><mi>r</mi> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>3</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>4</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>3</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>
\left( \begin{array}{ccccc}
0 &amp; 0 &amp; r_{2,n&#x2d;2} &amp; ... &amp; ... \\
0 &amp; 0 &amp; 0 &amp; r_{2,n&#x2d;2} &amp;  ... \\
q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp; q_{n&#x2d;3} &amp; q_{n&#x2d;4} &amp; ... \\
0 &amp; q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp; q_{n&#x2d;3} &amp; ... \\
0 &amp; 0 &amp; q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp;  ...  
\end{array} 
\right)
 </annotation></semantics></math>
si on enlève les lignes 3 et 4, et les colonnes 1 et 2,
on obtient (après échanges
de lignes) une sous-matrice de la matrice de Sylvester de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>R_2</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><msub><mi>r</mi> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>r</mi> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>
\left( \begin{array}{ccc}
 q_{n&#x2d;1} &amp; q_{n&#x2d;2} &amp;  ... \\
 r_{2,n&#x2d;2} &amp; ... &amp; ... \\
 0 &amp; r_{2,n&#x2d;2} &amp;  ... 
\end{array} 
\right)
 </annotation></semantics></math>
On recommence les opérations de réduction de cette sous-matrice
correspondant à la division euclidienne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>R_2</annotation></semantics></math>, on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><msub><mi>r</mi> <mrow><mn>3</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>3</mn></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>r</mi> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>r</mi> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>
\left( \begin{array}{ccc}
 0 &amp; 0 &amp; r_{3,n&#x2d;3} \\
 r_{2,n&#x2d;2} &amp; ... &amp; ... \\
 0 &amp; r_{2,n&#x2d;2} &amp;  ... 
\end{array} 
\right)
 </annotation></semantics></math>
puis après suppression des colonnes 1 et 2 et des lignes 2 et 3
la ligne des coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>R_3</annotation></semantics></math>.</p><p>Supposons qu’on se limite dès le début de la réduction à ne
garder que les colonnes 1 à 4 et une 5-ième colonne parmi
les suivantes, on obtient à la fin de la réduction
une matrice 1,1 qui contient
un des coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>R_3</annotation></semantics></math> (selon le choix de la 5-ième colonne).
Donc ce coefficient est égal au déterminant de la matrice 1,1
qui est égal, au signe près, au déterminant de la matrice 3,3
dont il est issu par notre réduction (en effet, dans la 2ième
partie de la réduction,
on a multiplié deux fois <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>L_1</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{2,n&#x2d;2}</annotation></semantics></math>, mais on doit ensuite diviser 
le déterminant par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>r</mi> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow> <mn>2</mn></msubsup></mrow><annotation encoding='application/x-tex'>r_{2,n&#x2d;2}^2</annotation></semantics></math> pour éliminer les colonnes 1 et 2).
Quant au déterminant de la matrice 3,3, il se déduit du
déterminant de la matrice 5,5 par multiplication par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow> <mn>4</mn></msubsup></mrow><annotation encoding='application/x-tex'>q_{n&#x2d;1}^4</annotation></semantics></math>
(2 lignes ont été multipliées 2 fois par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>q_{n&#x2d;1}</annotation></semantics></math>) et division
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mrow><annotation encoding='application/x-tex'>q_{n&#x2d;1}^2</annotation></semantics></math> (élimination des colonnes 1 et 2). Au final,
tout coefficient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>R_3</annotation></semantics></math> est égal au produit d’un déterminant
5,5 extrait de la matrice de Sylvester de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow> <mn>2</mn></msubsup></mrow><annotation encoding='application/x-tex'>q_{n&#x2d;1}^2</annotation></semantics></math>,
qui est justement le coefficient “magique” par lequel on divise le reste
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>1</mn></msub><mo>=</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>R_1=Q</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>R_2</annotation></semantics></math> lors de l’algorithme du sous-résultant.</p>
<!--TOC section id="sec47" Le pgcd en une variable.-->
<h2 id="sec47" class="section">5.2  Le pgcd en une variable.</h2><!--SEC END -->
<!--TOC subsection id="sec48" Le pgcd heuristique.-->
<h3 id="sec48" class="subsection">5.2.1  Le pgcd heuristique.</h3><!--SEC END --><p><a id="hevea_default54"></a></p><p>On suppose ici que les coefficients sont entiers ou entiers de Gauss.
<span style="font-weight:bold">On peut donc se ramener au cas où les polynômes sont primitifs.</span></p><p>L’idée consiste à évaluer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> en un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> et à extraire des
informations du pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> des entiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( z )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( z )</annotation></semantics></math>. Il faut donc un
moyen de remonter de l’entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> à un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi></mrow><annotation encoding='application/x-tex'>G ( z ) = g</annotation></semantics></math>. La
méthode consiste à écrire en base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> l’entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>, avec une particularité
dans les divisions euclidiennes successives on utilise le reste symétrique
(compris entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>z</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>&#x2d; z / 2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>z / 2</annotation></semantics></math>). Cette écriture donne les coefficients
d’un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> unique. On extrait ensuite la partie primitive de ce
polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>. Lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> est assez grand par rapport aux coefficients des
polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>pp</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{pp} ( G )</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, on va montrer
que le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>=</mo><mtext>pp</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D = \mbox{pp} ( G )</annotation></semantics></math>.</p><p>On remarque tout d’abord que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo>:</mo><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>d : = D ( z )</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>. En effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> divise
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> donc pour tout entier (ou entier de Gauss) <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D ( z )</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P
( z )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( z )</annotation></semantics></math>. Il existe donc une constante <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> telle que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>g</mi><mo>=</mo><mi>a</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'> g = a d  </annotation></semantics></math>
On a aussi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>pp</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{pp} ( G )</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>. Il existe donc un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> tel
que :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>D</mi><mo>=</mo><mtext>pp</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mi>C</mi></mrow><annotation encoding='application/x-tex'> D = \mbox{pp} ( G ) C  </annotation></semantics></math>
Nous devons prouver que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> est un polynôme constant. On suppose dans la suite
que ce n’est pas le cas. Evaluons l’égalité précédente au point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>, on
obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>d</mi><mo>=</mo><mfrac><mi>g</mi><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></mfrac><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> d = \frac{g}{c ( G )} C ( z )  </annotation></semantics></math>
Finalement
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>1</mn><mo>=</mo><mfrac><mi>a</mi><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></mfrac><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 1 = \frac{a}{c ( G )} C ( z )  </annotation></semantics></math>
La procédure de construction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> nous donne une majoration de ces
coefficients par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>| z | / 2</annotation></semantics></math>, donc de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c ( G )</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>| z | / 2</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>C ( z
)</annotation></semantics></math> divise un entier de module plus petit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>| z | / 2</annotation></semantics></math>, donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> | C ( z ) | \leq \frac{| z |}{2}  </annotation></semantics></math>
On considère maintenant les racines complexes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>z</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>z_1, \ldots ., z_n</annotation></semantics></math> du polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> (il en existe au moins une puisqu’on a supposé <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> non constant). On a:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>c</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>z</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>&hellip;</mi><mo>.</mo><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>z</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> C ( X ) = c_n ( X &#x2d; z_1 ) \ldots . ( X &#x2d; z_n )  </annotation></semantics></math>
Donc, comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>c_n</annotation></semantics></math> est un entier (ou entier de Gauss) non nul, sa norme est
supérieure ou égale à 1 et :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&geq;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo>&minus;</mo><mo stretchy="false">&vert;</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> | C ( z ) | \geq \prod^n_{j = 1} ( | z | &#x2d; | z_j | )  </annotation></semantics></math>
Il nous reste à majorer les racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> pour minorer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>| C ( z ) |</annotation></semantics></math>. Comme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> il divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> donc les racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> sont des racines
communes à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. On va appliquer le:</p><div class="theorem"><span style="font-weight:bold">Lemme 5</span>  <em> </em><a id="lemme:majoration"></a><em>
Soit x une racine complexe d’un polynôme </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>X</mi> <mi>n</mi></msup><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P = a_n X^n + \ldots . + a_0</annotation></semantics></math><em>.</em><p><em>Alors 
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo></mrow></mfrac><mo>+</mo><mn>1</mn><mo>,</mo><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mo>=</mo><munder><mi>max</mi> <mrow><mn>0</mn><mo>&leq;</mo><mi>i</mi><mo>&leq;</mo><mi>n</mi></mrow></munder><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>i</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> | x | &amp;lt; \frac{| P |}{| a_n |} + 1, | P | = \max_{0 \leq i
     \leq n} ( | a_i | )  </annotation></semantics></math><em>
</em></p></div><p>Application du lemme à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>C(X)</annotation></semantics></math> : on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">&vert;</mo><msub><mi>c</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>1/|c_n|\leq 1</annotation></semantics></math>
donc si on a choisi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo>&geq;</mo><mn>2</mn><mi>min</mi><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mo>,</mo><mo stretchy="false">&vert;</mo><mi>Q</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>| z | \geq 2 \min ( | P |, | Q | ) + 2</annotation></semantics></math>,
alors pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>| z_j | &amp;lt; | z | / 2</annotation></semantics></math> donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mi>&gt;</mi><msup><mrow><mo>(</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo></mrow><mn>2</mn></mfrac><mo>)</mo></mrow> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'> | C ( z ) | &amp;gt; \left( \frac{| z |}{2} \right)^n  </annotation></semantics></math>
qui contredit notre majoration de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>| C ( z ) |</annotation></semantics></math>.</p><div class="theorem"><span style="font-weight:bold">Théorème 6</span>  <em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> et Q deux polynômes à coefficients entiers. On
choisit un entier z tel que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo>&geq;</mo><mn>2</mn><mi>min</mi><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mo>,</mo><mo stretchy="false">&vert;</mo><mi>Q</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>| z | \geq 2 \min ( | P |, | Q | ) + 2</annotation></semantics></math><em>,
si la partie primitive du polynôme </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math><em> reconstruit à partir du pgcd de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mtext>et</mtext></mrow><annotation encoding='application/x-tex'>P (
  z ) \mbox{et}</annotation></semantics></math><em>Q(z) par écriture en base </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math><em> (avec comme reste euclidien le
reste symétrique) divise </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math><em> alors c’est le pgcd de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math><em>.
</em></div><p>Pour finir la démonstration du théorème, il nous faut encore montrer le lemme.
On a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>n</mi></msup><mo>=</mo><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msup><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'> &#x2d; a_n x^n = a_{n &#x2d; 1} x^{n &#x2d; 1} + \ldots . + a_0  </annotation></semantics></math>
Donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>x</mi><msup><mo stretchy="false">&vert;</mo> <mi>n</mi></msup><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><mo stretchy="false">&vert;</mo><mi>x</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><msup><mo stretchy="false">&vert;</mo> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&minus;</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding='application/x-tex'> | a_n | | x |^n \leq | P | ( 1 + \ldots . + | x |^{n &#x2d; 1} ) = | P |
   \frac{| x |^n &#x2d; 1}{| x | &#x2d; 1}  </annotation></semantics></math>
Ici on peut supposer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&geq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>| x | \geq 1</annotation></semantics></math>, sinon le lemme est démontré,
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>| x | &#x2d; 1</annotation></semantics></math> est positif et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><msup><mo stretchy="false">&vert;</mo> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><msup><mo stretchy="false">&vert;</mo> <mi>n</mi></msup></mrow></mfrac><mo>&Rightarrow;</mo><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&minus;</mo><mn>1</mn><mi>&lt;</mi><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> | a_n | ( | x | &#x2d; 1 ) \leq | P | \frac{| x |^n &#x2d; 1}{| x |^n}
   \Rightarrow | x | &#x2d; 1 &amp;lt; \frac{| P |}{| a_n |}  </annotation></semantics></math>
Remarques
</p><ul class="itemize"><li class="li-itemize">
Le théorème publié par Char, Geddes et Gonnet 
porte sur des coefficients entiers et
c’est comme cela qu’il est utilisé par les systèmes de calcul formel (en
commençant historiquement par Maple). Peu de systèmes l’utilisent pour les
polynômes à coefficients entiers de Gauss. On peut d’ailleurs généraliser le
théorème à d’autres types de coefficients, à condition d’avoir un anneau
euclidien plongé dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{C}</annotation></semantics></math> avec une minoration sur la valeur absolue
des élements non nuls de l’anneau.</li><li class="li-itemize">Nous n’avons jusqu’à présent aucune certitude qu’il existe des entiers
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> tels que la partie primitive de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. Nous allons
montrer en utilisant l’identité de Bézout que pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> assez grand c’est
toujours le cas. Plus précisément, on sait qu’il existe deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math> tels que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mi>U</mi><mo>+</mo><mi>Q</mi><mi>V</mi><mo>=</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'> P U + Q V = D  </annotation></semantics></math>
Attention toutefois, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math> sont à coefficients rationnels, pour avoir
des coefficients entiers, on doit multiplier par une constante entière
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>, donc en évaluant en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> on obtient l’existence d’une égalité à
coefficients entiers
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mi>u</mi><mo>+</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mi>v</mi><mo>=</mo><mi>&alpha;</mi><mi>D</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> P ( z ) u + Q ( z ) v = \alpha D ( z )  </annotation></semantics></math><p>Donc le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( z )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( z )</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mi>D</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>&alpha;</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>\alpha D ( z ) = \alpha
  d</annotation></semantics></math>. Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> est un multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math>, on en déduit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>=</mo><mi>&beta;</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>g = \beta d</annotation></semantics></math>, où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\beta</annotation></semantics></math> est un diviseur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>. Si on a choisi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mi>&gt;</mi><mn>2</mn><mo stretchy="false">&vert;</mo><mi>D</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>&alpha;</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> | z | &amp;gt; 2 | D | | \alpha |  </annotation></semantics></math>
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mi>&gt;</mi><mn>2</mn><mo stretchy="false">&vert;</mo><mi>D</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>&beta;</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>| z | &amp;gt; 2 | D | | \beta |</annotation></semantics></math> donc l’écriture symétrique en base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo>=</mo><mi>&beta;</mi><mi>D</mi></mrow><annotation encoding='application/x-tex'>G = \beta D</annotation></semantics></math>. Donc la partie primitive de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>, le
pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.</p></li></ul><div class="theorem"><span style="font-weight:bold">Exemple 7</span>  <em>
Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_0 = 6 ( X^2 &#x2d; 1 )</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub><mo>=</mo><mn>4</mn><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>3</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q_0 = 4 ( X^3 &#x2d; 1 )</annotation></semantics></math><em>.</em><p><em>Le contenu de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math><em> est 6, celui de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math><em> est 4.<br>
 On a donc pgcd des contenus = 2, </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>Q</mi><mo>=</mo><msup><mi>X</mi> <mn>3</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P = X^2 &#x2d; 1, Q = X^3 &#x2d; 1</annotation></semantics></math><em>. La valeur
initiale de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math><em> est donc </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo>&ast;</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>2 \ast 1 + 2 = 4</annotation></semantics></math><em>. On trouve </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>15</mn><mo>,</mo><mi>Q</mi><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mn>63</mn></mrow><annotation encoding='application/x-tex'>P ( 4 ) = 15, Q ( 4
  ) = 63</annotation></semantics></math><em>. Le pgcd entier de 15 et 63 est 3 que nous écrivons symétriquement
en base 4 sous la forme </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>3</mn><mo>=</mo><mn>1</mn><mo>&ast;</mo><mn>4</mn><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>3 = 1 \ast 4 &#x2d; 1</annotation></semantics></math><em>, donc </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo>=</mo><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>G = X &#x2d; 1</annotation></semantics></math><em>, sa partie
primitive est </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X &#x2d; 1</annotation></semantics></math><em>. On teste si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X &#x2d; 1</annotation></semantics></math><em> divise </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math><em>, c’est le cas,
donc c’est le pgcd de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math><em> et le pgcd de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math><em> est </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>2 ( X &#x2d; 1
  )</annotation></semantics></math><em>.
</em></p></div><p><span style="font-weight:bold">Algorithme gcdheu</span><br>
En arguments deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math> à coefficients entiers ou entiers
de Gauss. Retourne le pgcd de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math> ou faux en cas d’échec.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Calculer le contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math>. Vérifier que les coefficients
sont entiers de Gauss sinon retourner faux.</li><li class="li-enumerate">Extraire la partie primitive <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math>, calculer le
pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> des contenus de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math></li><li class="li-enumerate">Déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi><mo>=</mo><mn>2</mn><mi>min</mi><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mo>,</mo><mo stretchy="false">&vert;</mo><mi>Q</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>z = 2 \min ( | P |, | Q | ) + 2</annotation></semantics></math>.</li><li class="li-enumerate">Début de boucle: initialisation du nombre d’essais à 1, test d’arrêt
sur un nombre maximal d’essais, avec changement de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> entre deux itérations
(par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi><mo>&leftarrow;</mo><mn>2</mn><mi>z</mi></mrow><annotation encoding='application/x-tex'>z \leftarrow 2 z</annotation></semantics></math>).</li><li class="li-enumerate">Calculer le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( z )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( z )</annotation></semantics></math> puis son écriture
symétrique en base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> dont on extrait la partie primitive <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>.</li><li class="li-enumerate">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mtext>ne</mtext><mtext>divise</mtext><mtext>pas</mtext></mrow><annotation encoding='application/x-tex'>G \mbox{ne} \mbox{divise} \mbox{pas}</annotation></semantics></math><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> passer à l’itération
suivante. De même pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.</li><li class="li-enumerate">Retourner <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mi>G</mi></mrow><annotation encoding='application/x-tex'>c G</annotation></semantics></math></li><li class="li-enumerate">Fin de la boucle</li><li class="li-enumerate">Retourner faux.
</li></ol><p>
On remarque au passage qu’on a calculé le quotient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> et le
quotient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> lorsque la procédure réussit. On peut donc passer à la
procédure gcdheu deux paramètres supplémentaires par référence, les deux
polynômes que l’on affectera en cas de succès, ce qui optimise la
simplification d’une fraction de 2 polynômes.</p>
<!--TOC subsection id="sec49" Le pgcd modulaire-->
<h3 id="sec49" class="subsection">5.2.2  Le pgcd modulaire</h3><!--SEC END --><p><a id="hevea_default55"></a></p><p>On part du fait que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> est le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> (ou
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z} [ i ] )</annotation></semantics></math> alors après réduction modulo un nombre premier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> qui ne
divise pas les coefficients dominants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> divise le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / n \mathbb{Z}</annotation></semantics></math> (par convention, le pgcd dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / n \mathbb{Z}</annotation></semantics></math> est normalisé pour que son coefficient dominant
vaille 1). Comme on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / n \mathbb{Z}</annotation></semantics></math>, les
coefficients des restes intermédiaires de l’algorithme d’Euclide sont bornés,
on évite ainsi la croissance exponentielle des coefficients. Il faudra ensuite
reconstruire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> à partir de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>.</p><p>On remarque d’abord que si on trouve <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo>=</mo><mn>1</mn><mo>,</mo></mrow><annotation encoding='application/x-tex'>G = 1,</annotation></semantics></math> alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> sont premiers
entre eux. En général, on peut seulement dire que le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est
supérieur ou égal au degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>. En fait, le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est égal au degré
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> lorsque les restes de l’algorithme d’Euclide (calculé en effectuant des
pseudo-divisions, cf. l’exercice 1) ont leur coefficient dominant non
divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. Donc plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est grand, plus la probabilité est grande de
trouver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> du bon degré.</p><p>Dans la suite, nous allons déterminer une borne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> à priori majorant 
les coefficients de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>. On utilisera ensuite la même méthode que dans l’algorithme modulaire de
recherche de racines évidentes: on multiplie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / n
\mathbb{Z}</annotation></semantics></math> par le pgcd dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> des coefficients dominants <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover><mo>=</mo><mtext>pgcd</mtext><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo><mi>G</mi></mrow><annotation encoding='application/x-tex'>\tilde{D} = \mbox{pgcd} ( p, q ) G</annotation></semantics></math> le résultat écrit
en représentation symétrique. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&geq;</mo><mi>b</mi><mtext>pgcd</mtext><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>n \geq b \mbox{pgcd} ( p, q )</annotation></semantics></math> et si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est du bon degré, on montre de la même manière que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>=</mo><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>D = \tilde{D}</annotation></semantics></math>. Comme 
on ne connait pas le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>, on est obligé de tester si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{D}</annotation></semantics></math> 
divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. Si c’est le cas, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{D}</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover><mo>=</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'>\tilde{D} = D</annotation></semantics></math>
puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>&geq;</mo><mtext>degre</mtext><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( \tilde{D} ) = \mbox{degre} ( G ) \geq
\mbox{degre} ( D )</annotation></semantics></math>. Sinon, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est un nombre premier malchanceux pour ce
calcul de pgcd (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>&geq;</mo><mtext>degre</mtext><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( G ) \geq \mbox{degre} ( D )</annotation></semantics></math>), il faut
essayer un autre premier.</p><p><span style="font-weight:bold">Remarque:</span> On serait tenté de dire que les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>
sont bornés par le plus grand coefficient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. C’est malheureusement faux,
par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>( X + 1 )^2</annotation></semantics></math> dont le plus grand coefficient est 2 divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>( X + 1
)^2 ( X &#x2d; 1 )</annotation></semantics></math> dont le plus grand coefficient (en valeur absolue) est 1.</p><p>Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo><msub><mi>p</mi> <mi>i</mi></msub><msup><mi>X</mi> <mi>i</mi></msup></mrow><annotation encoding='application/x-tex'>P = \sum p_i X^i</annotation></semantics></math> un polynôme à coefficients entiers. On utilise la
norme euclidienne
<a id="eqref_4"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>P</mi><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo>=</mo><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mi>i</mi></msub><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mspace width="2em"/><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>
  | P |^2 = \sum | p_i |^2
\qquad (4) </annotation></semantics></math>
On établit d’abord une majoration du produit des racines de norme supérieure à
1 de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à l’aide de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>P</mi><msup><mo stretchy="false">&vert;</mo> <mrow/></msup></mrow><annotation encoding='application/x-tex'>| P |^{}</annotation></semantics></math>. Ensuite si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> est un diviseur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, le
coefficient dominant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> divise le coefficient dominant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et 
les racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> sont aussi des racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. On pourra donc déterminer une
majoration des polynômes symétriques des racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> et donc des
coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>.</p><div class="theorem"><span style="font-weight:bold">Lemme 8</span>  <em> </em><a id="lemme:A"></a><em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>a</mi></msubsup><msub><mi>a</mi> <mi>j</mi></msub><msup><mi>X</mi> <mi>j</mi></msup></mrow><annotation encoding='application/x-tex'>A = \sum_{j = 0}^a a_j X^j</annotation></semantics></math><em> un polynôme et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>&Element;</mo><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>\alpha \in \mathbb{C}</annotation></semantics></math><em>.
Alors
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>A</mi><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mover><mi>&alpha;</mi><mo>&#x000AF;</mo></mover><mi>X</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>A</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> | ( X &#x2d; \alpha ) A | = | ( \overline{\alpha} X &#x2d; 1 ) A |  </annotation></semantics></math><em>
</em></div><p>Pour prouver le lemme <a href="#lemme%3AA">8</a>, on développe les produits de polynômes. 
On pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>a</mi> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>a_{&#x2d;1} = a_{a + 1} = 0</annotation></semantics></math> et on note <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Re;</mi></mrow><annotation encoding='application/x-tex'>\Re</annotation></semantics></math> la partie réelle.
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>A</mi><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></munderover><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>&alpha;</mi><msub><mi>a</mi> <mi>j</mi></msub><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></munderover><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo>+</mo><mo stretchy="false">&vert;</mo><mi>&alpha;</mi><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>j</mi></msub><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn><mi>&Re;</mi><mo stretchy="false">(</mo><msub><mi>a</mi> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mover><mrow><mi>&alpha;</mi><msub><mi>a</mi> <mi>j</mi></msub></mrow><mo>&#x000AF;</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> | ( X &#x2d; \alpha ) A |^2 = \sum_{j = 0}^{a + 1} | a_{j &#x2d; 1} &#x2d; \alpha
   a_j |^2 = \sum_{j = 0}^{a + 1} | a_{j &#x2d; 1} |^2 + | \alpha |^2 | a_j |^2 &#x2d; 2
   \Re ( a_{j &#x2d; 1} \overline{\alpha  a_j} )  </annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mover><mi>&alpha;</mi><mo>&#x000AF;</mo></mover><mi>X</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>A</mi><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></munderover><mo stretchy="false">&vert;</mo><mover><mi>&alpha;</mi><mo>&#x000AF;</mo></mover><msub><mi>a</mi> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>a</mi> <mi>j</mi></msub><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow></munderover><mo stretchy="false">&vert;</mo><mi>&alpha;</mi><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo>+</mo><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>j</mi></msub><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn><mi>&Re;</mi><mo stretchy="false">(</mo><mover><mi>&alpha;</mi><mo>&#x000AF;</mo></mover><msub><mi>a</mi> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mover><mrow><msub><mi>a</mi> <mi>j</mi></msub></mrow><mo>&#x000AF;</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> | (  \overline{\alpha} X &#x2d; 1 ) A |^2 = \sum_{j = 0}^{a + 1} | 
\overline{\alpha} a_{j &#x2d; 1}
   &#x2d; a_j |^2 = \sum_{j = 0}^{a + 1} | \alpha |^2 | a_{j &#x2d; 1} |^2 + | a_j |^2 &#x2d;
   2 \Re ( \overline{\alpha}  a_{j &#x2d; 1}   \overline{a_j} )  </annotation></semantics></math>
Les deux donnent bien le même résultat.</p><p>Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( X ) = p \prod ( X &#x2d; \alpha_j )</annotation></semantics></math> la factorisation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{C}</annotation></semantics></math>. On introduit le polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mover><mi>P</mi><mo stretchy="false">&tilde;</mo></mover><mo>=</mo><mi>p</mi><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo stretchy="false">/</mo><mo stretchy="false">&vert;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mo>&geq;</mo><mn>1</mn></mrow></munder><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo stretchy="false">/</mo><mo stretchy="false">&vert;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mn>1</mn></mrow></munder><mo stretchy="false">(</mo><mover><mrow><msub><mi>&alpha;</mi> <mi>j</mi></msub></mrow><mo>&#x000AF;</mo></mover><mi>X</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \tilde{P} = p \prod_{j / | \alpha_j | \geq 1} ( X &#x2d; \alpha_j )
   \prod_{j / | \alpha_j | &amp;lt; 1} (  \overline{\alpha_j} X &#x2d; 1 )  </annotation></semantics></math>
qui d’après le lemme a la même norme que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. La norme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> majore donc le
coefficient constant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>P</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{P} </annotation></semantics></math> d’où:
<a id="eqref_5"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo stretchy="false">/</mo><mo stretchy="false">&vert;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mo>&geq;</mo><mn>1</mn></mrow></munder><mo stretchy="false">&vert;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><mi>p</mi><mo stretchy="false">&vert;</mo></mrow></mfrac><mspace width="2em"/><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>
   \prod_{j / | \alpha_j | \geq 1} | \alpha_j |
  \leq \frac{| P |}{| p |}
\qquad (5) </annotation></semantics></math>
On remarque que (<a href="#eqref_5">5</a>) reste vraie si on considère les
racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&delta;</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\delta_j</annotation></semantics></math> de norme plus grande que 1 d’un diviseur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> puisque
le produit porte alors sur un sous-ensemble. On écrit maintenant l’expression
des coefficients <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>d_j</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> à l’aide des racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&delta;</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\delta_j</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>d</mi> <mrow><mi>m</mi><mo>&minus;</mo><mi>j</mi></mrow></msub><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><mi>d</mi><mo stretchy="false">&vert;</mo><mrow><mo>&vert;</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mtext>choix</mtext><mtext>de</mtext><mi>j</mi><mtext>racines</mtext><mtext>parmi</mtext><mtext>les</mtext><mi>m</mi><mtext>racines</mtext><mtext>de</mtext><mi>D</mi></mrow></munder><mspace width="1em"/><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><msub><mi>&delta;</mi> <mi>k</mi></msub><mo>&Element;</mo><mtext>racines</mtext><mtext>choisies</mtext></mrow></munder><msub><mi>&delta;</mi> <mi>k</mi></msub><mo>&vert;</mo></mrow></mrow><annotation encoding='application/x-tex'> | d_{m &#x2d; j} | = | d | \left| \sum_{\mbox{choix} \mbox{de} j \mbox{racines}
   \mbox{parmi} \mbox{les} m \mbox{racines} \mbox{de} D} \quad  \prod_{\delta_k \in
   \mbox{racines} \mbox{choisies}} \delta_k \right|  </annotation></semantics></math>
Pour majorer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>d</mi> <mrow><mi>m</mi><mo>&minus;</mo><mi>j</mi></mrow></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>| d_{m &#x2d; j} |</annotation></semantics></math>, on commence par majorer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>&delta;</mi> <mi>k</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>| \delta_k |</annotation></semantics></math> par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&beta;</mi> <mi>k</mi></msub><mo>=</mo><mi>max</mi><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mo stretchy="false">&vert;</mo><msub><mi>&delta;</mi> <mi>k</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\beta_k = \max ( 1, | \delta_k | )</annotation></semantics></math>. On est donc ramené à majorer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&sigma;</mi> <mrow><mi>j</mi><mo>,</mo><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mtext>choix</mtext><mtext>de</mtext><mi>j</mi><mtext>parmi</mtext><mi>m</mi><mtext>valeurs</mtext><msub><mi>&beta;</mi> <mi>k</mi></msub></mrow></munder><mspace width="1em"/><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><msub><mi>&beta;</mi> <mi>k</mi></msub><mo>&Element;</mo><mtext>choix</mtext></mrow></munder><msub><mi>&beta;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'> \sigma_{j, m} ( \beta ) = \sum_{\mbox{choix} \mbox{de} j \mbox{parmi} m
   \mbox{valeurs} \beta_k} \quad \prod_{\beta_k \in \mbox{choix}} \beta_k   </annotation></semantics></math>
avec pour hypothèse une majoration de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>m</mi></msubsup><msub><mi>&beta;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>M = \prod_{k = 1}^m \beta_k</annotation></semantics></math> donnée par
la relation (<a href="#eqref_5">5</a>). Pour cela, on cherche le maximum de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&sigma;</mi> <mrow><mi>j</mi><mo>,</mo><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sigma_{j,
m} ( \beta )</annotation></semantics></math> sous les contraintes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> fixé et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&beta;</mi> <mi>k</mi></msub><mo>&geq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\beta_k \geq 1</annotation></semantics></math>.</p><p>On va montrer que le maximum ne peut être atteint que si l’un des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&beta;</mi> <mi>k</mi></msub><mo>=</mo><mi>M</mi></mrow><annotation encoding='application/x-tex'>\beta_k =
M</annotation></semantics></math> (et tous les autres <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&beta;</mi> <mi>k</mi></msub><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\beta_k = 1 )</annotation></semantics></math>. Sinon, quitte à réordonner supposons
que les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&beta;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\beta_k</annotation></semantics></math> sont classés par ordre croissant. On a donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&beta;</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&ne;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\beta_{m &#x2d; 1}
\neq 1</annotation></semantics></math>, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mrow><msub><mi>&beta;</mi> <mi>k</mi></msub></mrow><mo>&tilde;</mo></mover><mo>=</mo><msub><mi>&beta;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\widetilde{\beta_k} = \beta_k</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&leq;</mo><mi>m</mi><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>k \leq m &#x2d; 2</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>&beta;</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\tilde{\beta}_{m &#x2d; 1} = 1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>&beta;</mi><mo stretchy="false">&tilde;</mo></mover> <mi>m</mi></msub><mo>=</mo><msub><mi>&beta;</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>&beta;</mi> <mi>m</mi></msub></mrow><annotation encoding='application/x-tex'>\tilde{\beta}_m = \beta_{m &#x2d; 1} \beta_m</annotation></semantics></math>.
Comparons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&sigma;</mi> <mrow><mi>j</mi><mo>,</mo><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sigma_{j, m} ( \beta )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&sigma;</mi> <mrow><mi>j</mi><mo>,</mo><mtext>nm</mtext></mrow></msub><mo stretchy="false">(</mo><mover><mi>&beta;</mi><mo stretchy="false">&tilde;</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sigma_{j, \mbox{nm}} ( \tilde{\beta}
)</annotation></semantics></math>. Si le choix de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> parmi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> comporte <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k = m &#x2d; 1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding='application/x-tex'>k = m</annotation></semantics></math>, le produit
est inchangé. Sinon on a la somme de deux produits, l’un contenant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k = m &#x2d; 1</annotation></semantics></math>
et l’autre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding='application/x-tex'>k = m</annotation></semantics></math>. On compare donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&beta;</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>&beta;</mi> <mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B ( \beta_{m &#x2d; 1} + \beta_m )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msub><mi>&beta;</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>&beta;</mi> <mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B ( 1
+ \beta_{m &#x2d; 1} \beta_m )</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><msub><mi>&beta;</mi> <mi>k</mi></msub><mo>&Element;</mo><mtext>reste</mtext><mtext>du</mtext><mtext>choix</mtext></mrow></msub><msub><mi>&beta;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>B = \prod_{\beta_k \in \mbox{reste} \mbox{du}
\mbox{choix}} \beta_k</annotation></semantics></math>. Comme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>1</mn><mo>+</mo><msub><mi>&beta;</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>&beta;</mi> <mi>m</mi></msub><mo>&geq;</mo><msub><mi>&beta;</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>&beta;</mi> <mi>m</mi></msub></mrow><annotation encoding='application/x-tex'> 1 + \beta_{m &#x2d; 1} \beta_m \geq \beta_{m &#x2d; 1} + \beta_m  </annotation></semantics></math>
puisque la différence est le produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msub><mi>&beta;</mi> <mi>m</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msub><mi>&beta;</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1&#x2d;\beta_m)(1&#x2d;\beta_{m&#x2d;1})</annotation></semantics></math> de deux
nombres positifs, on arrive à la contradiction souhaitée.</p><p>Ensuite on décompose les choix de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&sigma;</mi> <mrow><mi>m</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>\sigma_{m, j}</annotation></semantics></math> en ceux contenant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> et
des 1 et ceux ne contenant que des 1, d’où la majoration
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&sigma;</mi> <mrow><mi>j</mi><mo>,</mo><mi>m</mi></mrow></msub><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>m</mi><mo>&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mi>j</mi><mo>&minus;</mo><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow><mi>M</mi><mo>+</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>m</mi><mo>&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mi>j</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \sigma_{j, m} ( \beta ) \leq \left(\begin{array}{c}
     m &#x2d; 1\\
     j &#x2d; 1
   \end{array}\right) M + \left(\begin{array}{c}
     m &#x2d; 1\\
     j
   \end{array}\right)   </annotation></semantics></math>
et finalement
<a id="eqref_6"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>d</mi> <mrow><mi>m</mi><mo>&minus;</mo><mi>j</mi></mrow></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mi>d</mi><mo stretchy="false">&vert;</mo><mrow><mo>(</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>m</mi><mo>&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mi>j</mi><mo>&minus;</mo><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><mi>p</mi><mo stretchy="false">&vert;</mo></mrow></mfrac><mo>+</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>m</mi><mo>&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mi>j</mi></mtd></mtr></mtable><mo>)</mo></mrow><mo>)</mo></mrow><mspace width="2em"/><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>
  | d_{m &#x2d; j} | \leq | d | \left( \left(\begin{array}{c}
    m &#x2d; 1\\
    j &#x2d; 1
  \end{array}\right)  \frac{| P |}{| p |} + \left(\begin{array}{c}
    m &#x2d; 1\\
    j
  \end{array}\right) \right) 
\qquad (6) </annotation></semantics></math>
On peut en déduire une majoration indépendante de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> sur les coefficients de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>, en majorant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>d</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>| d |</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>p</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>| p |</annotation></semantics></math> (puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>) et les
coefficients binomiaux par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{m &#x2d; 1}</annotation></semantics></math> (obtenue en développant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>( 1 + 1 )^{m &#x2d;
1}</annotation></semantics></math>). D’où le</p><div class="theorem"><span style="font-weight:bold">Théorème 9</span>  <a id="hevea_default56"></a><em> </em><a id="hevea_default57"></a><em>
(</em><em><span style="font-weight:bold">Landau-Mignotte</span></em><em>) 
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> un polynôme à coefficients entiers (ou entiers de
Gauss) et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math><em> un diviseur de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> de degré </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math><em>. Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>| P |</annotation></semantics></math><em> désigne la norme
euclidienne du vecteur des coefficients de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math><em> le coefficient
dominant de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> alors les coefficients </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>d_j</annotation></semantics></math><em> de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math><em> satisfont l’inégalité
</em><a id="eqref_7"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>d</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mn>2</mn> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">&vert;</mo><mi>p</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>
    | d_j | \leq 2^{m &#x2d; 1} ( | P | + | p | )
  \qquad (7) </annotation></semantics></math><em>
</em></div><p>Avec cette estimation, on en déduit que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est un premier plus grand que
<a id="eqref_8"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>min</mi><mrow><mo>(</mo><msup><mn>2</mn> <mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">&vert;</mo><mi>p</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo><mo>,</mo><msup><mn>2</mn> <mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><mi>Q</mi><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">&vert;</mo><mi>q</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo><mo>)</mo></mrow><mo>,</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>
  \min \left( 2^{\mbox{degre} ( P ) &#x2d; 1} ( | P | + | p | ),
  2^{\mbox{degre} ( Q ) &#x2d; 1} ( | Q | + | q | ) \right), 
\qquad (8) </annotation></semantics></math>
alors le pgcd trouvé dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / n \mathbb{Z}</annotation></semantics></math> va se reconstruire en un
pgcd dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> si son degré est le bon.</p><p>Malheureusement la borne précédente est souvent très grande par rapport aux
coefficients du pgcd et calculer dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / n \mathbb{Z}</annotation></semantics></math> s’avèrera
encore inefficace (surtout si le pgcd est 1). Cela reste vrai même si on
optimise un peu la majoration (<a href="#eqref_8">8</a>) en repartant de 
(<a href="#eqref_6">6</a>).</p><p>L’idée est donc de travailler modulo plusieurs nombres premiers plus petits et
reconstruire le pgcd des 2 polynômes à coefficients entiers à partir des pgcd
des polynômes dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / n \mathbb{Z}</annotation></semantics></math> et du
théorème des restes chinois. En pratique on prend des nombres premiers
inférieurs à la racine carrée du plus grand entier hardware de la machine
(donc plus petits que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>16</mn></msup></mrow><annotation encoding='application/x-tex'>2^{16}</annotation></semantics></math> sur une machine 32 bits) ce qui permet 
d’utiliser l’arithmétique hardware du processeur sans risque de débordement.</p><p><span style="font-weight:bold">Algorithme du PGCD modulaire en 1 variable:</span></p><p>En argument: 2 polynômes primitifs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> à coefficients entiers. Le
résultat renvoyé sera le polynôme pgcd.</p><p>Variable auxiliaire: un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> initialisé à 1 qui représente le produit
des nombres premiers utilisés jusqu’ici et un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> initialisé à 0 qui
représente le pgcd dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>N</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / N \mathbb{Z}</annotation></semantics></math>.</p><p>Boucle infinie :
</p><ol class="enumerate" type=1><li class="li-enumerate">
Chercher un nouveau nombre premier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> qui ne divise pas les
coefficients dominants <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math></li><li class="li-enumerate">Calculer le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / n \mathbb{Z}</annotation></semantics></math>.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>=1, renvoyer 1.</li><li class="li-enumerate">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>H = 0</annotation></semantics></math> ou si le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est plus petit que le degré
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math>, recopier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>, passer à la 6ème étape</li><li class="li-enumerate">Si le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est plus grand que celui de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> passer à
l’itération suivante</li><li class="li-enumerate">Si le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est égal au degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math>, 
en utilisant le théorème des restes chinois, calculer un polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>H</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{H}</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>H</mi><mo stretchy="false">&tilde;</mo></mover><mo>=</mo><mi>H</mi></mrow><annotation encoding='application/x-tex'>\tilde{H} = H</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>H</mi><mo stretchy="false">&tilde;</mo></mover><mo>=</mo><mi>G</mi></mrow><annotation encoding='application/x-tex'>\tilde{H} = G</annotation></semantics></math> modulo
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. Recopier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>H</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{H}</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>N</mi></mrow><annotation encoding='application/x-tex'>n N</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>.</li><li class="li-enumerate">Ecrire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>pgcd</mtext><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo><mi>H</mi></mrow><annotation encoding='application/x-tex'>\mbox{pgcd} ( p, q ) H</annotation></semantics></math> en représentation symétrique. Soit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>H</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{H}</annotation></semantics></math> le résultat rendu primitif. Tester si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>H</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{H}</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. Si c’est le cas, renvoyer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>H</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{H}</annotation></semantics></math>, sinon passer à l’itération
suivante.
</li></ol><p>
Finalement on n’a pas utilisé <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>, la borne de Landau-Mignotte. 
On peut penser que l’étape
6 ne devrait être effectuée que lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> est plus grand que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>pgcd</mtext><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>\mbox{pgcd} (
p, q ) b</annotation></semantics></math>. En pratique, on effectue le test de l’étape 6 plus tôt parce que
les coefficients du pgcd sont rarement aussi grand que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>. Mais pour éviter
de faire le test trop tôt, on introduit une variable auxiliaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>H&apos;</annotation></semantics></math> qui
contient la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> de l’itération précédente et on ne fait le test que
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo>&prime;</mo><mo>=</mo><mi>H</mi></mrow><annotation encoding='application/x-tex'>H&apos; = H</annotation></semantics></math> (ou bien sûr si on a dépassé la borne).</p><p><span style="font-weight:bold">Remarque</span>:</p><p>L’algorithme ci-dessus fonctionne également pour des polynômes à plusieurs
variables.</p><p><span style="font-weight:bold">Exemple 1:</span></p><p>Calcul du pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>3</mn></msup><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>( X + 1 )^3 ( X &#x2d; 1 )^4</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>4</mn></msup><mo>&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow/></msup></mrow><annotation encoding='application/x-tex'>( X^4 &#x2d; 1 )^{}</annotation></semantics></math>. Prenons pour
commencer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n = 2</annotation></semantics></math>. On trouve comme pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>4</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X^4 + 1</annotation></semantics></math> (en effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>&#x2d; 1 = 1</annotation></semantics></math> donc on
cherchait le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>7</mn></msup></mrow><annotation encoding='application/x-tex'>( X + 1 )^7</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>4</mn></msup><mo>+</mo><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>X^4 + 1 = ( X + 1 )^4</annotation></semantics></math>). On teste si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>4</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X^4 + 1</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, ce n’est pas le cas donc on passe au nombre
premier suivant. Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>n = 3</annotation></semantics></math>, on trouve <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X^2 &#x2d; 1</annotation></semantics></math>. Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n = 2</annotation></semantics></math> n’était pas un
bon nombre premier pour ce calcul de pgcd puisqu’on a trouvé un pgcd de degré
plus petit. On teste si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X^2 &#x2d; 1</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, c’est le cas ici donc on
peut arrêter, le pgcd cherché est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X^2&#x2d;1</annotation></semantics></math>.</p><p><span style="font-weight:bold">Exemple</span><span style="font-weight:bold"> 2 :</span></p><p>Calcul du pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>3</mn></msup><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>( X + 1 )^3 ( X &#x2d; 1 )^4</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>4</mn></msup><mo>&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>( X^4 &#x2d; 1 )^3</annotation></semantics></math>. 
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n = 2</annotation></semantics></math>, on trouve un polynôme de degré 7.
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>n = 3</annotation></semantics></math>, on trouve <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>6</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X^6 &#x2d; 1</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n = 2</annotation></semantics></math> était une mauvaise réduction.
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>6</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X^6 &#x2d; 1</annotation></semantics></math> ne divise pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, on passe à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>n = 5</annotation></semantics></math>. On trouve <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>6</mn></msup><mo>+</mo><mn>2</mn><msup><mi>X</mi> <mn>4</mn></msup><mo>&minus;</mo><mn>2</mn><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X^6 +
2 X^4 &#x2d; 2 X^2 &#x2d; 1</annotation></semantics></math>. On applique le théorème des restes chinois qui va nous
donner un polynôme dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>15</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / 15 \mathbb{Z}</annotation></semantics></math>. On cherche donc un
entier congru à 2 modulo 5 et à 0 modulo 3, -3 est la solution (écrite en
représentation symétrique), donc le polynôme modulo 15 est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mn>6</mn></msup><mo>&minus;</mo><mn>3</mn><msup><mi>X</mi> <mn>4</mn></msup><mo>+</mo><mn>3</mn><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>X^6 &#x2d; 3 X^4 + 3
X^2 &#x2d; 1 = ( X^2 &#x2d; 1 )^3</annotation></semantics></math>. Ce polynôme divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, c’est donc le pgcd de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.</p>
<!--TOC section id="sec50" Le pgcd à plusieurs variables.-->
<h2 id="sec50" class="section">5.3  Le pgcd à plusieurs variables.</h2><!--SEC END -->
<!--TOC subsection id="sec51" Le pgcd heuristique.-->
<h3 id="sec51" class="subsection">5.3.1  Le pgcd heuristique.</h3><!--SEC END --><p><a id="hevea_default58"></a></p><p>On suppose comme dans le cas à une variable que les polynômes sont primitifs,
donc qu’on a simplifié les polynômes par le pgcd entier de leurs coefficients
entiers.</p><p>Le principe est identique à celui du PGCD à 1 variable, on évalue les deux
polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>X_1, \ldots ., X_k</annotation></semantics></math> en un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>k</mi></msub><mo>=</mo><mi>z</mi></mrow><annotation encoding='application/x-tex'>X_k = z</annotation></semantics></math> et
on calcule le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> des 2 polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( z )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( z )</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k &#x2d; 1</annotation></semantics></math>
variables. On remonte ensuite à un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> par écriture symétrique en
base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> et on teste si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>pp</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{pp} ( G )</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. Il s’agit
à nouveau de montrer que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> est assez grand, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>pp</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{pp} ( G )</annotation></semantics></math> est
le pgcd cherché. On sait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo>=</mo><mi>D</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>d = D ( z )</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>. Il existe donc un
polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k &#x2d; 1</annotation></semantics></math> variables tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>=</mo><mi>a</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>g = a d</annotation></semantics></math>. On sait aussi que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>pp</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{pp} ( G )</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>, donc il existe un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> variables
tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>=</mo><mi>C</mi><mo>&ast;</mo><mtext>pp</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>D = C \ast \mbox{pp} ( G ) .</annotation></semantics></math> On évalue en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> et on obtient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">/</mo><mi>c</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>d = C (
z ) g / c ( G )</annotation></semantics></math>, où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c ( G )</annotation></semantics></math> est un entier, donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>&ast;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> c ( G ) = a \ast C ( z )  </annotation></semantics></math>
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c ( G )</annotation></semantics></math> est un entier, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>C ( z )</annotation></semantics></math> sont des polynômes constants.
Comme précédemment, on a aussi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>| C ( z ) | \leq | z | / 2</annotation></semantics></math> puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>c</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>| c
( G ) | \leq | z | / 2</annotation></semantics></math>.
</p><ul class="itemize"><li class="li-itemize">
Premier cas: si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> ne dépend que de la variable <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>X_k</annotation></semantics></math>. On continue le
raisonnement comme dans le cas unidimensionnel.</li><li class="li-itemize">Deuxième cas: si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> dépend d’une autre variable, par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math>.
On regarde le coefficient de plus haut degre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> par rapport a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math>. Ce
coefficient divise le coefficient de plus haut degre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par
rapport a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math>. Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>C ( z )</annotation></semantics></math> est constant, on en deduit que le
coefficient de plus haut degre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par rapport a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math> est
divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>k</mi></msub><mo>&minus;</mo><mi>z</mi></mrow><annotation encoding='application/x-tex'>X_k &#x2d; z</annotation></semantics></math> donc le coefficient de plus bas degre en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>X_k</annotation></semantics></math> de
ces coefficients de plus haut degre est divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>, ce qui contredit
la majoration de ce coefficient.
</li></ul><p>En pratique, cet algorithme nécessite le calcul récursif de pgcd sans
garantie de réussite. On l’évite donc s’il y a beaucoup de variables (la
limite est par exemple de 5 pour MuPAD).</p>
<!--TOC subsection id="sec52" Le pgcd modulaire multivariables.-->
<h3 id="sec52" class="subsection">5.3.2  Le pgcd modulaire multivariables.</h3><!--SEC END --><p><a id="hevea_default59"></a></p><p>Ici, on travaille modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mrow/></msub></mrow><annotation encoding='application/x-tex'>X_n &#x2d; \alpha_{}</annotation></semantics></math>, où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_1, \ldots ., X_n</annotation></semantics></math> désignent
les variables des polynômes. On considère donc deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> comme
polynômes de la variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_n</annotation></semantics></math> avec des coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z} [ X_1,
\ldots ., X_{n &#x2d; 1} ]</annotation></semantics></math>. On évalue en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub><mo>=</mo><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>X_n = \alpha</annotation></semantics></math>, on obtient deux polynômes
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n &#x2d; 1</annotation></semantics></math> variables dont on calcule le pgcd (récursivement).</p><p>Il s’agit de reconstruire le pgcd par interpolation. Tout d’abord, on a une 
borne évidente sur le degré du pgcd par rapport à la variable <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_n</annotation></semantics></math>, c’est le
minimum <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\delta</annotation></semantics></math> des degrés par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_n</annotation></semantics></math> des polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. A
première vue, il suffit donc d’évaluer les polynômes
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\delta + 1</annotation></semantics></math> points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>.</p><p>Il faut toutefois prendre garde aux mauvaises évaluations et à la
normalisation des pgcd avant d’interpoler. En effet, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D ( X_1, \ldots .,
X_n )</annotation></semantics></math> désigne le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>G ( X_1, \ldots ., X_{n &#x2d; 1} )</annotation></semantics></math> le
pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( X_1, \ldots ., X_{n &#x2d; 1}, \alpha )</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( X_1, \ldots .,
X_{n &#x2d; 1}, \alpha )</annotation></semantics></math>, 
on peut seulement dire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D ( X_1, \ldots ., X_{n &#x2d; 1}, \alpha )</annotation></semantics></math>
divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>. Plusieurs cas sont donc possibles lorsqu’on évalue en un nouveau
point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>:
</p><ul class="itemize"><li class="li-itemize">
l’un des degrés de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est plus petit que le degré du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math>
reconstruit par interpolation jusque là. Dans ce cas, toutes les évaluations
qui ont conduit à reconstruire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math> étaient mauvaises. Il faut recommencer
l’interpolation à zéro ou à partir de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> (si tous les degrés de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> sont
inférieurs ou égaux aux degrés du <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math> reconstruit).</li><li class="li-itemize">l’un des degrés de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est plus grand que le degré du <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math> reconstruit
jusque là. Il faut alors ignorer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>.</li><li class="li-itemize">Tous les degrés de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> sont égaux aux degrés du <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math> reconstruit
jusque là. Dans ce cas, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> est un multiple entier du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math>
reconstruit jusque là et évalué en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub><mo>=</mo><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>X_n = \alpha</annotation></semantics></math>. Si on suppose qu’on a pu
s’arranger pour que ce multiple soit 1, on ajoute le point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> aux
points d’évaluation précédents <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\alpha_j</annotation></semantics></math> en posant:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>D</mi><mo>&prime;</mo><mo>=</mo><mi>D</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mo stretchy="false">(</mo><mi>G</mi><mo>&minus;</mo><mi>D</mi><mo>&prime;</mo><mo stretchy="false">)</mo><mfrac><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><msub><mi>&alpha;</mi> <mi>j</mi></msub></mrow></munder><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><msub><mi>&alpha;</mi> <mi>j</mi></msub></mrow></munder><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> D&apos; = D&apos; + ( G &#x2d; D&apos; ) \frac{\prod_{\alpha_j} ( X_n &#x2d; \alpha_j
     )}{\prod_{\alpha_j} ( \alpha &#x2d; \alpha_j )}  </annotation></semantics></math>
</li></ul><p>
On voit que les mauvaises évaluations se détectent simplement par les degrés.
Pour la normalisation, on utilise une petite astuce: au lieu de reconstruire
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>le</mtext><mtext>pgcd</mtext><mi>D</mi></mrow><annotation encoding='application/x-tex'>\mbox{le} \mbox{pgcd} D</annotation></semantics></math>, on va reconstruire un multiple du pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> (ce
multiple appartiendra à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z} [ X_n ] )</annotation></semantics></math>. On voit maintenant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>
comme des polynômes en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n &#x2d; 1</annotation></semantics></math> variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1, \ldots ., X_{n &#x2d; 1}</annotation></semantics></math> à
coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z} [ X_n ]</annotation></semantics></math>. Alors lcoeff<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(D)</annotation></semantics></math>, 
le coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>
(relativement à l’ordre lexicographique sur les variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1}</annotation></semantics></math>),
est un polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_n</annotation></semantics></math> qui divise le coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>
donc divise le coefficient dominant du pgcd des coefficients dominants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. On va donc reconstruire le polynôme :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>D</mi><mo>&prime;</mo><mo>=</mo><mi>D</mi><mfrac><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>,</mo><mi>&Delta;</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mtext>pgcd</mtext><mo stretchy="false">(</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> D&apos; = D \frac{\Delta ( X_n )}{\mbox{lcoeff} ( D ) ( X_n )}, \Delta ( X_n ) =
   \mbox{pgcd} ( \mbox{lcoeff} ( P ) ( X_n ), \mbox{lcoeff} ( Q ) ( X_n ))  </annotation></semantics></math>
c’est-à-dire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> multiplié par un polynôme qui ne dépend que de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_n</annotation></semantics></math>.</p><p>Revenons à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> en un point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> de bonne évaluation. C’est un multiple
entier de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D ( X_1, \ldots ., X_{n &#x2d; 1}, \alpha )</annotation></semantics></math>:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>G</mi><mo>=</mo><mi>&beta;</mi><mi>D</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> G = \beta D ( X_1, \ldots ., X_{n &#x2d; 1}, \alpha )  </annotation></semantics></math>
Donc, comme polynômes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1}</annotation></semantics></math> à coefficients dans 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X_n]</annotation></semantics></math> ou dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>&beta;</mi><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>D</mi><msub><mo stretchy="false">)</mo> <mrow><mo stretchy="false">&vert;</mo><msub><mi>X</mi> <mi>n</mi></msub><mo>=</mo><mi>&alpha;</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( G ) = \beta \mbox{lcoeff} ( D )_{| X_n = \alpha}</annotation></semantics></math>. Comme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( D )</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\Delta ( X_n )</annotation></semantics></math>, il en est de même en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub><mo>=</mo><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>X_n =
\alpha</annotation></semantics></math> donc lcoeff<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(G)</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi><mi>&Delta;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\beta \Delta(\alpha)</annotation></semantics></math>. 
On en déduit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>G</mi></mrow><annotation encoding='application/x-tex'> \Delta ( \alpha) G</annotation></semantics></math> qui 
est divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'> \Delta (\alpha) \beta</annotation></semantics></math> est
divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( G )</annotation></semantics></math>. On va donc considérer le polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>G</mi><mo stretchy="false">/</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \Delta (\alpha) G  / \mbox{lcoeff} ( G )</annotation></semantics></math> :
ses coefficients sont entiers et son coefficient dominant est 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>D</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\Delta ( \alpha) = \mbox{lcoeff}(D&apos;( X_1, \ldots ., X_{n &#x2d; 1}, \alpha )) </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>G</mi><mo stretchy="false">/</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>D</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \Delta (\alpha) G  / \mbox{lcoeff} ( G )=
D&apos;( X_1, \ldots ., X_{n &#x2d; 1}, \alpha ) </annotation></semantics></math></p><p><span style="font-weight:bold">Algorithme du pgcd modulaire à plusieurs variables (interpolation
dense)</span>:</p><p>Arguments: 2 polynômes primitifs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_1, \ldots .,
X_n</annotation></semantics></math> à coefficients entiers. Renvoie le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n = 1</annotation></semantics></math>, renvoyer le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> en une variable.</li><li class="li-enumerate">Test rapide de pgcd trivial par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_n</annotation></semantics></math>. On cherche des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n &#x2d;
  1</annotation></semantics></math>-uplets <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> tels que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( \alpha, X_n )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( \alpha, X_n )</annotation></semantics></math>
soient de même degré que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par rapport à la variable <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_n</annotation></semantics></math>. On
calcule le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> de ces 2 polynômes en une variable. Si le pgcd est
constant, alors on retourne le pgcd des coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.</li><li class="li-enumerate">On divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par leur contenu respectifs vu comme polynômes en
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1, \ldots ., X_{n &#x2d; 1}</annotation></semantics></math> à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z} [ X_n ]</annotation></semantics></math>, on note
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>C ( X_n )</annotation></semantics></math> le pgcd des contenus. On calcule aussi le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\Delta ( X_n )</annotation></semantics></math>
des coefficients dominants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.</li><li class="li-enumerate">On initialise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math> le pgcd reconstruit à 0, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>I ( X_n )</annotation></semantics></math> le polynôme
d’interpolation à 1, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>&delta;</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>&delta;</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\delta=(\delta_1,...,\delta_{n&#x2d;1})</annotation></semantics></math> 
la liste des degrés partiels du pgcd par
rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1, \ldots ., X_{n &#x2d; 1}</annotation></semantics></math> au minimum des degrés partiels de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1, \ldots ., X_{n &#x2d; 1}</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi></mrow><annotation encoding='application/x-tex'>e</annotation></semantics></math> le nombre d’évaluation
à 0 et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi></mrow><annotation encoding='application/x-tex'>E</annotation></semantics></math> l’ensemble des points d’interpolation à la liste vide.</li><li class="li-enumerate">Boucle infinie:
<ul class="itemize"><li class="li-itemize">
Faire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>=entier aléatoire n’appartenant pas à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi></mrow><annotation encoding='application/x-tex'>E</annotation></semantics></math> jusqu’à ce
que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mtext>degre</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mtext>degre</mtext> <mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mtd> <mtd/> <mtd/></mtr> <mtr><mtd><mtext>degre</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mtext>degre</mtext> <mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd> <mtd/> <mtd/></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
      \mbox{degre}(P ( X_1, \ldots ., X_{n &#x2d; 1}, \alpha
      ))=\mbox{degre}_{X_n} ( P ( X_1, \ldots ., X_n ) &amp;  &amp; \\
      \mbox{degre} ( Q ( X_1, \ldots ., X_{n &#x2d; 1}, \alpha )) =
      \mbox{degre}_{X_n} ( Q ( X_1, \ldots ., X_n )) &amp;  &amp; 
     \end{matrix} </annotation></semantics></math>
</li><li class="li-itemize">Calculer le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>G ( X_1, \ldots ., X_{n &#x2d; 1} )</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n &#x2d; 1</annotation></semantics></math>
variables de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( X_1, \ldots ., X_{n &#x2d; 1}, \alpha )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( X_1, \ldots
    ., X_{n &#x2d; 1}, \alpha )</annotation></semantics></math>.</li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mtext>degre</mtext> <mrow/></msub><mo stretchy="false">(</mo><mi>G</mi><msub><mo stretchy="false">)</mo> <mi>i</mi></msub><mi>&lt;</mi><msub><mi>&delta;</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>\mbox{degre}_{} ( G )_i &amp;lt; \delta_i</annotation></semantics></math> pour un indice au moins.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( G ) \leq \delta</annotation></semantics></math>, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi><mo>=</mo><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\delta =
    \mbox{degre} ( G )</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo><mo>=</mo><mi>G</mi><mfrac><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>D&apos; = G \frac{\Delta ( \alpha )}{\mbox{lcoeff} ( G
    )}</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>=</mo><msub><mi>X</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>I = X_n &#x2d; \alpha</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>e = 1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi><mo>=</mo><mo stretchy="false">[</mo><mi>&alpha;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>E = [ \alpha ]</annotation></semantics></math>, sinon on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi><mo>=</mo><mi>min</mi><mo stretchy="false">(</mo><mi>&delta;</mi><mo>,</mo><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>,</mo><mi>D</mi><mo>&prime;</mo><mo>=</mo><mn>0</mn><mo>,</mo><mi>I</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>e</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>E</mi><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\delta
    = \min ( \delta, \mbox{degre} ( G )), D&apos; = 0, I = 1, e = 0, E = [ ]</annotation></semantics></math>.
On passe à l’itération suivante.</li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mi>&gt;</mi><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( G ) &amp;gt; \delta</annotation></semantics></math>, on passe à l’itération suivante.</li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( G ) = \delta</annotation></semantics></math>, on interpole:
<ul class="itemize"><li class="li-itemize">
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo>:</mo><mo>=</mo><mi>G</mi><mfrac><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>G := G \frac{\Delta ( \alpha )}{\mbox{lcoeff} ( G )}</annotation></semantics></math></li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo><mo>:</mo><mo>=</mo><mi>D</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mfrac><mrow><mi>I</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo>&Element;</mo><mi>E</mi></mrow></msub><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">(</mo><mi>G</mi><mo>&minus;</mo><mi>D</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D&apos; := D&apos; + \frac{I ( X_n )}{\prod_{\alpha_j \in E} ( \alpha &#x2d;
      \alpha_j )} ( G &#x2d; D&apos; ( X_1, \ldots ., X_{n &#x2d; 1}, \alpha ))</annotation></semantics></math></li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>:</mo><mo>=</mo><mi>I</mi><mo>&ast;</mo><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>I := I \ast ( X_n &#x2d; \alpha )</annotation></semantics></math></li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>:</mo><mo>=</mo><mi>e</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>e := e + 1</annotation></semantics></math> et ajouter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi></mrow><annotation encoding='application/x-tex'>E</annotation></semantics></math></li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi></mrow><annotation encoding='application/x-tex'>e</annotation></semantics></math> est strictement plus grand que le minimum des degrés
partiels de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_n</annotation></semantics></math>, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{D}</annotation></semantics></math> la
partie primitive de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos; </annotation></semantics></math>(vu comme polynôme à coefficients dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z} [ X_n ]</annotation></semantics></math>), on teste si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> sont divisibles par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{D}</annotation></semantics></math>, si c’est le cas, on renvoie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>=</mo><mi>C</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>D = C ( X_n ) \tilde{D}</annotation></semantics></math>
</li></ul>
</li></ul>
</li></ol><p>
On observe que dans cet algorithme, on fait le test de divisibilite de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>D</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{D}</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>. En effet, même après avoir évalué en suffisamment
de points, rien n’indique que tous ces points sont des points de bonne
évaluation. En pratique cela reste extrêmement improbable. En pratique, on
teste la divisibilité plus tôt, dès que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math> n’est pas modifié par l’ajout
d’un nouveau point à la liste des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\alpha_j</annotation></semantics></math>.</p><p>Il existe une variation de cet algorithme, appelé SPMOD (sparse modular), qui
suppose que seuls les coefficients non nuls du pgcd en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n &#x2d; 1</annotation></semantics></math> variables sont
encore non nuls en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> variables (ce qui a de fortes chances d’être le cas).
L’étape d’interpolation est alors remplacée par la résolution d’un
sous-système d’un système de Vandermonde. Cette variation est intéressante si
le nombre de coefficients non nuls en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n &#x2d; 1</annotation></semantics></math> variables est petit devant le
degré. Si elle échoue, on revient à l’interpolation dense.</p><p>Notons enfin qu’on peut appliquer cette méthode lorsque les coefficients de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> sont dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z} / n \mathbb{Z}</annotation></semantics></math> mais il faut alors vérifier
qu’on dispose de suffisamment de points d’interpolation. Ce qui en combinant
avec l’algorithme modulaire à une variable donne un algorithme doublement
modulaire pour calculer le pgcd de 2 polynômes à coefficients entiers. C’est
cette méthode qu’utilise par exemple MuPAD (en essayant d’abord SPMOD puis
l’interpolation dense).</p><p><span style="font-weight:bold">Exemple:</span></p><p>Dans cet exemple, on donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> sous forme factorisée, le but étant de
faire comprendre l’algorithme. En utilisation normale, on n’exécuterait cet
algorithme que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> étaient développés.</p><p><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>y</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mi>Q</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>y</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi><mi>y</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P = (( x + 1 ) y + x^2 + 1 ) ( y^2 + x y + 1 ), Q = (( x + 1 ) y +
x^2 + 1 ) ( y^2 &#x2d; x y &#x2d; 1 )</annotation></semantics></math>.</p><p>Prenons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> comme variable <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> comme variable <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>X_2</annotation></semantics></math>. Les coefficients
dominants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> sont respectivement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>&#x2d; y</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>\Delta = y</annotation></semantics></math>.</p><p>En <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y = 0</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P ( x, 0 ) = x^2 + 1</annotation></semantics></math> n’est pas du bon degré.</p><p>En <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>y = 1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( x, 1 ) = ( x + x^2 + 2 ) ( x + 2 )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( x, 1 ) = ( x +
x^2 + 2 ) ( &#x2d; x )</annotation></semantics></math> sont du bon degré. Leur pgcd est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>G = x^2 + x + 2</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\Delta
( 1 ) = 1</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>D&apos; = x^2 + x + 1</annotation></semantics></math>. On teste la divisibilité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math>,
le teste échoue.</p><p>En <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>y = 2</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( x, 2 ) = ( x^2 + 2 x + 3 ) ( 2 x + 5 )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( x, 2 ) = (
x^2 + 2 x + 3 ) ( &#x2d; 2 x + 3 )</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>G = x^2 + 2 x + 3</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\Delta ( 2 ) = 2</annotation></semantics></math>.
On interpole:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>D</mi><mo>&prime;</mo><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo>+</mo><mfrac><mrow><mi>y</mi><mo>&minus;</mo><mn>1</mn></mrow><mrow><mn>2</mn><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> D&apos; = x^2 + x + 2 + \frac{y &#x2d; 1}{2 &#x2d; 1} ( 2 ( x^2 + 2 x + 3 ) &#x2d; ( x^2 + x +
   2 )) = y ( x^2 + 3 x + 4 ) &#x2d; ( 2 x + 2 )  </annotation></semantics></math>
On teste la divisibilité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math>, le test échoue.</p><p>En <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>y = 3</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P ( x, 3 ) = ( x^2 + 3 x + 4 ) ( 3 x + 10 )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>8</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q ( x, 3 ) = (
x^2 + 3 x + 4 ) ( &#x2d; 3 x + 8 )</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>G = x^2 + 3 x + 4</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Delta;</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>\Delta ( 3 ) = 3</annotation></semantics></math>.
On interpole:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>D</mi><mo>&prime;</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>y</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo></mtd></mtr> <mtr><mtd/> <mtd/> <mtd><mfrac><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mn>3</mn><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>3</mn><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><mrow><mo>(</mo><mn>3</mn><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
  D&apos; &amp;= &amp;y ( x^2 + 3 x + 4 ) &#x2d; ( 2 x + 2 ) + \\
  &amp; &amp; \frac{( y &#x2d; 2 ) ( y &#x2d; 1 )}{( 3 &#x2d; 2
  ) ( 3 &#x2d; 1 )} \left( 3 ( x^2 + 3 x + 4 ) &#x2d; ( 3 ( x^2 + 3 x + 4 ) &#x2d; ( 2 x + 2
  )) \right)
 \end{matrix} </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>D</mi><mo>&prime;</mo><mo>=</mo><mi>y</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mi>x</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mi>y</mi><mo>+</mo><mi>x</mi><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'> D&apos; = y ( x^2 + 3 x + 4 ) &#x2d; ( 2 x + 2 ) + \frac{( y &#x2d; 2 ) ( y &#x2d; 1 )}{2} ( &#x2d;
   2 x &#x2d; 2 ) = x^2 y + x y^2 + y^2 + y  </annotation></semantics></math>
On divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>D&apos;</annotation></semantics></math> par son contenu et on trouve <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mi>y</mi><mo>+</mo><mi>y</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^2 + x y + y + 1</annotation></semantics></math> qui est bien
le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.</p>
<!--TOC subsection id="sec53" EZGCD.-->
<h3 id="sec53" class="subsection">5.3.3  EZGCD.</h3><!--SEC END --><p>Il s’agit d’une méthode <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-adique. On évalue toutes les variables sauf une,
on calcule le pgcd en une variable et on remonte au pgcd variable par variable
(EEZGCD) ou toutes les variables simultanément (EZGCD) par un lemme de Hensel.
Il semble qu’il est plus efficace de remonter les variables séparément.</p><p>Soit donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> deux polynômes primitifs dépendant des variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_1,
\ldots, X_n</annotation></semantics></math> de pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>, on fixe une des variables qu’on appelera <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math> dans
la suite. Soient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( F )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( G )</annotation></semantics></math> les
coefficients dominants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math>. On évalue <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>
en un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n &#x2d; 1</annotation></semantics></math> uplet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> tel que le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math>
soit conservé après evaluation en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>. On suppose que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mtext>pgcd</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>,</mo><mi>G</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D_b ( X_1 ) =
\mbox{pgcd} ( F ( b ), G ( b ))</annotation></semantics></math> a le même degré que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D ( b )</annotation></semantics></math>. On a donc
l’égalité:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo>&ast;</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>(</mo><msub><mi>D</mi> <mi>b</mi></msub><mfrac><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>D</mi> <mi>b</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>)</mo></mrow><mo>&ast;</mo><mrow><mo>(</mo><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac><mfrac><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac><mo stretchy="false">)</mo></mrow></mfrac><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> ( F \ast \mbox{lcoeff} ( F )) ( b ) = \left( D_b  \frac{\mbox{lcoeff} ( F (
   b ))}{\mbox{lcoeff} ( D_b )} \right) \ast \left( \frac{F ( b )}{D_b} 
   \frac{\mbox{lcoeff} ( F ) ( b )}{\mbox{lcoeff} ( \frac{F ( b )}{D_b} )}
   \right)  </annotation></semantics></math>
et de même en remplaçant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>.</p><p>Pour pouvoir lifter cette égalité (c’est-à-dire généraliser à plusieurs 
variables), il faut que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow><annotation encoding='application/x-tex'>D_b</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{F ( b )}{D_b}</annotation></semantics></math>
soient premiers entre eux. Sinon, on peut essayer de lifter l’égalité analogue
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>. En général, on montre qu’il existe un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow><annotation encoding='application/x-tex'>D_b</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mi>j</mi><mi>G</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{F ( b ) + j G ( b )}{D_b}</annotation></semantics></math> soient premiers entre eux. En effet, sinon
au moins un des facteurs irréductibles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow><annotation encoding='application/x-tex'>D_b</annotation></semantics></math> va diviser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mi>j</mi><mi>G</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{F ( b ) + j
G ( b )}{D_b}</annotation></semantics></math> pour deux valeurs distinctes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> et va donc diviser à la
fois <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{F ( b )}{D_b}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{G ( b )}{D_b}</annotation></semantics></math> en contradiction avec la
définition de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub><mo>=</mo><mtext>pgcd</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>,</mo><mi>G</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D_b = \mbox{pgcd} ( F ( b ), G ( b ))</annotation></semantics></math>. On lifte alors
l’égalité obtenue en remplaçant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo>+</mo><mi>k</mi><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>( F + k G )</annotation></semantics></math> ci-dessus. Dans la
suite, on suppose qu’on peut prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>j = 0</annotation></semantics></math> pour alléger les notations.</p><p>On va aussi supposer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>b = 0</annotation></semantics></math>. Sinon, on fait un changement d’origine sur
les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> pour que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>b = 0</annotation></semantics></math> convienne, on calcule le pgcd et on
lui applique la translation d’origine opposée.</p><p>On adopte ensuite la notation suivante: si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est un entier, on dit qu’un
polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O ( k )</annotation></semantics></math> si la valuation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> vu comme polynôme en
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_2, \ldots ., X_n</annotation></semantics></math> à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mn>1</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z} [ X_1 ]</annotation></semantics></math> est supérieure
ou égale à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>k</mi> <mrow/></msup></mrow><annotation encoding='application/x-tex'>k^{}</annotation></semantics></math>, ou de manière équivalente si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mi>h</mi><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><mi>h</mi><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>O</mi> <mrow><mi>h</mi><mo>&rightarrow;</mo><mn>0</mn></mrow></msub><mo stretchy="false">(</mo><msup><mi>h</mi> <mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> P ( X_1, h X_2, \ldots ., h X_n ) = O_{h \rightarrow 0} ( h^k )  </annotation></semantics></math>
L’égalité à lifter se réécrit donc:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>F</mi><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>P</mi> <mn>0</mn></msub><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> F \mbox{lcoeff} ( F ) = P_0 Q_0 + O ( 1 )  </annotation></semantics></math> 
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo>=</mo></mrow><annotation encoding='application/x-tex'>P_0 =</annotation></semantics></math><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub><mfrac><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>D</mi> <mi>b</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>D_b  \frac{\mbox{lcoeff} ( F ( b ))}{\mbox{lcoeff} ( D_b )}</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub><mo>=</mo><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac><mfrac><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>Q_0 = \frac{F ( b )}{D_b}  \frac{\mbox{lcoeff} ( F ) ( b )}{\mbox{lcoeff} (
\frac{F ( b )}{D_b} )}</annotation></semantics></math> sont premiers entre eux et de degré 0 par rapport aux
variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_2, \ldots ., X_n</annotation></semantics></math>. Cherchons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_1 = O ( 1 )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q_1 = O ( 1 )</annotation></semantics></math>
de degré 1 par rapport aux variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_2, \ldots ., X_n</annotation></semantics></math> tels que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>F</mi><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> F \mbox{lcoeff} ( F ) = ( P_0 + P_1 ) ( Q_0 + Q_1 ) + O ( 2 )  </annotation></semantics></math>
Il faut donc résoudre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>F</mi><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>P</mi> <mn>0</mn></msub><msub><mi>Q</mi> <mn>0</mn></msub><mo>=</mo><msub><mi>P</mi> <mn>0</mn></msub><msub><mi>Q</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>0</mn></msub><msub><mi>P</mi> <mn>1</mn></msub><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> F \mbox{lcoeff} ( F ) &#x2d; P_0 Q_0 = P_0 Q_1 + Q_0 P_1 + O ( 2 )  </annotation></semantics></math>
On peut alors appliquer l’identité de Bézout qui permet de déterminer des
polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>P_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1</annotation></semantics></math> satisfaisant l’égalité ci-dessus (avec comme reste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O
( 2 )</annotation></semantics></math> nul) puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math> sont premiers entre eux. De plus, on
choisit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>P_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1</annotation></semantics></math> tels que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mtext>degre</mtext> <mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow></msub><msub><mi>P</mi> <mn>1</mn></msub><mo>&leq;</mo><msub><mtext>degre</mtext> <mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow></msub><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mtext>degre</mtext> <mrow/></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mtext>degre</mtext><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre}_{X_1} P_1 \leq
\mbox{degre}_{X_1} ( F ) &#x2d; \mbox{degre}_{} ( Q_0 ) = \mbox{degre} ( P_0 )</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mtext>degre</mtext> <mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>&leq;</mo><mtext>degre</mtext><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre}_{X_1} ( Q_1 ) \leq \mbox{degre} ( Q_0 )</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mtext>lcoeff</mtext> <mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow></msub><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mtext>lcoeff</mtext> <mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mtext>lcoeff</mtext> <mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow></msub><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff}_{X_1} ( P_0 + P_1 ) + O ( 2 ) = \mbox{lcoeff}_{X_1} ( Q_0 + Q_1
) + O ( 2 ) = \mbox{lcoeff}_{X_1} ( F )</annotation></semantics></math>. On tronque ensuite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>P_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1</annotation></semantics></math> en
ne conservant que les termes de degré 1 par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_2, \ldots ., X_n</annotation></semantics></math>.</p><p>On trouve de la même manière par récurrence <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>Q_k</annotation></semantics></math> homogènes de degré
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>X_2, \ldots ., X_k</annotation></semantics></math>, de degré par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math>
respectivement inférieur aux degrés de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et tels que
<a id="eqref_9"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>F</mi><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>Q</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>9</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>
  F \mbox{lcoeff} ( F ) = ( P_0 + \ldots . + P_k ) ( Q_0 + \ldots . + Q_k ) +
  O ( k + 1  ) 
\qquad (9) </annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mtext>lcoeff</mtext> <mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow></msub><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mtext>lcoeff</mtext> <mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>Q</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( F ) = \mbox{lcoeff}_{X_1} ( P_0 + \ldots . + P_k ) + O ( k
+ 1 ) = \mbox{lcoeff}_{X_1} ( Q_0 + \ldots . + Q_k ) + O ( k + 1 )</annotation></semantics></math>.</p><p>Si on est bien en un point de bonne évaluation et si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est plus grand que le
degré total (par rapport aux variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_2, \ldots ., X_n</annotation></semantics></math>) du polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>F \mbox{lcoeff} ( F )</annotation></semantics></math> on va vérifier que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>P</mi> <mi>k</mi></msub><mo>=</mo><mi>D</mi><mfrac><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>P_0 + \ldots . + P_k = D
\frac{\mbox{lcoeff} ( F )}{\mbox{lcoeff} ( D )}</annotation></semantics></math>. En effet, si on a deux
suites de polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>Q&apos;</annotation></semantics></math> satisfaisant (<a href="#eqref_9">9</a>) avec
les même termes de degré zéro <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math>, alors en prenant la différence,
on obtient:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub><mi>&hellip;</mi><mo>+</mo><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>1</mn></msub><mi>&hellip;</mi><mo>+</mo><msub><mi>Q</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub><mo>&prime;</mo><mi>&hellip;</mi><mo>+</mo><msub><mi>P</mi> <mi>k</mi></msub><mo>&prime;</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>&prime;</mo><mi>&hellip;</mi><mo>+</mo><msub><mi>Q</mi> <mi>k</mi></msub><mo>&prime;</mo><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> ( P_0 + P_1 \ldots  + P_k ) ( Q_0 + Q_1 \ldots  + Q_k ) = ( P_0 + P_1&apos;
   \ldots  + P_k&apos; ) ( Q_0 + Q_1&apos; \ldots  + Q_k&apos; ) + O ( k + 1 )  </annotation></semantics></math>
On égale alors les termes homogènes de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>, pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>j = 1</annotation></semantics></math>, on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>&prime;</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>P</mi> <mn>1</mn></msub><mo>&prime;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_0 ( Q_1 &#x2d; Q_1&apos; ) = Q_0 ( P_1 &#x2d; P_1&apos; )</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>Q_1 &#x2d; Q_1&apos;</annotation></semantics></math> qui
est de degré strictement inférieur au degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math> (car
on a l’inégalité large et les termes de plus haut degré sont égaux),
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>Q_1 = Q_1&apos;</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>P</mi> <mn>1</mn></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P_1 = P_1&apos;</annotation></semantics></math>. On montre de la même manière que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>Q</mi> <mi>j</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>Q_j =
Q_j&apos;</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>P</mi> <mi>j</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P_j = P_j&apos;</annotation></semantics></math>. L’écriture est donc unique, c’est donc l’écriture en
polynôme homogène de degré croissant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mfrac><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>D \frac{\mbox{lcoeff} ( F
)}{\mbox{lcoeff} ( D )}</annotation></semantics></math> que l’on reconstruit.</p><p>Cet algorithme permet donc de reconstruire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>, il suffit de tester à chaque
étape si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_0 + \ldots . + P_k</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>F \mbox{lcoeff} ( F )</annotation></semantics></math>. On appelle
cette méthode de remontée lemme de Hensel linéaire. Il existe une variante
dite lemme de Hensel quadratique qui consiste à passer de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O ( k )</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O ( 2 k
)</annotation></semantics></math>. Elle nécessite toutefois un calcul supplémentaire, celui de l’identité de
Bézout à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O ( 2 k )</annotation></semantics></math> près pour les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>P</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P_0 + \ldots . + P_{k &#x2d; 1}</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><mi>&hellip;</mi><mo>.</mo><mo>+</mo><msub><mi>Q</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>Q_0 + \ldots . + Q_{k &#x2d; 1}</annotation></semantics></math>. Ce calcul se fait également par lifting.</p><p><span style="font-weight:bold">Algorithme EZGCD (Hensel linéaire)</span></p><p>Arguments: 2 polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> à coefficients entiers et primitifs. Renvoie
le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> ou false.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Evaluer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>( X_2, \ldots ., X_n ) = ( 0, \ldots ., 0 )</annotation></semantics></math>,
vérifier que les coefficients dominants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> ne s’annulent pas.
Calculer le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow><annotation encoding='application/x-tex'>D_b</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>F ( 0 )</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>G ( 0 )</annotation></semantics></math>. Prendre un autre point
d’évaluation au hasard qui n’annule pas les coefficients dominants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> et vérifier que le pgcd a le même degré que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow><annotation encoding='application/x-tex'>D_b</annotation></semantics></math>. Sinon, renvoyer
false (on peut aussi faire une translation d’origine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> en un
autre point mais cela diminue l’efficacité de l’algorithme).</li><li class="li-enumerate">On note <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcF</mtext></mrow><annotation encoding='application/x-tex'>\mbox{lcF}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcG</mtext></mrow><annotation encoding='application/x-tex'>\mbox{lcG}</annotation></semantics></math> les coefficients dominants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math>
et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math>.</li><li class="li-enumerate">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( F ) \leq \mbox{degre} ( G )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><msub><mi>D</mi> <mi>b</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre}
  ( D_b ) = \mbox{degre} ( G )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> renvoyer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math></li><li class="li-enumerate">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mtext>degre</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( G ) &amp;lt; \mbox{degre} ( F )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><msub><mi>D</mi> <mi>b</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mtext>degre</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( D_b )
  = \mbox{degre} ( F )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> renvoyer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math></li><li class="li-enumerate">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>degre</mtext><mo stretchy="false">(</mo><msub><mi>D</mi> <mi>b</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( F ) = \mbox{degre} ( D_b )</annotation></semantics></math> ou si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>degre</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>degre</mtext><mo stretchy="false">(</mo><msub><mi>D</mi> <mi>b</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{degre} ( G
  ) = \mbox{degre} ( D_b )</annotation></semantics></math> renvoyer false</li><li class="li-enumerate">Boucle infinie sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> entier initialisé à 0, incrémenté de 1 à chaque
itération: si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>pgcd</mtext><mo stretchy="false">(</mo><msub><mi>D</mi> <mi>b</mi></msub><mo>,</mo><mfrac><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mi>j</mi><mi>G</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow></mfrac><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi></mrow><annotation encoding='application/x-tex'>\mbox{pgcd} ( D_b, \frac{F ( 0 ) + j G ( 0 )}{D_b} ) = C</annotation></semantics></math>
constant, alors arrêter la boucle</li><li class="li-enumerate">Lifter l’égalité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo>+</mo><mi>j</mi><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mtext>lcF</mtext><mo>+</mo><mi>j</mi><mtext>lcG</mtext><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>(</mo><msub><mi>D</mi> <mi>b</mi></msub><mfrac><mrow><mo stretchy="false">(</mo><mtext>lcF</mtext><mo>+</mo><mi>j</mi><mtext>lcG</mtext><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>D</mi> <mrow><mi>b</mi><mo stretchy="false">)</mo></mrow></msub></mrow></mfrac><mo>)</mo></mrow><mo>&ast;</mo><mi>&hellip;</mi><mo>.</mo></mrow><annotation encoding='application/x-tex'>( F + j G ) ( \mbox{lcF} + j \mbox{lcG} ) ( 0 ) =
  \left( D_b  \frac{( \mbox{lcF} + j \mbox{lcG} ) ( 0 )}{\mbox{lcoeff} ( D_{b
  )}} \right) \ast \ldots .</annotation></semantics></math> par remontée de Hensel linéaire ou quadratique.
Si le résultat est false, renvoyer false. Sinon renvoyer le premier polynôme
du résultat divisé par son contenu vu comme polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math> à coefficients
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z} [ X_2, \ldots ., X_n ]</annotation></semantics></math>.
</li></ol><p>
<span style="font-weight:bold">Remontée de Hensel linéaire</span>:<a id="hevea_default60"></a></p><p>Arguments: <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> un polynôme, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcF</mtext></mrow><annotation encoding='application/x-tex'>\mbox{lcF}</annotation></semantics></math>=lcoeff<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(F)</annotation></semantics></math> 
son coefficient dominant, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> un
facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>F ( 0 )</annotation></semantics></math> ayant comme coefficient dominant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcF</mtext><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcF} ( 0 )</annotation></semantics></math> et
dont le cofacteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math> est premier avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math>.</p><p>Renvoie deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> tels que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mtext>lcF</mtext><mo>=</mo><mi>P</mi><mi>Q</mi></mrow><annotation encoding='application/x-tex'>F \mbox{lcF} = P Q</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P ( 0 ) =
P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>lcF</mtext></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( P ) = \mbox{lcoeff} ( Q ) = \mbox{lcF}</annotation></semantics></math>.
</p><ol class="enumerate" type=1><li class="li-enumerate">
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo>=</mo><mi>F</mi><mtext>lcF</mtext></mrow><annotation encoding='application/x-tex'>G = F \mbox{lcF}</annotation></semantics></math>, , <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub><mo>=</mo><mi>G</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0 = G ( 0 ) / P_0</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P = P_0</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q =
  Q_0</annotation></semantics></math>.</li><li class="li-enumerate">Déterminer les deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math> de l’identité de Bézout
(tels que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mi>U</mi><mo>+</mo><msub><mi>Q</mi> <mn>0</mn></msub><mi>V</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>P_0 U + Q_0 V = d</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> est un entier).</li><li class="li-enumerate">Boucle infinie avec un compteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> initialisé à 1, incrémenté de 1 à
chaque itération
<ul class="itemize"><li class="li-itemize">
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>&gt;</mi><msub><mtext>degre</mtext> <mrow><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>k &amp;gt; \mbox{degre}_{X_2, \ldots ., X_n} ( G )</annotation></semantics></math>, renvoyer false.</li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>, renvoyer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo stretchy="false">/</mo><mi>P</mi></mrow><annotation encoding='application/x-tex'>G / P</annotation></semantics></math>.</li><li class="li-itemize">Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo>=</mo><mi>G</mi><mo>&minus;</mo><mi>P</mi><mi>Q</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>H = G &#x2d; P Q = O ( k )</annotation></semantics></math>. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>=</mo><mi>U</mi><mfrac><mi>H</mi><mi>d</mi></mfrac></mrow><annotation encoding='application/x-tex'>u = U \frac{H}{d}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mi>V</mi><mfrac><mi>H</mi><mi>d</mi></mfrac></mrow><annotation encoding='application/x-tex'>v = V
    \frac{H}{d}</annotation></semantics></math>, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mi>u</mi><mo>+</mo><msub><mi>Q</mi> <mn>0</mn></msub><mi>v</mi><mo>=</mo><mi>H</mi></mrow><annotation encoding='application/x-tex'>P_0 u + Q_0 v = H</annotation></semantics></math></li><li class="li-itemize">Remplacer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> par le reste de la division euclidienne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math> par le reste de la division euclidienne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math>. La
somme des deux quotients est égale au quotient euclidien de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0
    Q_0</annotation></semantics></math>, c’est-à-dire au coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> divisé par le produit
des coefficients dominants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0</annotation></semantics></math> (qui sont égaux) donc on a
l’égalité:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mi>u</mi><mo>+</mo><msub><mi>Q</mi> <mn>0</mn></msub><mi>v</mi><mo>=</mo><mi>H</mi><mo>&minus;</mo><mfrac><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow></mfrac><msub><mi>P</mi> <mn>0</mn></msub><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'> P_0 u + Q_0 v = H &#x2d; \frac{\mbox{lcoeff} ( H )}{\mbox{lcoeff} ( P_0
       )^2} P_0 Q_0  </annotation></semantics></math>
</li><li class="li-itemize">Soit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>=</mo><mo stretchy="false">(</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\alpha = ( \mbox{lcoeff} ( F ) &#x2d; \mbox{lcoeff} ( P )) / \mbox{lcoeff} (
    P_0 )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi><mo>=</mo><mo stretchy="false">(</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\beta = ( \mbox{lcoeff} ( F ) &#x2d; \mbox{lcoeff} ( Q )) /
    \mbox{lcoeff} ( P_0 )</annotation></semantics></math>.
On ajoute <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\alpha P_0</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>, ainsi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>P</mi> <mrow/></msub><mo>+</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( P_{} + v ) =
    \mbox{lcoeff} ( F ) + O ( k + 1 )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\beta Q_0</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math>, ainsi
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>Q</mi> <mrow/></msub><mo>+</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( Q_{} + u ) = \mbox{lcoeff} ( F ) + O ( k + 1 )</annotation></semantics></math> <p>Remarque: on montre alors que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><mo>=</mo><mfrac><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><msub><mi>Q</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\alpha + \beta = \frac{\mbox{lcoeff} ( H
    )}{\mbox{lcoeff} ( P_0 Q_0 )} + O ( k + 1 )</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mi>u</mi><mo>+</mo><msub><mi>Q</mi> <mn>0</mn></msub><mi>v</mi><mo>=</mo><mi>H</mi><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_0 u + Q_0 v = H + O (
    k + 1 )</annotation></semantics></math> en utilisant les propriétés :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \mbox{lcoeff} ( F ) = \mbox{lcoeff} ( P ) + O ( k ) =
       \mbox{lcoeff} ( Q ) + O ( k ) = \mbox{lcoeff} ( P_0 ) + O ( 1 )  </annotation></semantics></math>
</p></li><li class="li-itemize">Réduire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> en éliminant les termes de degré strictement
supérieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>2</mn></msub><mo>,</mo><mi>&hellip;</mi><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_2, \ldots ., X_n</annotation></semantics></math>. S’il reste un
coefficient non entier, renvoyer false</li><li class="li-itemize">Remplacer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>+</mo><mi>v</mi></mrow><annotation encoding='application/x-tex'>P + v</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>+</mo><mi>u</mi></mrow><annotation encoding='application/x-tex'>Q + u</annotation></semantics></math>, passer à l’itération
suivante.
</li></ul>
</li></ol><p>
<span style="font-weight:bold">Exemple</span>:</p><p><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>y</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>y</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi><mi>y</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>F = (( x + 1 ) y + x^2 + 1 ) ( y^2 + x y + 1 ), G = (( x + 1 ) y + x^2 + 1 )
( y^2 &#x2d; x y &#x2d; 1 )</annotation></semantics></math></p><p>On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>F ( 0, y ) = ( y + 1 ) ( y^2 + 1 )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>G ( 0, y ) = ( y + 1 ) ( y^2 &#x2d; 1
)</annotation></semantics></math>, le pgcd est donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D_b = ( y + 1 )</annotation></semantics></math>. On remarque que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mi>b</mi></msub></mrow><annotation encoding='application/x-tex'>D_b</annotation></semantics></math> est premier avec
le cofacteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> mais pas avec le cofacteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>. Si on évalue en un
autre point, par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x = 1</annotation></semantics></math>, on trouve un pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>D</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>D_1</annotation></semantics></math> de même degré, donc
0 est vraissemblablement un bon point d’évaluation (ici on en est sûr puisque
le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> se calcule à vue...). On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff} ( F ) = x +
1</annotation></semantics></math>, on va donc lifter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>y</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mi>Q</mi></mrow><annotation encoding='application/x-tex'>G = (( x + 1 ) y + x^2 + 1 ) ( y^2 + x y + 1 ) ( x + 1
) = P Q</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_0 = ( y + 1 )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q_0 = ( y^2 + 1 )</annotation></semantics></math>.</p><p>On calcule les polynômes de l’identité de Bézout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>U = ( 1 &#x2d; y )</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>V = 1</annotation></semantics></math>
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>d = 2</annotation></semantics></math>, puis à l’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k = 1</annotation></semantics></math>:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>H</mi><mo>=</mo><mi>G</mi><mo>&minus;</mo><msub><mi>P</mi> <mn>0</mn></msub><msub><mi>Q</mi> <mn>0</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><msup><mi>y</mi> <mn>3</mn></msup><mo>+</mo><mn>2</mn><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> H = G &#x2d; P_0 Q_0 = ( 2 y^3 + 2 y^2 + 3 y + 1 ) x + O ( 2 )  </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>=</mo><mtext>reste</mtext><mo stretchy="false">(</mo><mi>U</mi><mi>H</mi><mo stretchy="false">/</mo><mi>d</mi><mo>,</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>u = \mbox{reste} ( U H / d, Q_0 ) = x y</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mtext>reste</mtext><mo stretchy="false">(</mo><mi>V</mi><mi>H</mi><mo stretchy="false">/</mo><mi>d</mi><mo>,</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>v = \mbox{reste} ( V H / d,
P_0 ) = &#x2d; x</annotation></semantics></math>.</p><p>Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>=</mo><mi>x</mi><mi>y</mi><mo>+</mo><mi>&alpha;</mi><msub><mi>Q</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1 = x y + \alpha Q_0</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>\alpha = ( x + 1 &#x2d; 1 ) / \mbox{lcoeff} (
P_0 ) = x</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>x</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>Q_0 + Q_1 = ( y^2 + 1 ) ( x + 1 ) + x y</annotation></semantics></math>. De
même, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><mo>+</mo><mi>&beta;</mi><msub><mi>P</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P_1 = &#x2d; x + \beta P_0</annotation></semantics></math>, avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mtext>lcoeff</mtext><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>\beta = ( x + 1 &#x2d; 1 ) / \mbox{lcoeff} (
P_0 ) = x</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>P_0 + P_1 = ( y + 1 ) ( x + 1 ) &#x2d; x</annotation></semantics></math>. On remarque que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>P_0 +
P_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_0 + Q_1</annotation></semantics></math> sont bien à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O ( 2 )</annotation></semantics></math> près les facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>F
\mbox{lcoeff} ( F )</annotation></semantics></math>:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>y</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>=</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>,</mo><mspace width="mediummathspace"/><mi>Q</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> P = ( x + 1 ) y + x^2 + 1 = P_0 + P_1 + O ( 2 ), \ Q = ( x +
   1 ) ( y^2 + x y + 1 ) = Q_0 + Q_1 + O ( 2 )  </annotation></semantics></math>
Une deuxième itération est nécessaire. On calcule
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>H</mi><mo>=</mo><mi>G</mi><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><msup><mi>y</mi> <mn>2</mn></msup><mo>+</mo><mi>y</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> H = G &#x2d; ( P_0 + P_1 ) ( Q_0 + Q_1 ) = ( 2 y^2 + y + 1 ) x^2 + O ( 3
   )  </annotation></semantics></math>
puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>reste</mtext><mo stretchy="false">(</mo><mi>U</mi><mi>H</mi><mo stretchy="false">/</mo><mi>d</mi><mo>,</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi><msup><mi>x</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\mbox{reste} ( U H / d, Q_0 ) = y x^2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>reste</mtext><mo stretchy="false">(</mo><mi>V</mi><mi>H</mi><mo stretchy="false">/</mo><mi>d</mi><mo>,</mo><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\mbox{reste} ( V H / d, P_0 )
= x^2</annotation></semantics></math>. Ici les coefficients <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\beta</annotation></semantics></math> sont nuls car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>lcoeff</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{lcoeff}
( F )</annotation></semantics></math> n’a pas de partie homogène de degré 2. On trouve alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>P</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>P = P_0 + P_1 +
P_2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><msub><mi>Q</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>Q</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>Q = Q_0 + Q_1 + Q_2</annotation></semantics></math>. Pour calculer le pgcd, il suffit de calculer la
partie primitive de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> vu comme polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>, ici c’est encore <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> car le
contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est 1 (remarque: pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> le contenu est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x + 1</annotation></semantics></math>).<br>
On trouve donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> comme pgcd.</p>
<!--TOC section id="sec54" Quel algorithme choisir?-->
<h2 id="sec54" class="section">5.4  Quel algorithme choisir?</h2><!--SEC END --><p>Il est toujours judicieux de faire une évaluation en quelques <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n &#x2d; 1</annotation></semantics></math> uplets
pour traquer les pgcd triviaux. (E)EZGCD sera efficace si (0,...,0) est un
point de bonne évaluation et si le nombre de remontées nécessaires pour le
lemme de Hensel est petit donc pour les pgcd de petit degré, GCDMOD est aussi
efficace si le degré du pgcd est petit. Le sous-résultant est efficace pour
les pgcd de grand degré car il y a alors peu de divisions euclidiennes à
effectuer et les coefficients n’ont pas trop le temps de croitre. SPMOD est
intéressant pour les polynômes creux de pgcd non trivial creux. GCDHEU est
intéressant pour les problèmes relativement petits.</p><p>Avec des machines multiprocesseurs, on a probablement intérêt à lancer en
parallèle plusieurs algorithmes et à s’arrêter dès que l’un deux recontre le
succès.</p>
<!--TOC section id="sec55" Pour en savoir plus.-->
<h2 id="sec55" class="section">5.5  Pour en savoir plus.</h2><!--SEC END --><p>
Parmi les références citées dans le premier article, ce sont les livres de
Knuth, H. Cohen, et Davenport-Siret-Tournier qui traitent des algorithmes de
pgcd. On peut bien sûr consulter le source de son système de calcul formel
lorsqu’il est disponible :
</p><ul class="itemize"><li class="li-itemize">
pour MuPAD sur un système Unix, depuis le
répertoire d’installation de MuPAD (en général <span style="font-family:monospace">/usr/local/MuPAD</span>)
après avoir désarchivé le fichier <span style="font-family:monospace">lib.tar</span> du répertoire <span style="font-family:monospace">share/lib</span> 
par la commande <br>
<span style="font-family:monospace">cd share/lib &amp;&amp; tar xvf lib.tar</span><br>
on trouve les algorithmes de calcul de PGCD dans le répertoire <br>
<span style="font-family:monospace">share/lib/lib/POLYLIB/GCD</span>
</li><li class="li-itemize">Pour l’algorithme EZGCD, je me suis inspiré de l’implémentation de 
Singular (logiciel libre disponible à <span style="font-family:monospace">www.singular.uni-kl.de</span>)
</li></ul><p>
Sur le web on trouve quelques articles en lignes sur le
sujet en cherchant les mots clefs GCDHEU, EZGCD, SPMOD sur un moteur de 
recherche, il y a par exemple une description un peu différente du pgcd
heuristique sur:<br>
<span style="font-family:monospace">www.inf.ethz.ch/personal/gonnet/CAII/HeuristicAlgorithms/node1.html</span><br>
et un article de comparaison de ces algorithmes 
par Fateman et Liao (dont la référence bibliographique est
Evaluation of the heuristic polynomial GCD.
in: ISSAC pages 240–247, 1995). Quelques autres références :
</p><ul class="itemize"><li class="li-itemize">
K.O.Geddes et al "Alg. for Computer Algebra", Kluwer 1992.
</li><li class="li-itemize">pour GCDHEU Char, Geddes, Gonnet, 
Gcdheu: Heuristic polynomial gcd algorithm based on integer gcd computation,
in: Journal of Symbolic Computation, 7:31–48, 1989.
</li><li class="li-itemize">pour SPMOD "Probabilistic Algorithms for Sparse Polynomials",
in: Symbolic &amp; Algebraic Comp. (Ed E.W.Ng), Springer 1979, pp216,
</li></ul>
<!--TOC chapter id="sec56" Le résultant-->
</html>
