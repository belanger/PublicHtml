<!DOCTYPE html>
<html >
<head>
<h1 id="sec158" class="chapter">Chapitre 17  Factorisation des entiers et primalité.</h1><!--SEC END --><p> <a id="sec:ifactor"></a>
<a id="hevea_default186"></a>
Les principaux algorithmes utilisés dans Xcas sont les suivants :
</p><ul class="itemize"><li class="li-itemize">
la division : pour les nombres premiers plus petits que 10000,
stockés dans une table. Cela permet de factoriser les entiers
plus petits que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>10</mn> <mn>10</mn></msup></mrow><annotation encoding='application/x-tex'>10^{10}</annotation></semantics></math> et de détecter les premiers, on teste
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> dans la table tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>k</mi> <mn>2</mn></msup><mo>&leq;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>k^2\leq N</annotation></semantics></math>.
Cela permet la factorisation partielle des entiers plus grands.
Le temps d’exécution est proportionnel au nombre de premiers
dans la table plus petits que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>N</mi></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{N}</annotation></semantics></math>, multiplié par un facteur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(N)</annotation></semantics></math> pour la factorisation partielle.
</li><li class="li-itemize">Le <span style="font-weight:bold">crible</span> d’Eratosthène<a id="hevea_default187"></a> permet de trouver la liste des premiers
plus petits qu’une valeur donnée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. On écrit tous les entiers dans
une table, on barre les multiples de 2, puis les multiples du premier
entier non barré (qui est premier), puis etc. et on s’arrête
lorsque le premier entier non barré au carré est strictement plus
grand que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>.
On montre facilement que la complexité de <code>crible(n)</code> est
celle du nombre de cases que l’on barre dans la boucle 
<code>for (j:=p*p;j&lt;=n;j+=p)</code>
elle est majorée par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac><mfrac><mi>n</mi><mn>3</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mn>5</mn></mfrac><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mfrac><mi>n</mi><mrow><msub><mi>p</mi> <mi>n</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{n}{2}\frac{n}{3}+\frac{n}{5}+...+\frac{n}{p_n} </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>p_n</annotation></semantics></math> est le dernier nombre premier inférieur ou égal à
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{n}</annotation></semantics></math>, que l’on peut facilement majorer par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n \ln(n))</annotation></semantics></math> puisque
la somme des inverses des premiers est inférieure à la somme des
inverses jusque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{n}</annotation></semantics></math>. Une analyse plus fine donne une majoration
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n \ln(\ln(n)))</annotation></semantics></math>, en pratique l’obstacle principal au crible reste la taille
mémoire nécessaire au calcul qui empêche de dépasser des
valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> de l’ordre du milliard.
</li><li class="li-itemize">le test de pseudo-primalité de <span style="font-weight:bold">Miller-Rabin</span><a id="hevea_default188"></a><a id="hevea_default189"></a> (voir
le manuel de programmation de Xcas) : effectué
pour 20 bases <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math>, il donne en cas de réussite la primalité
pour les entiers plus petits que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>10</mn> <mn>14</mn></msup></mrow><annotation encoding='application/x-tex'>10^{14}</annotation></semantics></math>, au-delà le nombre
est très probablement premier (moins de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><msup><mn>4</mn> <mn>20</mn></msup></mrow><annotation encoding='application/x-tex'>1/4^{20}</annotation></semantics></math> malchance
d’avoir un non premier au sens où le nombre de bases <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>&lt;</mi><mi>p</mi></mrow><annotation encoding='application/x-tex'>a&amp;lt;p</annotation></semantics></math> qui passent
le test alors que le nombre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> n’est pas premier est plus petit
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo stretchy="false">/</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>p/4</annotation></semantics></math>). Si on veut certifier qu’un nombre est premier, on peut 
utiliser le test de Pocklington (voir la section
dédiée) ou le test APRCL via PARI.
</li><li class="li-itemize">la méthode <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math> de Pollard qui permet de trouver
les“petits” facteurs d’un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> (plus petits que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>10</mn> <mn>10</mn></msup></mrow><annotation encoding='application/x-tex'>10^{10}</annotation></semantics></math> environ). Cette méthode est détaillée plus bas.
La commande <code>ifactor</code> de PARI permet de détecter
des “petits” facteurs de plus grande taille par la méthode
des courbes elliptiques (ECM, cf. Cohen par exemple). Pollard-<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math>
et ECM sont des méthodes de factorisation de type I, dont le
temps d’exécution est fonction de la taille du plus petit facteur
de l’entier à factoriser (supposé non premier).
</li><li class="li-itemize">le crible quadratique qui permet de factoriser
en un temps raisonnable les entiers jusqu’à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>10</mn> <mn>70</mn></msup></mrow><annotation encoding='application/x-tex'>10^{70}</annotation></semantics></math> environ.
Une esquisse de cette méthode est présentée plus bas.
Cette méthode est dite de type II, son temps d’exécution
est fonction de la taille de l’entier.
</li></ul><pre class="verbatim">crible(n):={
  local tab,prem,p;
  tab:=seq(j,j,0,n);
  prem:=[];
  tab[0]=&lt;0; tab[1]=&lt;0;
  p:=2;
  while (p*p&lt;=n) {
    for (j:=p*p;j&lt;=n;j+=p){
      tab[j]=&lt;0;
    }
    p:=p+1;
    //afficher(tab);
    while ((p*p&lt;=n) and (tab[p]==0)) {
      p:=p+1;
    } 
  }
  for (j:=2;j&lt;=n;j++) {
    if (tab[j]!=0) { 
      prem:=append(prem,j);
    }
  } 
  return(prem);
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>



<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">crible(100)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC section id="sec159" Le test de primalité de Pocklington.-->
<h2 id="sec159" class="section">17.1  Le test de primalité de Pocklington.</h2><!--SEC END --><p><a id="hevea_default190"></a> <a id="hevea_default191"></a>
</p><div class="theorem"><span style="font-weight:bold">Théorème 33</span>  <em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>N&amp;gt;1</annotation></semantics></math><em> entier. S’il existe deux entiers </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math><em> tels que
</em><ul class="itemize"><li class="li-itemize"><em>
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math><em> est un facteur premier de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>N&#x2d;1</annotation></semantics></math><em> plus grand que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>N</mi></msqrt><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\sqrt{N}&#x2d;1</annotation></semantics></math><em>,
</em></li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>N</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a^{N&#x2d;1}=1 \pmod N</annotation></semantics></math><em>
</em></li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>q</mi></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a^{(N&#x2d;1)/q}&#x2d;1</annotation></semantics></math><em> est premier avec </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math><em>
</em></li></ul><em>
alors </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math><em> est premier.
</em></div><p>
Preuve : Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> n’est pas premier, alors il a un facteur premier
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>&leq;</mo><msqrt><mi>N</mi></msqrt></mrow><annotation encoding='application/x-tex'>p\leq \sqrt{N}</annotation></semantics></math>. Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p&#x2d;1</annotation></semantics></math> sont premiers entre eux
(car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> est premier et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mi>&gt;</mi><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>q&amp;gt;p&#x2d;1</annotation></semantics></math>). Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math> l’inverse de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> modulo
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p&#x2d;1</annotation></semantics></math>. Alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo>=</mo><msup><mi>a</mi> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>1=a^{N&#x2d;1} \pmod p</annotation></semantics></math> car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>. Donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>1</mn><mo>=</mo><msup><mi>a</mi> <mrow><mi>u</mi><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow><mo>=</mo><msup><mrow><mo>(</mo><msup><mi>a</mi> <mrow><mi>u</mi><mi>q</mi></mrow></msup><mo>)</mo></mrow> <mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>q</mi></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow><mo>=</mo><msup><mi>a</mi> <mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>q</mi></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>1=a^{u(N&#x2d;1)} \pmod p = \left(a^{uq}\right)^{(N&#x2d;1)/q} \pmod p =
a^{(N&#x2d;1)/q} \pmod p </annotation></semantics></math>
d’après le petit théorème de Fermat. Ceci contredit 
le fait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>q</mi></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a^{(N&#x2d;1)/q}&#x2d;1</annotation></semantics></math> soit premier avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>.</p><p>Le couple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(a,q)</annotation></semantics></math> est alors un 
<span style="font-weight:bold">certificat de primalité</span><a id="hevea_default192"></a><a id="hevea_default193"></a> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>.
Le problème c’est que trouver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>,</mo><mi>q</mi></mrow><annotation encoding='application/x-tex'>a,q</annotation></semantics></math> peut être très difficile
voire impossible. Mais il existe une généralisation de ce
théorème qui est plus facile à réaliser
</p><div class="theorem"><span style="font-weight:bold">Théorème 34</span>  <em>
Supposons que l’on sache factoriser </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo>=</mo><mi>A</mi><mi>B</mi></mrow><annotation encoding='application/x-tex'>N&#x2d;1=AB</annotation></semantics></math><em> comme produit de deux entiers
premiers entre eux avec </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>&gt;</mi><msqrt><mi>N</mi></msqrt></mrow><annotation encoding='application/x-tex'>A&amp;gt;\sqrt{N}</annotation></semantics></math><em> dont la factorisation en produit
de facteurs premiers est connue. Si pour tout facteur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math><em> de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math><em> il
existe un entier </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>a_p</annotation></semantics></math><em> tel que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>a</mi> <mi>p</mi> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>N</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a_p^{N&#x2d;1}=1 \pmod N</annotation></semantics></math><em> et
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>a</mi> <mi>p</mi> <mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>p</mi></mrow></msubsup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a_p^{(N&#x2d;1)/p}&#x2d;1</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math><em> sont premiers entre eux, alors </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math><em> est premier.
</em></div><p>
Preuve : soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> un facteur premier de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>. 
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> premier divisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>e</mi></msup></mrow><annotation encoding='application/x-tex'>p^e</annotation></semantics></math> la plus grande
puissance de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> divisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>. On va montrer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>e</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>v=1 \pmod{p^e}</annotation></semantics></math>.
Par le lemme chinois on en déduira <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>A</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>v=1 \pmod A</annotation></semantics></math> puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mi>&gt;</mi><msqrt><mi>N</mi></msqrt></mrow><annotation encoding='application/x-tex'>v&amp;gt;\sqrt{N}</annotation></semantics></math>
ce qui est impossible pour au moins un facteur premier de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>.<br>
Montrons donc que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>e</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>v=1 \pmod{p^e}</annotation></semantics></math>. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><msubsup><mi>a</mi> <mi>p</mi> <mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><msup><mi>p</mi> <mi>e</mi></msup></mrow></msubsup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>v</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>b=a_p^{(N&#x2d;1)/p^e} \pmod v</annotation></semantics></math>. Alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>b</mi> <mrow><msup><mi>p</mi> <mi>e</mi></msup></mrow></msup><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>v</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>b^{p^e}=1 \pmod v</annotation></semantics></math>
puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>b</mi> <mrow><msup><mi>p</mi> <mrow><mi>e</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></msup><mo>=</mo><msubsup><mi>a</mi> <mi>p</mi> <mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>p</mi></mrow></msubsup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>v</mi><mo rspace="mediummathspace">)</mo></mrow><mo>&ne;</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>v</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>b^{p^{e&#x2d;1}} = a_p^{(N&#x2d;1)/p} \pmod v \neq 1
\pmod v</annotation></semantics></math> puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>a</mi> <mi>p</mi> <mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>p</mi></mrow></msubsup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a_p^{(N&#x2d;1)/p}&#x2d;1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> sont premiers entre eux.
Donc l’ordre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>e</mi></msup></mrow><annotation encoding='application/x-tex'>p^e</annotation></semantics></math>, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>e</mi></msup></mrow><annotation encoding='application/x-tex'>p^e</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>v&#x2d;1</annotation></semantics></math> CQFD.</p><p>Ce test nécessite de savoir factoriser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>N&#x2d;1</annotation></semantics></math>, au moins
partiellement. Pour des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> grands, cela peut nécessiter
de certifier que les facteurs obtenus sont eux-même premiers,
ce qui peut nécessiter une sorte d’appel récursif du test. C’est
l’étape difficile, la recherche des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>a_p</annotation></semantics></math> n’est pas un blocage en pratique.</p>
<!--TOC section id="sec160" La méthode <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math> de Pollard-->
<h2 id="sec160" class="section">17.2  La méthode <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math> de Pollard</h2><!--SEC END --><p> <a id="hevea_default194"></a>
<span style="font-weight:bold">Théorème des anniversaires </span>: la probabilité que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> éléments pris au
hasard parmi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> soient distincts 2 à 2 pour 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mi>a</mi><msqrt><mo stretchy="false">(</mo></msqrt><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>n=a \sqrt(N))</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&rightarrow;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>N\rightarrow \infty</annotation></semantics></math> 
est équivalente à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>a</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{&#x2d;a^2/2}</annotation></semantics></math>, 
et peut donc être rendue arbitrairement petite.</p><p>En effet, cette probabilité vaut
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>=</mo><mn>1</mn><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mfrac><mn>2</mn><mi>N</mi></mfrac><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mfrac><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><mi>N</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P=1(1&#x2d;\frac1N)(1&#x2d;\frac2N)...(1&#x2d;\frac{n&#x2d;1}{N}) </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mo>&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mfrac><mi>k</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;\ln(P)=\sum_{k=0}^{n&#x2d;1} &#x2d;\ln(1&#x2d;\frac{k}{N})   </annotation></semantics></math>
on reconnait une méthode de rectangles pour approcher <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&Integral;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\int
&#x2d;\ln(1&#x2d;t)</annotation></semantics></math>, fonction croissante positive sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mo>+</mo></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^+</annotation></semantics></math> d’où l’encadrement
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msubsup><mo>&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mfrac><mi>t</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo><mspace width="thinmathspace"/><mi>d</mi><mi>t</mi><mo>&leq;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>&leq;</mo><msubsup><mo>&Integral;</mo> <mn>1</mn> <mi>n</mi></msubsup><mo>&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mfrac><mi>t</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo><mspace width="thinmathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int_{0}^{n&#x2d;1} &#x2d;\ln(1&#x2d;\frac{t}{N}) \, dt \leq &#x2d;\ln(P) \leq
\int_{1}^{n} &#x2d;\ln(1&#x2d;\frac{t}{N})  \, dt  </annotation></semantics></math>
On intègre par parties, en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>=</mo><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>&#x2d;1=(N&#x2d;t)&apos;</annotation></semantics></math> 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo>&Integral;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mfrac><mi>t</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo><mspace width="thinmathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mi>t</mi><mo stretchy="false">)</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mfrac><mi>t</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo><mo>+</mo><mo>&Integral;</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mi>t</mi><mo stretchy="false">)</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mfrac><mi>t</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo><mo>+</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int &#x2d;\ln(1&#x2d;\frac{t}{N}) \, dt 
= (N&#x2d;t) \ln(1&#x2d;\frac{t}{N}) + \int \ dt 
= (N&#x2d;t) \ln(1&#x2d;\frac{t}{N}) + t  </annotation></semantics></math>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo stretchy="false">/</mo><mi>N</mi><mo>=</mo><mi>o</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>t/N=o(1)</annotation></semantics></math> la primitive vaut :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>&minus;</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mi>t</mi><mi>N</mi></mfrac><mo>&minus;</mo><mfrac><mrow><msup><mi>t</mi> <mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>N</mi> <mn>2</mn></msup></mrow></mfrac><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mfrac><mrow><msup><mi>t</mi> <mn>3</mn></msup></mrow><mrow><msup><mi>N</mi> <mn>3</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><mo>+</mo><mi>t</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><msup><mi>t</mi> <mn>2</mn></msup></mrow><mrow><mn>2</mn><mi>N</mi></mrow></mfrac><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mfrac><mrow><msup><mi>t</mi> <mn>3</mn></msup></mrow><mrow><msup><mi>N</mi> <mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(N&#x2d;t)(&#x2d;\frac{t}{N}&#x2d;\frac{t^2}{2N^2}+O(\frac{t^3}{N^3})+t
=&#x2d;\frac{t^2}{2N} + O(\frac{t^3}{N^2})  </annotation></semantics></math>
Donc pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mi>a</mi><msqrt><mi>N</mi></msqrt></mrow><annotation encoding='application/x-tex'>n=a\sqrt{N}</annotation></semantics></math>, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><msup><mi>a</mi> <mn>2</mn></msup></mrow><mn>2</mn></mfrac><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><msqrt><mi>N</mi></msqrt> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mo>&leq;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mfrac><mrow><msup><mi>a</mi> <mn>2</mn></msup></mrow><mn>2</mn></mfrac><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><msqrt><mi>N</mi></msqrt> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\frac{a^2}{2}+ O(\sqrt{N}^{&#x2d;1})
\leq &#x2d;\ln(P) 
\leq \frac{a^2}{2}+ O(\sqrt{N}^{&#x2d;1}) </annotation></semantics></math>
d’où le résultat annoncé.</p><p><span style="font-weight:bold">Application </span>: si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est composé, on prend des entiers modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
générés par une suite 
récurrente <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x_{k+1}=f(x_k) \pmod n</annotation></semantics></math>, 
on espère qu’ils ont de bonne propriétés de répartition, 
et on regarde s’ils sont distincts modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> est 
le plus petit facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. Il suffira d’en générer 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>p</mi></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(\sqrt{p})</annotation></semantics></math> pour avoir une bonne proba d’en trouver 
deux égaux modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>. 
Comme on ne connait pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>, le test d’égalité modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> 
se fait en calculant le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> et
de la différence des 2 entiers modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>,
qui doit être non trivial. 
La fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> peut par exemple être <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&rightarrow;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x \rightarrow x^2+1</annotation></semantics></math> 
(ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^2&#x2d;1</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>x^2+3</annotation></semantics></math>)<sup><a id="text31" href="#note31">1</a></sup>. 
On ne teste pas toutes les différences de paires d’entiers générés,
car ce serait trop long,
mais les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>x_{2k}&#x2d;x_k</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>k=1,2,...</annotation></semantics></math> 
ce qui suffit car la suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>x_k</annotation></semantics></math> est ultimement périodique 
(le dessin d’une suite ultimement périodique est un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math>
d’où la méthode tire son nom). 
Le calcul nécessite donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msqrt><mi>p</mi></msqrt><mo>*</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(\sqrt{p}*\ln(n)^2)</annotation></semantics></math> opérations 
(ce qui est toujours mieux que la division triviale car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>&leq;</mo><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>p \leq \sqrt{n}</annotation></semantics></math>).</p>
<!--TOC section id="sec161" Le crible quadratique-->
<h2 id="sec161" class="section">17.3  Le crible quadratique</h2><!--SEC END --><p><a id="hevea_default195"></a>
<a id="hevea_default196"></a>
On cherche des relations <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>=</mo><msup><mi>y</mi> <mn>2</mn></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>N</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x^2=y^2 \pmod N</annotation></semantics></math>, en espérant trouver un
facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> en calculant pgcd<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>y</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x&#x2d;y,N)</annotation></semantics></math>.
Problème trop difficile, à la place on va essayer de factoriser sur
une base de "petits" nombre premiers des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>x</mi> <mi>i</mi> <mn>2</mn></msubsup><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>x_i^2&#x2d;N</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> 
proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>N</mi></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{N}</annotation></semantics></math> (nombre friable). 
La taille de la base dépend de la taille de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>. 
La recherche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>x^2</annotation></semantics></math> se fait par produit de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math> 
tel qu’il n’apparaisse que des carrés de la base des petits 
nombres premiers, ce qui s’obtient en résolvant 
un gros système linéaire à coefficient dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>2</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/2\mathbb{Z}</annotation></semantics></math>.
Pour trouver les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math> on utilise un crible: 
sachant que si on a une solution de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>N</mi><mo>=</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x^2&#x2d;N=0 \pmod p</annotation></semantics></math>, 
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>+</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>x+p</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>+</mo><mn>2</mn><mi>p</mi></mrow><annotation encoding='application/x-tex'>x+2p</annotation></semantics></math>, etc. le seront aussi, on a facilement les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> 
tels que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>x^2&#x2d;N</annotation></semantics></math> est divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> à partir des 2 racines carrées 
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> si elles existent 
(sinon on ne met pas ces racines dans la base de petits premiers!). 
Le crible consiste à incrémenter de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>log</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\log(p)</annotation></semantics></math> 
tous les éléments d’un tableau dont l’indice correspond 
à un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>x^2&#x2d;N</annotation></semantics></math> est divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>. 
Lorsqu’on a parcouru tous les premiers de la base de nombres premiers, 
on regarde dans le tableau les valeurs assez grandes 
vont correspondre à des possibilités d’entiers friables, 
on factorise alors les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>x</mi> <mi>i</mi> <mn>2</mn></msubsup><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>x_i^2&#x2d;N</annotation></semantics></math> correspondants pour avoir des relations. 
Dès qu’on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>+une marge de sécurité (par exemple 20 ou 50) 
relations où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est le nombre de premiers de la base 
on est sur qu’on trouvera une vingtaine ou une cinquantaine de
relations 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>=</mo><msup><mi>y</mi> <mn>2</mn></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>N</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x^2=y^2 \pmod N</annotation></semantics></math>. 
Comme chaque relation a une chance sur 2 de donner un facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>, 
on pourra factoriser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>, sauf malchance vraiment exceptionnelle!</p>
<!--TOC subsection id="sec162" Recherche de racine carrée modulo p-->
<h3 id="sec162" class="subsection">17.3.1  Recherche de racine carrée modulo p</h3><!--SEC END --><p><a id="hevea_default197"></a>
Pour trouver les solutions <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>x^2&#x2d;N</annotation></semantics></math> divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>, il
faut calculer les racines carrées de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>. On procède
comme suit :
</p><ul class="itemize"><li class="li-itemize">
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>p=2</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>N</mi></msqrt><mo>=</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>\sqrt{N}=N</annotation></semantics></math>
</li><li class="li-itemize">si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>4</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>p+1=0 \pmod 4</annotation></semantics></math>, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> est un carré alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>N</mi> <mrow><mo stretchy="false">(</mo><mi>p</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow></msup><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>N^{(p&#x2d;1)/2}=1 \pmod p</annotation></semantics></math> 
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&pm;</mo><msup><mi>N</mi> <mrow><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>4</mn></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>\pm N^{(p+1)/4} \pmod p</annotation></semantics></math> est la racine cherchée (calcul
effectué par l’algorithme de la puissance rapide).
</li><li class="li-itemize">sinon on cherche le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>x^2&#x2d;N</annotation></semantics></math> avec
powmod<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>r</mi><mo>,</mo><mo stretchy="false">(</mo><mi>p</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><mi>p</mi><mo>,</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x+r,(p&#x2d;1)/2,p,x^2&#x2d;N)</annotation></semantics></math> 
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> est aléatoire, il y a une chance sur 2 que le pgcd soit de degré 1.<br>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> est assez petit (disons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mi>&lt;</mi><msqrt><mrow><msup><mn>2</mn> <mn>31</mn></msup></mrow></msqrt></mrow><annotation encoding='application/x-tex'>p&amp;lt; \sqrt{2^{31}}</annotation></semantics></math>), il est plus rapide de
tester les carrés mod <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mo stretchy="false">(</mo><mi>p</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>k=1,2,3, ..., (p&#x2d;1)/2</annotation></semantics></math>. Comme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo>=</mo><msup><mi>k</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mo>*</mo><mi>k</mi><mo>+</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>(k+1)^2=k^2+2*k+1 \pmod p</annotation></semantics></math>, cela se résume à faire un shift (*2) une
addition, un test si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&geq;</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>\geq p</annotation></semantics></math> et dans ce cas une soustraction, puis un test
d’égalité avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>, le tout avec des entiers courts (32 bits) ce qui est
très rapide.
</li></ul>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note31" href="#text31">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Il n’existe à ma connaissance
pas de résultat sur pourquoi ces choix de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> donnent 
des entiers bien répartis par rapport au hasard</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec163" Factorisation des polynômes.-->
</html>
