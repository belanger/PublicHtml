<!DOCTYPE html>
<html >
<head>
<h1 id="sec218" class="chapter">Chapitre 22  Algèbre linéaire</h1><!--SEC END --><p> <a id="sec:linalg"></a>
On présente ici des algorithmes autour de la résolution exacte
et approchée de systèmes (réduction des matrices sous forme échelonnée) 
et la recherche de valeurs propres et de vecteurs propres 
(diagonalisation et jordanisation des matrices).</p>
<!--TOC section id="sec219" Résolution de systèmes, calcul de déterminant.-->
<h2 id="sec219" class="section">22.1  Résolution de systèmes, calcul de déterminant.</h2><!--SEC END -->
<!--TOC subsection id="sec220" La méthode du pivot de Gauß.-->
<h3 id="sec220" class="subsection">22.1.1  La méthode du pivot de Gauß.</h3><!--SEC END --><p><a id="hevea_default252"></a> <a id="hevea_default253"></a>
</p><ul class="itemize"><li class="li-itemize">
Le pivot : on détermine à partir d’une ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math> 
la ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> où apparait le premier coefficient non nul <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> dans
la colonne à réduire. On échange les lignes
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>. Puis pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mi>&gt;</mi><mi>i</mi></mrow><annotation encoding='application/x-tex'>j&amp;gt;i</annotation></semantics></math> (réduction sous-diagonale)
ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&ne;</mo><mi>i</mi></mrow><annotation encoding='application/x-tex'>j\neq i</annotation></semantics></math> (réduction complète), on effectue l’opération
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub><mo>&leftarrow;</mo><msub><mi>L</mi> <mi>j</mi></msub><mo>&minus;</mo><mfrac><mrow><msub><mi>p</mi> <mi>j</mi></msub></mrow><mi>p</mi></mfrac><msub><mi>L</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>L_j \leftarrow L_j &#x2d; \frac{p_j}{p}L_i</annotation></semantics></math>.<br>
Inconvénient : avec des données exactes de taille non bornée, 
la complexité des coefficients augmente plus vite qu’en choisissant 
le pivot le plus simple possible, (remarque, lorsque les données 
sont approchées, on n’utilise pas non plus cette méthode
pour des raisons de stabilité numérique).
Le domaine d’utilisation naturel concerne donc les coefficients
dans un corps fini (par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math>).
</li><li class="li-itemize">Le pivot partiel. On choisit le meilleur coefficient non nul de la
colonne, où meilleur dépend du type de coefficient : avec des données
exactes, on choisirait le coefficient de taille la plus petite possible,
avec des données approximatives, on choisit
le coefficient de plus grande norme dans la colonne.
Le domaine d’utilisation naturel concerne les coefficients
approchés. Pour les coefficients exacts, on remplacerait la
réduction par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub><mo>&leftarrow;</mo><mi>p</mi><msub><mi>L</mi> <mi>j</mi></msub><mo>&minus;</mo><msub><mi>p</mi> <mi>j</mi></msub><msub><mi>L</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>L_j \leftarrow pL_j &#x2d;p_j L_i</annotation></semantics></math> pour ne pas effectuer
de division. Mais avec cette méthode, la taille des coefficients
augmente de manière exponentielle. On peut améliorer
la taille des coefficients intermédiaires en divisant chaque
ligne par le PGCD de ses coefficients, mais comme pour le
calcul du PGCD par l’algorithme du sous-résultant, il existe
une méthode plus efficace présentée ci-dessous.
</li><li class="li-itemize">La méthode de <span style="font-weight:bold">Bareiss</span> :<a id="hevea_default254"></a> on initialise un coefficient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> à 1.
On remplace l’étape de réduction ci-dessus
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub><mo>&leftarrow;</mo><mo stretchy="false">(</mo><mi>p</mi><msub><mi>L</mi> <mi>j</mi></msub><mo>&minus;</mo><msub><mi>p</mi> <mi>j</mi></msub><msub><mi>L</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>L_j \leftarrow (pL_j &#x2d;p_j L_i)/b</annotation></semantics></math>.
À la fin de l’étape de réduction, on met le coefficient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>
à la valeur du pivot <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>. L’intérêt de la méthode est que la division
se fait sans introduire de fraction (la preuve pour les deux premières
étapes se fait facilement à la main ou avec
un système de calcul formel (cf. infra), pour le cas général, on vérifie
que le déterminant de la matrice de départ
est égal au dernier coefficient sur la diagonale obtenu par
cette méthode de réduction, ce dernier est donc entier, le
même raisonnement fait sur des sous-matrices dont on prend les
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> premières lignes et colonnes et une autre ligne et une autre
colonne montre que tous les coefficients des matrices intermédiaires
sont entiers).
On peut utiliser cette méthode aussi bien pour la réduction
sous-diagonale que pour la réduction complète (les lignes
intervenant dans la combinaison linéaire subissent des 
modifications identiques dans les deux cas).
</li></ul><p>
Vérifions
qu’on n’introduit pas de dénominateur dans la méthode
de Bareiss. Sans
restreindre la généralité, il suffit de le montrer avec une
matrice 3x3 à coefficients symboliques génériques. 
</p><pre class="verbatim">Pivot(M,n,m,r):={ 
 // n ligne du pivot, m colonne, r ligne a modifier
 local COL,j,a,b; 
 COL:=ncols(M);
 a:=M[n,m];
 b:=M[r,m];
 for j from 0 to COL-1 do
   // afficher(j,a,b,n,m,r);
   M[r,j]:=a*M[r,j]-b*M[n,j];
 end_for;
 return(M);
}:; 
M:=matrix(3,3,[[A,B,C],[D,E,F],[G,H,J]]);
M:=Pivot(M,0,0,1); M:=Pivot(M,0,0,2); /* 1ere colonne */
M:=Pivot(M,1,1,2); M:=Pivot(M,1,1,0); /* 2eme colonne */
factor(M[2,2]);
</pre><p>
Ce qui met bien en évidence le facteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mrow><mn>3</mn><mo>,</mo><mn>3</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>M_{3,3}</annotation></semantics></math>.</p>
<!--TOC subsection id="sec221" Le déterminant.-->
<h3 id="sec221" class="subsection">22.1.2  Le déterminant.</h3><!--SEC END --><p><a id="hevea_default255"></a>
On peut bien sûr appliquer les méthodes ci-dessus en tenant compte
des pivots utilisés et du produit des coefficients diagonaux. Dans le cas de 
la méthode de Bareiss, si on effectue la réduction sous-diagonale
uniquement, il n’est pas nécessaire de garder une trace des pivots
et de calculer le produit des coefficients diagonaux,
montrons que la valeur du déterminant est égal au 
dernier coefficient diagonal : en effet si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> désigne la matrice réduite et
que l’on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mrow><mn>0</mn><mo>,</mo><mn>0</mn></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>R_{0,0}=1</annotation></semantics></math>, alors la réduction par la méthode de
Bareiss de la colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math> a pour effet de multiplier le déterminant 
de la matrice initiale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi> <mrow><mi>i</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msub><mi>R</mi> <mrow><mi>i</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>&minus;</mo><mi>i</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>(R_{i,i}/(R_{i&#x2d;1,i&#x2d;1})^{n&#x2d;i}</annotation></semantics></math>. Donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mtext>det</mtext><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mtext>det</mtext><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><msub><mi>R</mi> <mrow><mi>i</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msub><mi>R</mi> <mrow><mi>i</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>i</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>&minus;</mo><mi>i</mi></mrow></msup></mtd></mtr> <mtr><mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>R</mi> <mrow><mi>i</mi><mo>,</mo><mi>i</mi></mrow></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mtext>det</mtext><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>R</mi> <mrow><mi>i</mi><mo>,</mo><mi>i</mi></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>R</mi> <mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mtext>det</mtext><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 \mbox{det}(R)&amp;=&amp;\mbox{det}(M) \ \prod_{i=1}^{n&#x2d;1}
(R_{i,i}/(R_{i&#x2d;1,i&#x2d;1})^{n&#x2d;i} \\
\prod_{i=1}^{n} R_{i,i}&amp;=&amp; \mbox{det}(M) \ \prod_{i=1}^{n&#x2d;1} R_{i,i}  \\
R_{n,n} &amp;=&amp; \mbox{det}(M)
 \end{matrix} </annotation></semantics></math></p><p>Pour les matrices à coefficients entiers, on peut aussi utiliser une
méthode 
<span style="font-weight:bold">modulaire</span><a id="hevea_default256"></a><a id="hevea_default257"></a> :
on calcule une borne à priori sur le déterminant
et on calcule le déterminant modulo suffisamment de petits nombres
premiers pour le reconstruire par les restes chinois. En effet
si le produit des nombres premiers utilisés
est supérieur au double d’un majorant de la valeur absolue du
déterminant, alors le déterminant est le résultat des restes chinois
écrit en représentation symétrique.
L’avantage de cet algorithme est qu’il est simple et facile à paralléliser.</p><p>On utilise souvent la <span style="font-weight:bold">borne d’Hadamard</span><a id="hevea_default258"></a> 
sur le déterminant :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>det</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mn>1</mn><mo>&leq;</mo><mi>i</mi><mo>&leq;</mo><mi>n</mi></mrow></munder><msqrt><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mn>1</mn><mo>&leq;</mo><mi>j</mi><mo>&leq;</mo><mi>n</mi></mrow></munder><mo stretchy="false">&vert;</mo><msub><mi>m</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding='application/x-tex'> |\det(M)| \leq \prod_{1\leq i \leq n} 
\sqrt{\sum_{1\leq j \leq n} |m_{i,j}|^2} </annotation></semantics></math>
Preuve de la borne : on majore le déterminant par le produit des
normes des vecteurs colonnes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>.</p><p>L’algorithme de calcul modulaire du déterminant d’une matrice bornée
de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>4</mn></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^4 \ln(n))</annotation></semantics></math> opérations, en effet 
chaque calcul modulaire
nécessite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3)</annotation></semantics></math> opérations, et il faut <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n\ln(n))</annotation></semantics></math> nombres premiers
d’une taille donnée (par exemple 31 bits)
pour dépasser le double de la borne de Hadamard 
(on montre facilement que la norme
euclidienne d’une colonne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&leq;</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">&Vert;</mo><mi>A</mi><msub><mo stretchy="false">&Vert;</mo> <mn>&infin;</mn></msub></mrow><annotation encoding='application/x-tex'>\leq \sqrt{n}\|A\|_\infty</annotation></semantics></math>,
on en prend la puissance <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>-ième).
C’est meilleur que la méthode de Bareiss, qui est en 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>5</mn></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>O(n^5 \ln(n)^2</annotation></semantics></math> (avec multiplication naïve des entiers). En effet
lors de la réduction de la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième colonne, on manipule des entiers
qui sont des mineurs de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> donc de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(k\ln(k))</annotation></semantics></math>, d’où
une complexité en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>k</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>k</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(\sum_{k=1}^{n&#x2d;1} (n&#x2d;k)^2 (k\ln(k))^2 )</annotation></semantics></math>. Mais
la méthode de Bareiss fonctionne dans bien d’autres situations, par
exemple si les coefficients sont des polynômes.</p><p><span style="font-weight:bold">Remarque</span> :<br>
Si on veut juste prouver l’inversibilité d’une matrice à coefficients
entiers, il suffit
de trouver un nombre premier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> tel que le déterminant de cette matrice modulo
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> soit non nul.</p><p><span style="font-weight:bold">Développement par rapport à une ligne ou une colonne</span><br>
On a tendance à oublier ce type de méthode car le développement
complet du déterminant (faisant intervenir une somme sur toutes les
permutations du groupe symétrique)
nécessite d’effectuer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>!</mo></mrow><annotation encoding='application/x-tex'>n!</annotation></semantics></math> produits
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> coefficients et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>!</mo></mrow><annotation encoding='application/x-tex'>n!</annotation></semantics></math> additions ce qui est gigantesque. Or on peut
"factoriser" une partie des calculs et se ramener à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><msup><mn>.2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>n.2^n</annotation></semantics></math> opérations
élémentaires au lieu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>.</mo><mi>n</mi><mo>!</mo></mrow><annotation encoding='application/x-tex'>n.n!</annotation></semantics></math>. Remarquons aussi que le nombre
d’opérations élémentaires n’a guère de sens si on ne tient pas
compte de la complexité des expressions, l’avantage principal
de la méthode de développement étant d’éviter d’effectuer
des divisions.</p><p><span style="font-weight:bold">Calcul du déterminant par développement de Laplace</span><a id="hevea_default259"></a><br>
On calcule d’abord tous les mineurs 2x2 des colonnes 1 et 2
que l’on place dans une table de mineurs,
puis on calcule les mineurs 3x3 des colonnes 1 à 3 en développant
par rapport à la colonne 3 et en utilisant les mineurs précédents,
puis les mineurs 4x4 avec les mineurs 3x3, etc.. 
On évite ainsi de recalculer plusieurs fois les mêmes mineurs.
Cf. par exemple l’implémentation en C++ dans giac/xcas
(<code>www-fourier.ujf-grenoble.fr/~parisse/giac.html</code>)
qui utilise le type générique <code>map&lt;&gt;</code> de la librairie standard C++ (STL)
pour stocker les tables de mineurs (fonction 
<code>det_minor</code> du fichier <span style="font-family:monospace">vecteur.cc</span>).<br>
Nombre d’opérations élémentaires : il y a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo stretchy="false">(</mo> <mn>2</mn> <mi>n</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(^n_2)</annotation></semantics></math> mineurs d’ordre 2
à calculer nécessitant chacun 2 multiplications (et 1 addition),
puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo stretchy="false">(</mo> <mn>3</mn> <mi>n</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(^n_3)</annotation></semantics></math> mineurs d’ordre 3 nécessitant 3 multiplications et
2 additions, etc. donc le nombre de multiplications est de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><msubsup><mo stretchy="false">(</mo> <mn>2</mn> <mi>n</mi></msubsup><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><msubsup><mo stretchy="false">(</mo> <mn>3</mn> <mi>n</mi></msubsup><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>n</mi><msubsup><mo stretchy="false">(</mo> <mi>n</mi> <mi>n</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>2(^n_2)+3(^n_3)+...+n(^n_n)</annotation></semantics></math>, celui d’additions est
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo stretchy="false">(</mo> <mn>2</mn> <mi>n</mi></msubsup><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><msubsup><mo stretchy="false">(</mo> <mn>3</mn> <mi>n</mi></msubsup><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><msubsup><mo stretchy="false">(</mo> <mi>n</mi> <mi>n</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(^n_2)+2(^n_3)+...+(n&#x2d;1)(^n_n)</annotation></semantics></math> soit un nombre d’opérations
élémentaires majoré par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><msup><mn>.2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>n.2^n</annotation></semantics></math>.</p><p>On observe "expérimentalement" que cet algorithme est intéressant
lorsque le nombre de
paramètres dans le déterminant est grand et que la matrice est
plutôt creuse (majorité de coefficients nuls). Il existe des
heuristiques de permutation des lignes ou des colonnes visant
à optimiser la position des zéros (par exemple, les auteurs de GiNaC
(<code>www.ginac.de</code>) suite à des expérimentations
privilégient la simplification des petits mineurs en mettant les colonnes 
contenant le maximum de zéros à gauche selon la description faite
ici). </p><p>Pour se convaincre de l’intérêt de cet algorithme, on peut effectuer
le test O1 de Lewis-Wester<br>
<code>http://www.bway.net/~lewis/calatex.html</code><br>
il s’agit de calculer un déterminant de taille 15 avec 18 paramètres.</p>
<!--TOC subsection id="sec222" Systèmes linéaires-->
<h3 id="sec222" class="subsection">22.1.3  Systèmes linéaires</h3><!--SEC END --><p><a id="hevea_default260"></a>
On peut appliquer la méthode du pivot de Gauß ou les règles
de Cramer (matrices creuses avec beaucoup de paramètres par exemple). </p><p>Pour les systèmes à coefficients entiers non singuliers, 
on peut aussi utiliser une méthode <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-adique asymptotiquement
plus efficace. On calcule d’abord une borne sur les
coefficients des fractions solutions de l’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math>
en utilisant les règles de Cramer et la borne d’Hadamard.
On calcule ensuite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math>, l’inverse de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> (en changeant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> n’est pas inversible modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>), puis, si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>i</mi></munder><msub><mi>x</mi> <mi>i</mi></msub><msup><mi>p</mi> <mi>i</mi></msup><mo>,</mo><mspace width="1em"/><mi>A</mi><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mi>&lt;</mi><mi>k</mi></mrow></munder><msub><mi>x</mi> <mi>i</mi></msub><msup><mi>p</mi> <mi>i</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> x=\sum_i x_i p^i, \quad A(\sum_{i&amp;lt;k} x_i p^i)=b \pmod{p^k}  </annotation></semantics></math>
on ajoute <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub><msup><mi>p</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>x_k p^k </annotation></semantics></math> et on obtient l’équation :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><msub><mi>x</mi> <mi>k</mi></msub><mo>=</mo><mfrac><mrow><mi>b</mi><mo>&minus;</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mi>&lt;</mi><mi>k</mi></mrow></munder><msub><mi>x</mi> <mi>i</mi></msub><msup><mi>p</mi> <mi>i</mi></msup></mrow><mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></mfrac><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> Ax_k = \frac{b&#x2d;\sum_{i &amp;lt;k}  x_i p^i}{p^k} \pmod p  </annotation></semantics></math>
qui détermine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>x_k</annotation></semantics></math>.
On s’arrête lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est suffisamment grand pour pouvoir reconstruire
les fractions à l’aide de l’identité de Bézout (cf. infra),
ce qui est le cas si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>p^k</annotation></semantics></math> est
supérieur à 4 fois la borne de Hadamard de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> au carré.
Pour éviter de recalculer plusieurs fois <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>&minus;</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mi>&lt;</mi><mi>k</mi></mrow></msub><msub><mi>x</mi> <mi>i</mi></msub><msup><mi>p</mi> <mi>i</mi></msup></mrow><annotation encoding='application/x-tex'>b&#x2d;\sum_{i &amp;lt;k}  x_i p^i</annotation></semantics></math>,
on utilise la récurrence suivante
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>y</mi> <mn>0</mn></msub><mo>=</mo><mi>b</mi><mo>,</mo><mspace width="1em"/><msub><mi>x</mi> <mi>k</mi></msub><mo>=</mo><mi>C</mi><msub><mi>y</mi> <mi>k</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo><mspace width="1em"/><msub><mi>y</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mrow><msub><mi>y</mi> <mi>k</mi></msub><mo>&minus;</mo><mi>A</mi><msub><mi>x</mi> <mi>k</mi></msub></mrow><mi>p</mi></mfrac></mrow><annotation encoding='application/x-tex'> y_0=b, \quad x_{k}=Cy_k \pmod p, \quad y_{k+1} =
\frac{y_k&#x2d;Ax_{k}}{p} </annotation></semantics></math>
Pour une matrice de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, il faut <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3)</annotation></semantics></math> opérations
pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math>, puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><msup><mi>n</mi> <mn>2</mn></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>kn^2 \ln(n)</annotation></semantics></math> opérations 
pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>x_k</annotation></semantics></math> (le terme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(n)</annotation></semantics></math> 
vient de la taille des coefficients
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>y_k</annotation></semantics></math> dans le produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><msub><mi>y</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>Cy_k</annotation></semantics></math>),
donc pour pouvoir reconstruire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>, il faut prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> de l’ordre
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>n\ln(n)</annotation></semantics></math>, ce qui nécessite finalement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3\ln(n)^2)</annotation></semantics></math> opérations.</p>
<!--TOC subsection id="sec223" Bézout et les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-adiques.-->
<h3 id="sec223" class="subsection">22.1.4  Bézout et les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-adiques.</h3><!--SEC END --><p>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">/</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>a/b</annotation></semantics></math> une fraction irréductible d’entiers tels que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> est premier avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>a</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><msqrt><mi>n</mi></msqrt><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>|a| &amp;lt; \sqrt{n}/2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn><mo>&leq;</mo><mi>b</mi><mo>&leq;</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'> 0 \leq b \leq \sqrt{n}/2</annotation></semantics></math>.
Il s’agit de reconstruire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> connaissant 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi><mo>&times;</mo><mo stretchy="false">(</mo><msup><mi>b</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x=a \times (b^{&#x2d;1}) \pmod n</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>x\in [0,n[</annotation></semantics></math>.</p><p><span style="font-weight:bold">Unicité</span><br>
S’il existe une solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(a,b)</annotation></semantics></math> vérifiant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>a</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><msqrt><mi>n</mi></msqrt><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>|a| &amp;lt; \sqrt{n}/2</annotation></semantics></math> et 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn><mo>&leq;</mo><mi>b</mi><mo>&leq;</mo><msqrt><mi>n</mi></msqrt><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'> 0 \leq b \leq \sqrt{n}/2</annotation></semantics></math>, soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>&prime;</mo><mo>,</mo><mi>b</mi><mo>&prime;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(a&apos;,b&apos;)</annotation></semantics></math> une solution
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi><mo>&times;</mo><mo stretchy="false">(</mo><msup><mi>b</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x=a \times (b^{&#x2d;1}) \pmod n</annotation></semantics></math> et 
vérifiant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>a</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mi>&lt;</mi><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>|a&apos;| &amp;lt; \sqrt{n}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn><mo>&leq;</mo><mi>b</mi><mo>&prime;</mo><mo>&leq;</mo><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'> 0 \leq b&apos; \leq \sqrt{n}</annotation></semantics></math>, alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>a</mi><mi>b</mi><mo>&prime;</mo><mo>=</mo><mi>a</mi><mo>&prime;</mo><mi>b</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> a b&apos;=a&apos; b \pmod n  </annotation></semantics></math>
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>a</mi><mi>b</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>n</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>|ab&apos;| &amp;lt; n/2</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>a</mi><mo>&prime;</mo><mi>b</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>n</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>|a&apos;b| &amp;lt;n/2</annotation></semantics></math>, 
on en déduit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>b</mi><mo>&prime;</mo><mo>=</mo><mi>a</mi><mo>&prime;</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>ab&apos;=a&apos;b</annotation></semantics></math>. Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">/</mo><mi>b</mi><mo>=</mo><mi>a</mi><mo>&prime;</mo><mo stretchy="false">/</mo><mi>b</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>a/b=a&apos;/b&apos;</annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mi>a</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>a=a&apos;</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mi>b</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>b=b&apos;</annotation></semantics></math> car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">/</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>a/b</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&prime;</mo><mo stretchy="false">/</mo><mi>b</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>a&apos;/b&apos;</annotation></semantics></math> sont supposées irréductibles.</p><p><span style="font-weight:bold">Reconstruction lorsqu’on sait qu’il y a une solution</span><br>
On suit l’algorithme de calcul des coefficients de Bézout
pour les entiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>. On pose :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub><mi>n</mi><mo>+</mo><msub><mi>&beta;</mi> <mi>k</mi></msub><mi>x</mi><mo>=</mo><msub><mi>r</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'> \alpha_k n + \beta_k x= r_k  </annotation></semantics></math>
où les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>r_k</annotation></semantics></math> sont les restes successifs de l’algorithme d’Euclide,
avec la condition initiale :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&alpha;</mi> <mn>0</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>&beta;</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>&beta;</mi> <mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>r</mi> <mn>0</mn></msub><mo>=</mo><mi>n</mi><mo>,</mo><msub><mi>r</mi> <mn>1</mn></msub><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'> \alpha_0=1, \beta_0=0, \alpha_1=0, \beta_1=1, r_0=n, r_1=x  </annotation></semantics></math>
et la relation de récurrence :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>&beta;</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>q</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>q</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><mfrac><mrow><msub><mi>r</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><mrow><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \beta_{k+2}=\beta_k &#x2d; q_{k+2} \beta_{k+1}, \quad
q_{k+2}=\frac{r_{k}&#x2d;r_{k+2}}{r_{k+1}} </annotation></semantics></math></p><p>On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&beta;</mi> <mi>k</mi></msub><mi>x</mi><mo>=</mo><msub><mi>r</mi> <mi>k</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \beta_k x= r_k \pmod n</annotation></semantics></math> pour tout rang mais il faut vérifier
les conditions de taille sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&beta;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\beta_k</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>r_k</annotation></semantics></math> pour trouver le couple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(a,b)</annotation></semantics></math>.
Montrons par récurrence que :
<a id="eqref_41"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>r</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>&beta;</mi> <mi>k</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mi>n</mi><mspace width="2em"/><mo stretchy="false">(</mo><mn>41</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 \beta_{k+1} r_k &#x2d; r_{k+1} \beta_k = (&#x2d;1)^k n 
\qquad (41) </annotation></semantics></math>
Au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>k=0</annotation></semantics></math>, on vérifie l’égalité, on l’admet au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, 
alors au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math>, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>&beta;</mi> <mi>k</mi></msub><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>q</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>&beta;</mi> <mi>k</mi></msub><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>&beta;</mi> <mi>k</mi></msub><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>r</mi> <mi>k</mi></msub><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mi>n</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 \beta_{k+2} r_{k+1} &#x2d; r_{k+2} \beta_{k+1} 
&amp; = &amp; \beta_k r_{k+1} &#x2d; q_{k+2} r_{k+1} \beta_{k+1}  &#x2d; r_{k+2} \beta_{k+1} \\
&amp; = &amp; \beta_k r_{k+1} &#x2d; (r_{k}&#x2d;r_{k+2}) \beta_{k+1}  &#x2d; r_{k+2} \beta_{k+1} \\
&amp; = &amp; \beta_k r_{k+1} &#x2d; r_{k} \beta_{k+1} \\
&amp; = &amp; &#x2d; (&#x2d;1)^k n
 \end{matrix} </annotation></semantics></math>
On vérifie aussi que le signe de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&beta;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\beta_k</annotation></semantics></math> est positif si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est impair
et négatif si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est pair, on déduit donc de (<a href="#eqref_41">41</a>) :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>r</mi> <mi>k</mi></msub><mi>&lt;</mi><mi>n</mi></mrow><annotation encoding='application/x-tex'> |\beta_{k+1}| r_k &amp;lt; n  </annotation></semantics></math>
(avec égalité si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>r_{k+1}=0</annotation></semantics></math>)</p><p>Considérons la taille des restes successifs, il existe un rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>
tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>k</mi></msub><mo>&geq;</mo><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>r_k \geq \sqrt{n}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&lt;</mi><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>r_{k+1}&amp;lt;\sqrt{n}</annotation></semantics></math>. On a alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>&beta;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>n</mi><mo stretchy="false">/</mo><msub><mi>r</mi> <mi>k</mi></msub><mo>&leq;</mo><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>|\beta_{k+1}|  &amp;lt; n/r_k \leq \sqrt{n}</annotation></semantics></math>.</p><p>Donc l’algorithme de Bézout permet de reconstruire l’unique couple
solution s’il existe.</p><p><span style="font-weight:bold">Exemple</span><br>
On prend <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>101</mn></mrow><annotation encoding='application/x-tex'>n=101</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>a=2</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>b=3</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">/</mo><mi>b</mi><mo>=</mo><mn>68</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>101</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a/b=68 \pmod {101}</annotation></semantics></math>.
Puis on effectue Bézout pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>68</mn></mrow><annotation encoding='application/x-tex'>68</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>101</mn></mrow><annotation encoding='application/x-tex'>101</annotation></semantics></math> en affichant les étapes 
intermédiaires (par exemple avec <code>IEGCD</code> sur une HP49 ou exercice
avec votre système de calcul formel) :
</p><pre class="verbatim">   = alpha*101+beta*68
101    1        0
 68    0        1  L1 - 1*L2
 33    1       -1  L2 - 2*L3
  2   -2        3  ...
</pre><p>
On s’arrête à la première ligne telle que le coefficient de la 1ère colonne
est inférieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>101</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{101}</annotation></semantics></math>, on retrouve bien <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn></mrow><annotation encoding='application/x-tex'>2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>3</mn></mrow><annotation encoding='application/x-tex'>3</annotation></semantics></math>.
Quand on programme l’algorithme de
reconstruction, on ne calcule bien sûr pas la colonne des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>,
ce qui donne par exemple le programme xcas ou mupad suivant :
</p><pre class="verbatim">// Renvoie a/b tel que a/b=x mod n et |a|,|b|&lt;sqrt(n)
padictofrac:=proc (n,x)
  local r0,beta0,r1,beta1,r2,q2,beta2;
begin
  r0:=n;
  beta0:=0;
  r1:=x;
  beta1:=1;
  sqrtn:=float(sqrt(n));
  while r1&gt;sqrtn do
    r2:= irem(r0,r1); 
    q2:=(r0-r2)/r1;
    beta2:=beta0-q2*beta1;
    beta0:=beta1; r0:=r1; beta1:=beta2; r1:=r2;
  end_while;
  return(r1/beta1);
end_proc;
</pre>
<!--TOC subsection id="sec224" Base du noyau-->
<h3 id="sec224" class="subsection">22.1.5  Base du noyau</h3><!--SEC END --><p><a id="hevea_default261"></a>
On présente ici deux méthodes, la première se généralise
au cas des systèmes à coefficients entiers, la deuxième
utilise un peu moins de mémoire (elle travaille sur une matrice 2 fois
plus petite).</p><p><span style="font-weight:bold">Première méthode</span>
Soir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> la matrice dont on cherche le noyau. On ajoute à droite
de la matrice transposée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> une matrice identité ayant
le même nombre de lignes que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>M^t</annotation></semantics></math>. On effectue une réduction
sous-diagonale qui nous amène à une matrice composée de deux
blocs
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>M</mi> <mi>t</mi></msup><msub><mi>I</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mo>&rightarrow;</mo><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mi>U</mi><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> ( M^t I_n ) \ \rightarrow \ ( U \tilde{L} )  </annotation></semantics></math>
Attention, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{L}</annotation></semantics></math> n’est pas la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> de la décomposition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>M^t</annotation></semantics></math>, on a en fait
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover><msup><mi>M</mi> <mi>t</mi></msup><mo>=</mo><mi>U</mi></mrow><annotation encoding='application/x-tex'> \tilde{L} M^t = U </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>M</mi><msup><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mi>t</mi></msup><mo>=</mo><msup><mi>U</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'> M \tilde{L}^t = U^t  </annotation></semantics></math>
Les colonnes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>\tilde{L}^t</annotation></semantics></math> correspondant aux colonnes nulles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>U</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>U^t</annotation></semantics></math> 
(ou si on préfère les lignes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{L}</annotation></semantics></math> correspondant
aux lignes nulles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math>) sont donc dans le noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> et réciproquement
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mi>v</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>Mv=0</annotation></semantics></math> alors 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>U</mi> <mi>t</mi></msup><mo stretchy="false">(</mo><msup><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mi>t</mi></msup><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>v</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> U^t (\tilde{L}^t)^{&#x2d;1} v =0  </annotation></semantics></math>
donc, comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> est réduite, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mi>t</mi></msup><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>(\tilde{L}^t)^{&#x2d;1} v</annotation></semantics></math> est une combinaison
linéaire des vecteurs de base d’indice les lignes nulles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math>.
Finalement, les lignes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{L}</annotation></semantics></math> correspondant
aux lignes nulles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> forment une base du noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>.</p><p><span style="font-weight:bold">Deuxième méthode</span>
On commence bien sûr par réduire la matrice (réduction complète
en-dehors de la diagonale), et on divise chaque ligne par son
premier coefficient non nul (appelé pivot). On insère alors
des lignes de 0 pour que les pivots (non nuls) se trouvent
sur la diagonale. Puis en fin de matrice, on ajoute ou on supprime des 
lignes de 0 pour avoir une matrice carrée de dimension le nombre de colonnes
de la matrice de départ.
On parcourt alors la matrice en diagonale. Si
le <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>-ième coefficient est non nul, on passe au suivant. 
S’il est nul, alors tous
les coefficients d’indice supérieur ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math> du <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>-ième
vecteur colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>v_i</annotation></semantics></math> sont nuls (mais pas forcément pour les indices
inférieurs à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>). Si on remplace le <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>-ième coefficient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>v_i</annotation></semantics></math>
par -1, il est facile de se convaincre que c’est un vecteur du noyau,
on le rajoute donc à la base du noyau. On voit facilement
que tous les vecteurs de ce type forment une famille libre de
la bonne taille, c’est donc bien une base du noyau.</p>
<!--TOC section id="sec225" Algèbre linéaire sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>-->
<h2 id="sec225" class="section">22.2  Algèbre linéaire sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math></h2><!--SEC END -->
<!--TOC subsection id="sec226" Calcul du déterminant d’une matrice à coefficient entiers-->
<h3 id="sec226" class="subsection">22.2.1  Calcul du déterminant d’une matrice à coefficient entiers</h3><!--SEC END --><p>
L’algorithme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-adique de résolution de systèmes
linéaires peut servir à accélérer le calcul du
déterminant d’une matrice à coefficients entiers de grande taille.
En effet, le PPCM <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> des dénominateurs des composantes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est
un diviseur du déterminant, et si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> est choisi avec des
coefficients aléatoires, on a une forte probabilité d’obtenir
le dernier facteur invariant de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>. Comme le déterminant
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> a une très faible probabilité de contenir un gros facteur
carré, ce dernier facteur invariant est très proche du
déterminant. Ce dernier est pour une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> aléatoire
lui-même à un facteur de l’ordre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">/</mo><mi>&pi;</mi><msup><mo stretchy="false">)</mo> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>(2/\pi)^n</annotation></semantics></math> proche
de la borne de Hadamard. Il suffit donc de très peu de nombres
premiers pour déterminer det<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>f</mi></mrow><annotation encoding='application/x-tex'>(A)/f</annotation></semantics></math> par le théorème
des restes chinois. En pratique pour des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> de l’ordre de 100
à 1000, cet algorithme est plus rapide que le calcul uniquement
par les restes chinois. Pour des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> plus grands, il faut se
rabattre sur des algorithmes probabilistes avec arrêt prématuré
pour être plus rapide (on s’arrête lorsque le déterminant
n’évolue plus par reconstruction par les restes chinois 
pour plusieurs nombres premiers successifs, le résultat n’est
alors pas certifié, c’est ce qui se passe dans Xcas si
<code>proba_epsilon</code> n’est pas nul), 
ou utiliser des méthodes
d’inversion ou de réduction de type Strassen.</p>
<!--TOC subsection id="sec227" Réduction de Hermite et Smith-->
<h3 id="sec227" class="subsection">22.2.2  Réduction de Hermite et Smith</h3><!--SEC END --><p><a id="hevea_default262"></a> <a id="hevea_default263"></a>
Lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> est une matrice à coefficients entiers, 
on ne peut plus faire l’algorithme du pivot de Gauss ou de
Gauss-Bareiss en restant dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> et en étant réversible.
On peut toutefois effectuer des manipulations élémentaires
réversibles dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>, grâce à l’idendité de Bézout. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math>
est le pivot en ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> le coefficient en ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> à
annuler, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>u, v, d</annotation></semantics></math> les coefficients de l’identité de Bézout
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>u</mi><mo>+</mo><mi>b</mi><mi>v</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>a u + b v =d</annotation></semantics></math> on fait les changements :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>L</mi> <mi>i</mi></msub><mo>&leftarrow;</mo><mi>u</mi><msub><mi>L</mi> <mi>i</mi></msub><mo>+</mo><mi>v</mi><msub><mi>L</mi> <mi>j</mi></msub><mo>,</mo><mspace width="1em"/><msub><mi>L</mi> <mi>j</mi></msub><mo>&leftarrow;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mi>b</mi><mi>d</mi></mfrac><msub><mi>L</mi> <mi>i</mi></msub><mo>+</mo><mfrac><mi>a</mi><mi>d</mi></mfrac><msub><mi>L</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'> L_i \leftarrow uL_i +v L_j, \quad 
L_j \leftarrow &#x2d;\frac{b}{d} L_i + \frac{a}{d} L_j  </annotation></semantics></math>
qui est réversible dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>
car le déterminant de la sous-matrice élémentaire
correspondante est
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>&vert;</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mi>u</mi></mtd> <mtd><mi>v</mi></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mi>b</mi><mi>d</mi></mfrac></mtd> <mtd><mfrac><mi>a</mi><mi>d</mi></mfrac></mtd></mtr></mtable><mo>&vert;</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'> \left| \begin{array}{cc}
u &amp; v \\
&#x2d;\frac{b}{d} &amp; \frac{a}{d}
\end{array} \right| = 1
 </annotation></semantics></math>
On peut donc créer des zéros en-dessous de la diagonale, il existe
une matrice inversible <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> telle que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>M</mi><mo>=</mo><mi>U</mi></mrow><annotation encoding='application/x-tex'>LM=U</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> est triangulaire
supérieure. On peut même rendre les coefficients hors diagonale
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> inférieur aux pivots de leurs colonnes respectives en faisant
une combinaison linéaire de lignes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>L</mi> <mi>j</mi></msub><mo>&minus;</mo><mi>q</mi><msub><mi>L</mi> <mi>p</mi></msub><mo>,</mo><mi>j</mi><mi>&lt;</mi><mi>p</mi></mrow><annotation encoding='application/x-tex'>L_j = L_j&#x2d;qL_p, j&amp;lt;p</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math>
est le quotient de la division euclidienne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mrow><mi>j</mi><mi>c</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>M_{jc}</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mrow><mi>p</mi><mi>c</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>M_{pc}</annotation></semantics></math>
(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> la ligne du pivot, en principe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>=</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>p=c</annotation></semantics></math>).
On observe aussi que les pivots sont les pgcd des éléments de la colonne
du pivot à partir de la ligne du pivot.</p><p>Applications : 
Cette réduction (dite forme normale de Hermite 
lorsqu’on réduit les lignes
au-dessus de la diagonale par division euclidienne par
le pivot) permet de trouver une base du noyau
à coefficients entiers et telle que tout élément du noyau à 
coefficient entier s’écrit comme combinaison linéaire à coefficients
entiers des éléments de la base. Il suffit d’appliquer la
réduction de Hermite à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>M</mi> <mi>t</mi></msup><mo stretchy="false">&vert;</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(M^t|I)</annotation></semantics></math>, on obtient une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>U</mi><mo stretchy="false">&vert;</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(U|L)</annotation></semantics></math>
telle que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi><mo>=</mo><mi>L</mi><msup><mi>M</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>U=LM^t</annotation></semantics></math>.
Dans Xcas, on peut utiliser l’instruction <code>ihermite</code> (ou
<code>mathnf</code> de PARI). L’aide
détaillée de Xcas donne un exemple de calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>-base
d’un noyau. </p><p>Exemple : soit à résoudre en entiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mi>y</mi><mo>+</mo><mn>5</mn><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>2x+3y+5z=0</annotation></semantics></math>.
On pose <code>M:=[[2,3,5]]</code> puis 
<code>L,U:=ihermite(tran(M))</code>, les lignes nulles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> correspondent
à des lignes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> qui forment une base du noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>, soit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>6</mn><mo>,</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(6,1,&#x2d;3)</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>5</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(&#x2d;5,0,2)</annotation></semantics></math>.
En effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi><mo>=</mo><mi>L</mi><msup><mi>M</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>U=L M^t</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>U</mi> <mi>t</mi></msup><mo>=</mo><mi>M</mi><msup><mi>L</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>U^t=M L^t</annotation></semantics></math>, les colonnes nulle 
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>U</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>U^t</annotation></semantics></math> sont donc images par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> des colonnes
correspondantes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>L^t</annotation></semantics></math>, ainsi les lignes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> correspondant
à des lignes nulles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> sont dans le noyau. Et si un vecteur
à coefficient entiers est dans le noyau, alors il se décompose
sur les vecteurs colonnes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>L^t</annotation></semantics></math> avec des coefficients entiers
(puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mo>&Element;</mo></mrow><annotation encoding='application/x-tex'>L\in</annotation></semantics></math>GL<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo/><mi>n</mi></msub><mo stretchy="false">(</mo><mi>&Zopf;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>_n(\mathbb{Z})</annotation></semantics></math>), on applique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> et on conclut
que ses composantes sur les colonnes non nulles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>U</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>U^t</annotation></semantics></math> sont nulles.</p><p>Remarque : l’algorithme du pivot de Gauss permet de trouver plus
rapidement une base sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Q}</annotation></semantics></math> du noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> à coefficients entiers,
par exemple ici <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">{</mo><msub><mi>v</mi> <mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>,</mo><msub><mi>v</mi> <mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>5</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>\{ v_1=(&#x2d;3,2,0), v_2=(&#x2d;5,0,2)\}</annotation></semantics></math> mais ce n’est pas une base
sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>, par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><msub><mi>v</mi> <mn>1</mn></msub><mo>+</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><msub><mi>v</mi> <mn>2</mn></msub><mo>&Element;</mo><msup><mi>&Zopf;</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>1/2v_1+1/2v_2 \in \mathbb{Z}^3</annotation></semantics></math>.</p><p>Plus généralement, chercher une solution particulière
du système <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mi>X</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding='application/x-tex'>MX=B</annotation></semantics></math> revient à résoudre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>U</mi> <mi>t</mi></msup><mi>Y</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding='application/x-tex'>U^t Y=B</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>L</mi> <mi>t</mi></msup><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>X</mi></mrow><annotation encoding='application/x-tex'>Y=(L^t)^{&#x2d;1} X</annotation></semantics></math>, la recherche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi></mrow><annotation encoding='application/x-tex'>Y</annotation></semantics></math> est
alors très simple puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> est échelonnée. 
Par exemple, <code>M:=[[2,3,5],[7,5,3]]</code>
puis <code>B:=[3,-2]</code>, puis
<code>L,U:=ihermite(tran(M))</code>, donne pour <code>tran(U)</code>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0
\end{array}\right)  </annotation></semantics></math>
on a donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>1</mn></msub><mo>=</mo><mn>3</mn><mo>,</mo><msub><mi>y</mi> <mn>2</mn></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mo>,</mo><msub><mi>y</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>y_1=3, y_2=&#x2d;2, y_3</annotation></semantics></math> quelconque puis on calcule 
<code>X:=tran(L)*[3,-2,y3]</code>, on peut vérifier 
avec <code>normal(M*X)</code>.</p><p>On peut aussi se servir de la forme normale de Hermite pour
compléter un vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v=(a_1,...,a_n)</annotation></semantics></math> de contenu 1 en une base
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Zopf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{Z}^n</annotation></semantics></math> (si le contenu n’est pas 1, c’est bien sur impossible
puisque le déterminant est un multiple du contenu), il suffit
de prendre les colonnes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>L^{&#x2d;1}</annotation></semantics></math> 
(où <code>L,U:=ihermite(tran(v))</code>).
En effet on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi><mo>=</mo><mi>L</mi><msup><mi>v</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>U=L v^t</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> est égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1,0,...,0)</annotation></semantics></math> car le
contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> vaut 1.</p><p>La réduction échelonnée sous la diagonale correspond à
<code>ihermite</code>, la réduction complète correspond à
<code>ismith</code>
(ou <code>matsnf</code> de PARI) qui 
calcule la décomposition de Smith d’une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> à coefficients
entiers et en donne les coefficients invariants.
Il faut pour cela alterner plusieurs décomposition de Hermite en
ligne et en colonne. En effet un élément hors diagonale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{ij}</annotation></semantics></math>
non nul d’une
réduction de Hermite est un reste de division euclidienne par
le pivot <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>j</mi><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{jj}</annotation></semantics></math> (respectivement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{ii}</annotation></semantics></math> selon qu’on réduit en lignes ou en
colonnes) sur la diagonale, il est donc 
strictement plus petit et donnera lieu à
l’étape de réduction suivante à un pgcd
soit égal en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{ii}</annotation></semantics></math> [resp. <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>j</mi><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{jj}</annotation></semantics></math>] 
(dans ce cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{ij}</annotation></semantics></math> deviendra nul et on effectue une seule
manipulation de lignes de type Gauss et non deux, ce qui ne changera
pas les 0 dans la ligne du pivot), soit strictement plus
petit, donc soit l’un des pivots décroit, soit l’un des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{ij}</annotation></semantics></math>
hors diagonale s’annule. On obtient en un nombre fini d’étapes
une matrice diagonale.
La forme normale de Smith d’une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> impose également 
que les coefficients
diagonaux non nuls <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mn>1</mn></msub><mo stretchy="false">&vert;</mo><msub><mi>d</mi> <mn>2</mn></msub><mo stretchy="false">&vert;</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">&vert;</mo><msub><mi>d</mi> <mi>r</mi></msub></mrow><annotation encoding='application/x-tex'>d_1|d_2|...|d_r</annotation></semantics></math> se divisent. Pour réaliser
cela, si par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>d_1</annotation></semantics></math> ne divise pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>d_2</annotation></semantics></math>, on remplace <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>C_1</annotation></semantics></math> par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>C</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>C_1+C_2</annotation></semantics></math>, puis on fait apparaitre le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>d_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>d_2</annotation></semantics></math> en ligne
1 colonne 1 en créant un 0 en ligne 2 colonne 1. </p><p>La réduction de Smith sert par exemple à montrer
qu’un sous-module de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Zopf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{Z}^n</annotation></semantics></math> obtenu par quotient par l’image 
d’une application linéaire de matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est isomorphe 
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msub><mi>d</mi> <mi>i</mi></msub><mo>&times;</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>&times;</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><msub><mi>d</mi> <mi>r</mi></msub><mo>&times;</mo><msup><mi>&Zopf;</mi> <mrow><mi>n</mi><mo>&minus;</mo><mi>r</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/d_i \times ... \times \mathbb{Z}/d_r \times \mathbb{Z}^{n&#x2d;r}</annotation></semantics></math>. C’est ce
qu’on obtient pour un module présenté par des générateurs
et relations entre générateurs.
Les coefficients <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>d_i</annotation></semantics></math> sont appelés <span style="font-weight:bold">facteurs
invariants</span><a id="hevea_default264"></a> de la
matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, leur factorisation en produit de nombres 
premiers à une certaine puissance donne les <span style="font-weight:bold">diviseurs 
élémentaires</span><a id="hevea_default265"></a>.</p><p>Exemple 1 : on se donne le groupe abélien engendré par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>x_1</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>x_2</annotation></semantics></math> vérifiant les relations <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><mn>4</mn><msub><mi>x</mi> <mn>2</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><mn>6</mn><msub><mi>x</mi> <mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>2x_1+4x_2=0, &#x2d;2x_1+6x_2=0</annotation></semantics></math>. On fait
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>L</mi> <mn>2</mn></msub><mo>+</mo><msub><mi>L</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>L_2=L_2+L_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>C</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>C</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>C_2=C_2&#x2d;C_1</annotation></semantics></math> ce qui donne la matrice réduite
de diagonale 2 et 10, qui en sont les facteurs invariants, le groupe
est isomorphe à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>2</mn><mo>&times;</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/2 \times \mathbb{Z}/10</annotation></semantics></math> (parfois noté 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&oplus;</mo></mrow><annotation encoding='application/x-tex'>\oplus</annotation></semantics></math> au lieu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&times;</mo></mrow><annotation encoding='application/x-tex'>\times</annotation></semantics></math>).</p><p>Exemple 2 : on se donne un module sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> engendré par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>m</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>m</mi> <mn>2</mn></msub><mo>,</mo><msub><mi>m</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>m_1,m_2,m_3</annotation></semantics></math>
et les relations <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><msub><mi>m</mi> <mn>1</mn></msub><mo>+</mo><mn>3</mn><msub><mi>m</mi> <mn>2</mn></msub><mo>+</mo><mn>5</mn><msub><mi>m</mi> <mn>3</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><mn>7</mn><msub><mi>m</mi> <mn>1</mn></msub><mo>+</mo><mn>3</mn><msub><mi>m</mi> <mn>2</mn></msub><mo>&minus;</mo><mn>5</mn><msub><mi>m</mi> <mn>3</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>2m_1+3m_2+5m_3=0, 7m_1+3m_2&#x2d;5m_3=0</annotation></semantics></math>.
On pose <code>A:=[[2,3,5],[7,3,-5]]</code>, puis
<code>U,B,V:=ismith(A)</code>, on a donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>=</mo><mi>U</mi><mi>A</mi><mi>V</mi></mrow><annotation encoding='application/x-tex'>B=UAV</annotation></semantics></math>.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>m</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>m</mi> <mn>2</mn></msub><mo>,</mo><msub><mi>m</mi> <mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>M=(m_1,m_2,m_3)</annotation></semantics></math>, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>M</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>AM=0</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><msup><mi>V</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>M</mi><mo>=</mo><mi>U</mi><mi>A</mi><mi>M</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>B V^{&#x2d;1}M=UAM=0</annotation></semantics></math>.
On pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>n</mi> <mn>2</mn></msub><mo>,</mo><msub><mi>n</mi> <mn>3</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi><mo>=</mo><msup><mi>V</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>M</mi></mrow><annotation encoding='application/x-tex'>(n_1,n_2,n_3)=N=V^{&#x2d;1}M</annotation></semantics></math>, 
les générateurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>m</mi> <mn>1</mn></msub><mo>&minus;</mo><mn>6</mn><msub><mi>m</mi> <mn>2</mn></msub><mo>&minus;</mo><mn>20</mn><msub><mi>m</mi> <mn>3</mn></msub><mo>,</mo><msub><mi>n</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>m</mi> <mn>2</mn></msub><mo>+</mo><mn>3</mn><msub><mi>m</mi> <mn>3</mn></msub><mo>,</mo><msub><mi>n</mi> <mn>3</mn></msub><mo>=</mo><msub><mi>m</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>n_1=m_1&#x2d;6m_2&#x2d;20m_3, n_2=m_2+3m_3,n_3=m_3</annotation></semantics></math>
vérifient donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mn>1</mn></msub><msub><mi>n</mi> <mn>1</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>b</mi> <mn>2</mn></msub><msub><mi>n</mi> <mn>2</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>b</mi> <mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>b</mi> <mn>2</mn></msub><mo>=</mo><mn>15</mn></mrow><annotation encoding='application/x-tex'>b_1 n_1=0, b_2n_2=0, b_1=1, b_2=15</annotation></semantics></math>, le module est donc
isomorphe à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>1</mn><mo>&times;</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>15</mn><mo>&times;</mo><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/1 \times \mathbb{Z}/15 \times \mathbb{Z}</annotation></semantics></math> soit encore <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>15</mn><mi>&Zopf;</mi><mo>&times;</mo><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/15\mathbb{Z}
\times \mathbb{Z}</annotation></semantics></math>.</p>
<!--TOC subsection id="sec228" L’algorithme LLL.-->
<h3 id="sec228" class="subsection">22.2.3  L’algorithme LLL.</h3><!--SEC END --><p> <a id="hevea_default266"></a>
Il s’agit d’une méthode permettant d’obtenir rapidement
une base courte d’un réseau. Ce n’est pas la base la plus courte
possible mais un compromis temps d’exécution rapide/base
pas trop grande. Voir par exemple Cohen pour la définition
et les propriétés. L’instruction Xcas correspondante est
<code>lll</code> (ou <code>qflll</code> de PARI).</p><p>Cet algorithme est très utile en calcul formel, pour éviter
une explosion combinatoire dans certaines
opérations de recombinaison. Par exemple, supposons que
nous souhaitions factoriser un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à coefficients
entiers sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math> en utilisant ses racines approchées. Si
plusieurs racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>r_k</annotation></semantics></math> correspondent à un facteur entier,
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>n</mi></msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo><msub><mi>r</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>p_n \sum r_k </annotation></semantics></math> doit être un entier aux erreurs
d’arrondi près. Tester toutes les combinaisons possibles
serait beaucoup trop long, en particulier si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est irréductible
(en gros <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{n&#x2d;1}</annotation></semantics></math> tests de recombinaison). Pour éviter ce
problème, on construit un réseau engendré par degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> 
lignes dont les premières coordonnées sont celles de la
matrice identité, complétées par la partie réelle et
imaginaire des racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> multipliée par le coefficient dominant
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et par une puissance de 10 assez grande. On ajoute
deux lignes qui“annulent” les parties entières des combinaisons
linéaires des parties réelles et imaginaires.
L’existence
d’un facteur irréductible se lira sur un vecteur court du réseau
avec des 1 et des 0 comme combinaison linéaire des vecteurs
initiaux.
</p><pre class="verbatim">f(P):={
  local l,n,prec,M,S,A,L,O;
  n:=degree(P);
  prec:=2*n;
  l:=proot(P,prec+n);
  M:=round(tran([op(idn(n)),
     lcoeff(P)*10^prec*re(l),lcoeff(P)*10^prec*im(l)]));
  M:=[op(M),[op(seq(0,n)),10^prec,0],[op(seq(0,n+1)),10^prec]];
  S,A,L,O:=lll(M);
  retourne l,A;
}:;
</pre><p>
Par exemple, <code>P:=(x^3+x+1)*(x^4+x+1)</code> suivi de <code>l,A:=f(P)</code>
fait apparaitre en première ligne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> le vecteur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1,1,1,0,0,0,0,0,0)</annotation></semantics></math>. On essaie donc de recombiner les trois
premières racines de <code>l</code><br>
<code>pcoeff(l[0],l[1],l[2])</code><br>
renvoie bien un facteur presqu’entier de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Il faut bien entendu des
encadrements rigoureux pour déterminer la précision à utiliser
pour les racines pour prouver l’irréductibilité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> ne
contient pas de vecteur court contenant uniquement des 1 et 0.</p>
<!--TOC section id="sec229" Le pivot de Gauss numérique.-->
<h2 id="sec229" class="section">22.3  Le pivot de Gauss numérique.</h2><!--SEC END -->
<!--TOC subsection id="sec230" Efficacité de l’algorithme-->
<h3 id="sec230" class="subsection">22.3.1  Efficacité de l’algorithme</h3><!--SEC END --><p>
Si la matrice possède <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> lignes et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> colonnes,
le nombre maximal d’opérations pour réduire une ligne est 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> opérations (une opération=1 multiplication + 1 soustraction, 
en calculant une seule fois le quotient). 
Il y a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>L&#x2d;1</annotation></semantics></math> lignes à réduire à chaque
étape et min<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo>,</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(L,C)</annotation></semantics></math> étapes à effectuer, on en déduit que le
nombre maximal d’opérations pour réduire une matrice est
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>C</mi></mrow><annotation encoding='application/x-tex'>LC</annotation></semantics></math>min<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo>,</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(L,C)</annotation></semantics></math>. Pour une matrice carrée de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, cela fait 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>n^3</annotation></semantics></math> opérations. En fait c’est moins, parce que lorsqu’on crée
des 0 dans la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième colonne, la ligne du pivot à retrancher
commence par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k&#x2d;1</annotation></semantics></math> zéros, on peut donc commencer la combinaison linéaire 
à la colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, donc pour une matrice carrée de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> cela
fait en réalité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n^3/2</annotation></semantics></math> opérations.
Si on effectue une réduction en-dessous de la diagonale, 
toujours pour une matrice carrée, le nombre d’opérations 
devient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">/</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>n^3/3</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow> <mi>n</mi></msubsup><msup><mi>k</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\sum_{k=2}^n k^2</annotation></semantics></math>). On peut ensuite réduire au-dessus
de la diagonale.</p>
<!--TOC subsection id="sec231" Erreurs d’arrondis du pivot de Gauss-->
<h3 id="sec231" class="subsection">22.3.2  Erreurs d’arrondis du pivot de Gauss</h3><!--SEC END --><p> <a id="hevea_default267"></a>
<a id="hevea_default268"></a>
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>j</mi><mi>c</mi></mrow></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>l</mi><mi>c</mi></mrow></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|a_{jc}| \leq |a_{lc}|</annotation></semantics></math>, une étape de réduction multiplie
au plus l’erreur absolue des coefficients par 2. Donc la
réduction complète d’une matrice peut multiplier au pire l’erreur
absolue sur les coefficients par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>2^n</annotation></semantics></math> (où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est le nombre
d’étapes de réduction, inférieur au plus petit du nombre de lignes
et de colonnes). Ceci signifie qu’avec la précision d’un double,
on peut au pire perdre toute précision pour des matrices pas
si grandes que ça (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>52</mn></mrow><annotation encoding='application/x-tex'>n=52</annotation></semantics></math>). Heureusement, il semble qu’en pratique, 
l’erreur absolue
ne soit que très rarement multipliée par un facteur supérieur à 10.</p><p>Par contre, si on ne prend pas la précaution de choisir le pivot
de norme maximale dans la colonne, les erreurs d’arrondis se
comportent de manière bien moins bonnes, cf. l’exemple suivant.</p><p><span style="font-weight:bold">Exemple</span><br>
Soit à résoudre le système linéaire
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&epsi;</mi><mi>x</mi><mo>+</mo><mn>1.0</mn><mi>y</mi><mo>=</mo><mn>1.0</mn><mo>,</mo><mspace width="1em"/><mi>x</mi><mo>+</mo><mn>2.0</mn><mi>y</mi><mo>=</mo><mn>3.0</mn></mrow><annotation encoding='application/x-tex'> \epsilon x + 1.0 y = 1.0 , \quad x + 2.0 y = 3.0  </annotation></semantics></math>
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo>=</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>54</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>\epsilon =2^{&#x2d;54}</annotation></semantics></math> (pour une machine utilisant des doubles pour
les calculs en flottant,
plus généralement on choisira <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>\epsilon</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1.0</mn><mo>+</mo><mn>3</mn><mi>&epsi;</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mn>1.0</mn></mrow><annotation encoding='application/x-tex'>(1.0+3\epsilon)&#x2d;1.0</annotation></semantics></math>
soit indistinguable de 0.0).<br>
Si on résoud le système exactement,
on obtient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mn>2</mn><mi>&epsi;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x=1/(1&#x2d;2\epsilon)</annotation></semantics></math> (environ 1)
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mn>3</mn><mi>&epsi;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mn>2</mn><mi>&epsi;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y=(1&#x2d;3\epsilon)/(1&#x2d;2\epsilon)</annotation></semantics></math> (environ 1).
Supposons que l’on n’utilise pas la stratégie du pivot partiel,
on prend alors comme pivot <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>\epsilon</annotation></semantics></math>, donc on effectue la
manipulation de ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>2</mn></msub><mo>&leftarrow;</mo><msub><mi>L</mi> <mn>2</mn></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mi>&epsi;</mi><msub><mi>L</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>L_2 \leftarrow L_2 &#x2d; 1/\epsilon L_1</annotation></semantics></math> ce qui
donne comme 2ème équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>2.0</mn><mo>&minus;</mo><mn>1.0</mn><mo stretchy="false">/</mo><mi>&epsi;</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mn>3.0</mn><mo>&minus;</mo><mn>1.0</mn><mo stretchy="false">/</mo><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>(2.0&#x2d;1.0/\epsilon)y=3.0&#x2d;1.0/\epsilon</annotation></semantics></math>.
Comme les calculs sont numériques, et à cause des erreurs
d’arrondis, cette 2ème équation sera remplacée par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1.0</mn><mo stretchy="false">/</mo><mi>&epsi;</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1.0</mn><mo stretchy="false">/</mo><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>(&#x2d;1.0/\epsilon)y=&#x2d;1.0/\epsilon</annotation></semantics></math> d’où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>1.0</mn></mrow><annotation encoding='application/x-tex'>y=1.0</annotation></semantics></math>, qui sera remplacé
dans la 1ère équation, donnant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mi>x</mi><mo>=</mo><mn>1.0</mn><mo>&minus;</mo><mn>1.0</mn><mi>y</mi><mo>=</mo><mn>0.0</mn></mrow><annotation encoding='application/x-tex'>\epsilon x = 1.0&#x2d;1.0y=0.0</annotation></semantics></math> donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>0.0</mn></mrow><annotation encoding='application/x-tex'>x=0.0</annotation></semantics></math>.<br>
Inversement, si on utilise la stratégie du pivot partiel, alors
on doit échanger les 2 équations <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>2</mn></msub><mo>&prime;</mo><mo>=</mo><msub><mi>L</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>L_2&apos;=L_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>1</mn></msub><mo>&prime;</mo><mo>=</mo><msub><mi>L</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>L_1&apos;=L_2</annotation></semantics></math> puis on effectue
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>2</mn></msub><mo>&leftarrow;</mo><msub><mi>L</mi> <mn>2</mn></msub><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&epsi;</mi><msub><mi>L</mi> <mn>1</mn></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>L_2 \leftarrow L_2&apos; &#x2d; \epsilon L_1&apos;</annotation></semantics></math>, ce qui donne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1.0</mn><mo>&minus;</mo><mn>2.0</mn><mi>&epsi;</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mn>1.0</mn><mo>&minus;</mo><mn>3.0</mn><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>(1.0&#x2d;2.0\epsilon) y = 1.0 &#x2d; 3.0 \epsilon </annotation></semantics></math>, remplacée en raison
des erreurs d’arrondi par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1.0</mn><mo>*</mo><mi>y</mi><mo>=</mo><mn>1.0</mn></mrow><annotation encoding='application/x-tex'>1.0*y=1.0</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>1.0</mn></mrow><annotation encoding='application/x-tex'>y=1.0</annotation></semantics></math>, puis on remplace
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>1</mn></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>L_1&apos;</annotation></semantics></math> ce qui donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>3.0</mn><mo>&minus;</mo><mn>2.0</mn><mi>y</mi><mo>=</mo><mn>1.0</mn></mrow><annotation encoding='application/x-tex'>x=3.0&#x2d;2.0y=1.0</annotation></semantics></math>.<br>
On observe dans les deux cas que la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> est proche de la
valeur exacte, mais la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> dans le premier cas est
grossièrement eloignée de la valeur correcte.</p><p>On peut aussi s’intéresser à la sensibilité de la solution d’un
système linéaire à des variations de son second membre. Cela fait intervenir
le nombre de conditionnement de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (voir plus bas) du système (qui
est essentiellement la valeur absolue du rapport de la valeur propre
la plus grande sur la valeur propre la plus petite), plus
ce nombre est grand, plus la solution variera (donc plus on
perd en précision).</p>
<!--TOC section id="sec232" La méthode de factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>-->
<h2 id="sec232" class="section">22.4  La méthode de factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math></h2><!--SEC END --><p> <a id="hevea_default269"></a>
<a id="hevea_default270"></a>
Dans sa forme la plus simple, elle permet d’écrire
une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> comme produit de deux matrices triangulaire
inférieures et supérieures, ce qui ramène la résolution
de système à la résolution de deux systèmes triangulaires.
Pour tenir compte d’éléments diagonaux nuls et pour optimiser 
les erreurs d’arrondi, il est nécessaire d’effectuer des
permutations sur les lignes de la matrice.</p>
<!--TOC subsection id="sec233" Interprétation matricielle du pivot de Gauss-->
<h3 id="sec233" class="subsection">22.4.1  Interprétation matricielle du pivot de Gauss</h3><!--SEC END --><p>
On notera <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> le nombre de lignes et colonnes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (pour
éviter la confusion avec le facteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>) et on
supposera <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> non singulière pour simplifier l’exposition.</p><p>Lorsqu’on réduit la colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> d’une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{A}</annotation></semantics></math>
(partiellement réduite) à partir
de la ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>j+1</annotation></semantics></math> (en supposant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>\tilde{A}_{j,j} \neq 0</annotation></semantics></math>), cela revient à
multiplier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{A}</annotation></semantics></math> à gauche par une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\tilde{L}_j</annotation></semantics></math> créée en
partant de la matrice
identité de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> où on remplace les 0 
colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>, lignes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>j+1</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> par 
le coefficient de la combinaison de ligne effectuée :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>l</mi> <mi>i</mi></msub><mo>&rightarrow;</mo><msub><mi>l</mi> <mi>i</mi></msub><mo>&minus;</mo><mfrac><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></mfrac><msub><mi>l</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>l_i \rightarrow l_i &#x2d; \frac{\tilde{A}_{i,j}}{\tilde{A}_{j,j}} l_j  </annotation></semantics></math>
donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi></msub><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>j</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></mfrac></mtd> <mtd><mn>1</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>l</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></mfrac></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd/></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \tilde{L}_j = \left( \begin{array}{ccccccc}
1 &amp; ... &amp; 0   &amp; 0 &amp; 0 &amp; ... &amp; 0\\
...&amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; 0\\
0 &amp; ... &amp; 1   &amp; 0 &amp; ... &amp; ... &amp; 0\\
0 &amp; ... &amp; 0 &amp; 1  &amp; ... &amp; ... &amp; 0 \\
0 &amp; ... &amp; 0 &amp; &#x2d; \frac{\tilde{A}_{j+1,j}}{\tilde{A}_{j,j}} &amp; 1 &amp; ... &amp; 0 \\
 0 &amp; ... &amp; 0  &amp; .... &amp; 0 &amp; ... &amp; 0 \\
0 &amp; ... &amp; 0 &amp; &#x2d; \frac{\tilde{A}_{l,j}}{\tilde{A}_{j,j}} &amp; 0 &amp; ... &amp; 1\\
\end{array} \right)  </annotation></semantics></math>
On vérifie facilement que l’inverse de cette matrice est
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub><mo>=</mo><msubsup><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mfrac><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>j</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></mfrac></mtd> <mtd><mn>1</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mfrac><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>l</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><mrow><msub><mover><mi>A</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></mfrac></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd/></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> L_j = \tilde{L}_j^{&#x2d;1} = \left( \begin{array}{ccccccc}
1 &amp; ... &amp; 0   &amp; 0 &amp; 0 &amp; ... &amp; 0\\
...&amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; 0\\
0 &amp; ... &amp; 1   &amp; 0 &amp; ... &amp; ... &amp; 0\\
0 &amp; ... &amp; 0 &amp; 1  &amp; ... &amp; ... &amp; 0 \\
0 &amp; ... &amp; 0 &amp; \frac{\tilde{A}_{j+1,j}}{\tilde{A}_{j,j}} &amp; 1 &amp; ... &amp; 0 \\
 0 &amp; ... &amp; 0  &amp; .... &amp; 0 &amp; ... &amp; 0 \\
0 &amp; ... &amp; 0 &amp; \frac{\tilde{A}_{l,j}}{\tilde{A}_{j,j}} &amp; 0 &amp; ... &amp; 1\\
\end{array} \right)  </annotation></semantics></math>
Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est le produit des matrices <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>L_j</annotation></semantics></math> par une matrice réduite
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> qui est triangulaire supérieure
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><msub><mi>L</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>L</mi> <mrow><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>U</mi></mrow><annotation encoding='application/x-tex'> A= L_1...L_{l&#x2d;1} U  </annotation></semantics></math>
On vérifie ensuite que le produit des matrices <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>L</mi> <mrow><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>L_1...L_{l&#x2d;1}</annotation></semantics></math> revient à
remplacer les coefficients de la colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> sous la diagonale 
par ceux de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>L_j</annotation></semantics></math>, ce qui donne une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> triangulaire
inférieure (avec des 1 sur la diagonale). Pour l’obtenir il suffit
au cours de l’algorithme de réduction sous-diagonale du 
pivot de Gauss de stocker le coefficient
de la combinaison linéaire dans une matrice initialisée
à la matrice identité (on peut aussi le faire
en place dans la matrice á réduire).</p><p>Attention, le produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>\tilde{L}_{l&#x2d;1}...\tilde{L}_1</annotation></semantics></math> ne s’obtient pas en
copiant la colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>L</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\tilde{L}_j</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> variant de 1 à
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>l&#x2d;1</annotation></semantics></math>! On peut l’obtenir en faisant
une réduction sous-diagonale de la matrice bloc obtenue en collant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> avec la matrice identité ayant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> lignes.</p>
<!--TOC subsection id="sec234" Factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mi>A</mi><mo>=</mo><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>PA=LU</annotation></semantics></math>-->
<h3 id="sec234" class="subsection">22.4.2  Factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mi>A</mi><mo>=</mo><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>PA=LU</annotation></semantics></math></h3><!--SEC END --><p>
Si on veut mettre en oeuvre la stratégie du pivot partiel (ou en
calcul exact si un coefficient diagonal est nul), il est nécessaire
d’intervertir une ligne de la matrice partiellement réduite
avec une ligne en-dessous. Cela revient à réduire la matrice
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> de départ après échange de ces mêmes lignes. En
conséquence ce n’est pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> qui est le produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math> mais
une matrice obtenue par permutations de lignes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, que
l’on peut écrire comme produit à gauche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> par une matrice
de permutation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.</p><p>Remarque : si à une étape de réduction, tous les coefficients
de la colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> à partir de la ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> sont nuls, on peut
simplement ignorer cette colonne et incrémenter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> de 1 (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>L_j</annotation></semantics></math>
sera l’identité).
Mais ceci différe de la réduction sous forme échelonnée
où on incrémente <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> de 1, mais pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math> (on ne peut plus
alors déduire le rang de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> du nombre de lignes non nulles).
On peut aussi effectuer un échange de colonnes (ce qui revient
à multiplier à droite par une matrice de permutation).</p>
<!--TOC subsection id="sec235" Applications de la décomposition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>-->
<h3 id="sec235" class="subsection">22.4.3  Applications de la décomposition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math></h3><!--SEC END --><p>
On peut résoudre des systèmes linéaires par la factorisation
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>. En effet soit à résoudre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math>. On effectue la permutation
de lignes sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> (correspondant à la matrice de permutation
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>), ce qui donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mi>A</mi><mi>x</mi><mo>=</mo><mi>P</mi><mi>b</mi><mo>=</mo><mi>L</mi><mi>U</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>PAx=Pb=LUx</annotation></semantics></math>, puis on résoud <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>y</mi><mo>=</mo><mi>P</mi><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ly=Pb</annotation></semantics></math>
(système triangulaire inférieur), puis on résoud <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>Ux=y</annotation></semantics></math>
(système triangulaire supérieur).</p><p>Comparaison avec la réduction complète sous forme échelonnée de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">&vert;</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(A|b)</annotation></semantics></math> :
</p><ul class="itemize"><li class="li-itemize">
La factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math> peut reservir plus tard pour résoudre le même
système linéaire avec un autre second membre.
Avec <code>rref</code> il faut dès le départ mettre tous les
vecteurs colonnes second membre à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>.
</li><li class="li-itemize">Le nombre d’opérations pour résoudre un système <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>n,n</annotation></semantics></math>
est moindre. La réduction sous-diagonale nécessite de réduire
les colonnes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> de 1 à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math>, avec pour réduire la colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>j</mi></mrow><annotation encoding='application/x-tex'>n&#x2d;j</annotation></semantics></math> combinaisons linéaire de lignes ayant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>&minus;</mo><mi>j</mi></mrow><annotation encoding='application/x-tex'>n+1&#x2d;j</annotation></semantics></math> coefficients non
nuls, soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mo stretchy="false">(</mo></msubsup><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>&minus;</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mn>3</mn><msup><mi>n</mi> <mn>3</mn></msup><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sum_{j=1}^(n&#x2d;1) (n&#x2d;j)(n+1&#x2d;j)=1/3n^3+O(n^2)</annotation></semantics></math> opérations
(1 opération = 1 multiplication et 1 soustraction).
La résolution des systèmes triangulaires est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^2)</annotation></semantics></math>.
</li><li class="li-itemize">Le calcul est plus favorable au cache mémoire, puisqu’on
travaille sur une portion de plus en plus petite de la matrice.
</li></ul><p>On peut inverser une matrice en utilisant la décomposition
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>. Supposons pour simplifier que la permutation est l’identité.
On calcule d’abord <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>L^{&#x2d;1}</annotation></semantics></math> en utilisant le fait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> est
triangulaire inférieure, voici comment cela est implémenté dans
Xcas (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> est noté <span style="font-family:monospace">l</span>) :
</p><pre class="verbatim">first step compute l^-1, 
solve l*a=y for y a canonical basis vector
  a0=y0, a1=y1-l_{1,0}*a0, ..., ak=yk-sum_{j=0..k-1}(l_kj*aj)
if y=(0,..,0,1,0,...0) (1 at position i), 
  a0=..=a_{i-1}=0, a_i=1 and we start at equation k=i+1 and sum_{j=i...}
-&gt; n^3/6 operations
To store the result in place of l
we first compute all the a2 (there is only 1), then all the a3 (2), etc.
a0=y0, a1=y1-l_{1,0}*a0, ..., ak=yk-sum_{j=0..k-1}(l_kj*aj)
</pre><p>
Puis on résoud <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>L</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>U A^{&#x2d;1}=L^{&#x2d;1}</annotation></semantics></math> colonne par colonne
</p><pre class="verbatim">second step, solve u*inverse=l^-1 (now under the diagonal)
we compute a column of inverse by solving the system: 
u*col(inverse)=corresponding row of l^-1, 
and overwrite the row of l^-1 by solution
u*[x0,..,xn-1]=[a0,...,an]
x_{n-1}=a_{n-1}/u_{n-1,n-1}
x_{n-2}=(a_{n-2}-u_{n-2,n-1}*x_{n-1})/u_{n-2,n-2}
...
x_k=(a_{k}-sum_{j=k+1..n-1} u_{k,j}x_j)/u_{k,k}
-&gt; n^3/2 operations
To store the solution in place, we first compute all the x_{n-1}
put them in the last line of m, then all the x_{n-2}, etc.
</pre><p>Pour une analyse des erreurs d’arrondis dans la décomposition
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>, voir par exemple Higham et les références citées<br>
<code>www.maths.manchester.ac.uk/~higham/narep/narep173.pdf</code></p>
<!--TOC section id="sec236" La factorisation de Cholesky-->
<h2 id="sec236" class="section">22.5  La factorisation de Cholesky</h2><!--SEC END --><p> <a id="hevea_default271"></a>
<a id="hevea_default272"></a>
Dans le cas où la matrice est réelle symétrique définie
positive (ou plus généralement hermitienne), 
on peut obtenir une écriture analogue
mais où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> est la transconjuguée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><msup><mi>U</mi> <mo>*</mo></msup><mi>U</mi><mo>=</mo><mi>L</mi><msup><mi>L</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'> A=U^* U = L L^*  </annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> reste triangulaire
inférieure, mais n’a plus des 1 sur sa diagonale en général. Si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est définie positive, on peut rendre l’écriture unique en
imposant aux coefficients diagonaux de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> d’être réels positifs.</p><p>L’algorithme de calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> est la traduction matricielle de l’algorithme
de Gauss de réduction des formes quadratiques. On a en effet
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>x</mi> <mo>*</mo></msup><mi>A</mi><mi>x</mi><mo>=</mo><msup><mi>x</mi> <mo>*</mo></msup><msup><mi>U</mi> <mo>*</mo></msup><mi>U</mi><mi>x</mi><mo>=</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>U</mi><mi>x</mi><mo stretchy="false">&vert;</mo><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'> x^* A x=x^* U^* U x = ||Ux||^2  </annotation></semantics></math>
les lignes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> (ou les colonnes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>) sont donc les coefficients
des formes linéaires indépendantes qui interviennent dans l’écriture
de la forme quadratique comme somme/différence de carrés de formes
linéaires. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>
est définie positive, seules des sommes interviennent, et les
variables s’éliminent l’une après l’autre (le coefficient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>x_2</annotation></semantics></math> est forcément
non nul lorsqu’on a éliminé <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>x_1</annotation></semantics></math> et ainsi de suite), ceci explique
la forme triangulaire de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>.</p><p>Le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> se fait donc colonne par colonne, en calculant d’abord le
coefficient diagonal comme racine carrée du coefficient diagonal 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>j</mi></msub><mo>=</mo><msqrt><mrow><msub><mi>A</mi> <mrow><mi>j</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></msqrt></mrow><annotation encoding='application/x-tex'>\alpha_j=\sqrt{A_{j,j}}</annotation></semantics></math>.
Ensuite on effectue les combinaisons de ligne sous la forme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>l</mi> <mi>j</mi></msub><mo>&rightarrow;</mo><mfrac><mn>1</mn><mrow><msub><mi>&alpha;</mi> <mi>j</mi></msub></mrow></mfrac><msub><mi>l</mi> <mi>j</mi></msub><mo>,</mo><mspace width="1em"/><msub><mi>l</mi> <mi>i</mi></msub><mo>&rightarrow;</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><msub><mi>l</mi> <mi>i</mi></msub><mo>&minus;</mo><mfrac><mrow><msub><mi>A</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><mrow><msub><mi>&alpha;</mi> <mi>j</mi></msub></mrow></mfrac><msub><mi>l</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'> l_j \rightarrow \frac{1}{\alpha_j}l_j, \quad  l_i \rightarrow \alpha_j l_i &#x2d; \frac{A_{i,j}}{\alpha_j} l_j  </annotation></semantics></math></p><p>On peut aussi tout simplement effectuer le produit de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><msup><mi>L</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>L L^*</annotation></semantics></math> et
chercher les inconnues en commencant par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>l</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>l_{1,1}</annotation></semantics></math> puis on calcule
les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>l</mi> <mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>l_{i,1}</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>i&amp;gt;1</annotation></semantics></math>, etc. En suivant wikipedia, pour une matrice réelle :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>L</mi><mo>=</mo><mrow><mo>[</mo><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>l</mi> <mn>11</mn></msub></mtd> <mtd><mn>0</mn></mtd> <mtd><mi>&ctdot;</mi></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><msub><mi>l</mi> <mn>21</mn></msub></mtd> <mtd><msub><mi>l</mi> <mn>22</mn></msub></mtd> <mtd><mi>&ctdot;</mi></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mi>&dtdot;</mi></mtd> <mtd><mi>&vellip;</mi></mtd></mtr> <mtr><mtd><msub><mi>l</mi> <mrow><mi>n</mi><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>l</mi> <mrow><mi>n</mi><mn>2</mn></mrow></msub></mtd> <mtd><mi>&ctdot;</mi></mtd> <mtd><msub><mi>l</mi> <mrow><mi>n</mi><mi>n</mi></mrow></msub></mtd></mtr></mtable></mrow><mo>]</mo></mrow></mrow><annotation encoding='application/x-tex'> L=\begin{bmatrix}
l_{11}&amp; 0 &amp; \cdots &amp; 0 \\
l_{21} &amp; l_{22}&amp; \cdots &amp; 0\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
l_{n1} &amp; l_{n2} &amp; \cdots &amp; l_{nn}
\end{bmatrix}  </annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mrow><mo>(</mo><mi>L</mi><msup><mi>L</mi> <mi>T</mi></msup><mo>)</mo></mrow> <mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>l</mi> <mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>l</mi> <mrow><mi>j</mi><mi>k</mi></mrow></msub></mrow><mo>=</mo><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>min</mi><mrow><mo>{</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>}</mo></mrow></mrow></munderover><msub><mi>l</mi> <mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>l</mi> <mrow><mi>j</mi><mi>k</mi></mrow></msub></mrow><mo>,</mo><mspace width="thickmathspace"/><mn>1</mn><mo>&leq;</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo>&leq;</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'> a_{ij}=\left(LL^{T}\right)_{ij}={\sum_{k=1}^{n}l_{ik}l_{jk}}=
{\sum_{k=1}^{\min\left\{ i,j\right\} }l_{ik}l_{jk}},\;1\leq i,j\leq n  </annotation></semantics></math>
La matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> étant symétrique, il suffit que les relations ci-dessus
soient vérifiées pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>&leq;</mo><mi>j</mi></mrow><annotation encoding='application/x-tex'>i \leq j</annotation></semantics></math>, 
c’est-à-dire que les éléments <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>l</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>l_{i,j}</annotation></semantics></math> de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> doivent
satisfaire
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>i</mi></munderover><msub><mi>l</mi> <mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>l</mi> <mrow><mi>j</mi><mi>k</mi></mrow></msub></mrow><mo>,</mo><mspace width="thickmathspace"/><mn>1</mn><mo>&leq;</mo><mi>i</mi><mo>&leq;</mo><mi>j</mi><mo>&leq;</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'> a_{ij}={\sum_{k=1}^{i}l_{ik}l_{jk}},\;1\leq i\leq j\leq n  </annotation></semantics></math>
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>i=1</annotation></semantics></math>, on détermine la première colonne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mn>11</mn></msub><mo>=</mo><msub><mi>l</mi> <mn>11</mn></msub><msub><mi>l</mi> <mn>11</mn></msub><mo>,</mo><mspace width="1em"/><msub><mi>a</mi> <mrow><mn>1</mn><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>l</mi> <mn>11</mn></msub><msub><mi>l</mi> <mrow><mi>j</mi><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'> a_{11}=l_{11}l_{11}, \quad a_{1j}=l_{11}l_{j1} </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>l</mi> <mn>11</mn></msub><mo>=</mo><msqrt><mrow><msub><mi>a</mi> <mn>11</mn></msub></mrow></msqrt><mo>,</mo><mspace width="1em"/><msub><mi>l</mi> <mrow><mi>j</mi><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mrow><msub><mi>a</mi> <mrow><mn>1</mn><mi>j</mi></mrow></msub></mrow><mrow><msub><mi>l</mi> <mn>11</mn></msub></mrow></mfrac><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mtext>pour </mtext><mi>j</mi><mi>&gt;</mi><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> l_{11}=\sqrt{a_{11}}, \quad l_{j1}=\frac{a_{1j}}{l_{11}}
\ (\mbox{pour } j&amp;gt;1)  </annotation></semantics></math>
On détermine la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>-ième colonne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo>&leq;</mo><mi>i</mi><mo>&leq;</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>2\leq i\leq n)</annotation></semantics></math> après avoir
calculé les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>i&#x2d;1</annotation></semantics></math> premières colonnes
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>l</mi> <mrow><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>l</mi> <mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>+</mo><mi>&hellip;</mi><mo>+</mo><msub><mi>l</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub><msub><mi>l</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>l</mi> <mrow><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>l</mi> <mrow><mi>j</mi><mn>1</mn></mrow></msub><mo>+</mo><mi>&hellip;</mi><mo>+</mo><msub><mi>l</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub><msub><mi>l</mi> <mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow><annotation encoding='application/x-tex'> a_{ii}=l_{i1}l_{i1}+\ldots+l_{ii}l_{ii}, \quad
a_{ij}=l_{i1}l_{j1}+\ldots+l_{ii}l_{ji}  </annotation></semantics></math>
d’où 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>l</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>=</mo><msqrt><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>&minus;</mo><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>i</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msubsup><mi>l</mi> <mrow><mi>i</mi><mi>k</mi></mrow> <mn>2</mn></msubsup></mrow></mrow></msqrt><mo>,</mo><mspace width="1em"/><msub><mi>l</mi> <mrow><mi>j</mi><mi>i</mi></mrow></msub><mo>=</mo><mfrac><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>&minus;</mo><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>i</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>l</mi> <mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>l</mi> <mrow><mi>j</mi><mi>k</mi></mrow></msub></mrow></mrow><mrow><msub><mi>l</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub></mrow></mfrac><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mtext>pour </mtext><mi>j</mi><mi>&gt;</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> l_{ii}= \sqrt{{a_{ii}&#x2d;{\sum_{k=1}^{i&#x2d;1}l_{ik}^{2}}}}, \quad
l_{ji}=\frac{a_{ij}&#x2d;{\sum_{k=1}^{i&#x2d;1}l_{ik}l_{jk}}}{l_{ii}} \ 
(\mbox{pour } j &amp;gt; i) </annotation></semantics></math>
Pour une matrice hermitienne complexe, il suffit de remplacer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>l</mi> <mrow><mi>i</mi><mi>k</mi></mrow></msub><msub><mi>l</mi> <mrow><mi>j</mi><mi>k</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>l_{ik}l_{jk}</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>l</mi> <mrow><mi>i</mi><mi>k</mi></mrow></msub><mover><mrow><msub><mi>l</mi> <mrow><mi>j</mi><mi>k</mi></mrow></msub></mrow><mo>&#x000AF;</mo></mover></mrow><annotation encoding='application/x-tex'>l_{ik}\overline{l_{jk}}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>l</mi> <mrow><mi>i</mi><mi>k</mi></mrow> <mn>2</mn></msubsup></mrow><annotation encoding='application/x-tex'>l_{ik}^{2}</annotation></semantics></math> par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>l</mi> <mrow><mi>i</mi><mi>k</mi></mrow></msub><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>|l_{ik}|^{2}</annotation></semantics></math>.</p><p>Le nombre d’opérations à effectuer est asymptotiquement
2 fois plus faible que celui pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>. En effet,
pour la première ligne, il faut 1 racine et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> divisions,
pour la deuxième ligne, 1 racine, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> additions, multiplications
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;2</annotation></semantics></math> divisions, ..., pour la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>-ième ligne 1 racine,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(i&#x2d;1)(n&#x2d;i)</annotation></semantics></math> additions, multiplications et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;2</annotation></semantics></math> divisions, au final
le cout est dominé par les additions et multiplications en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>6</mn><msup><mi>n</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>1/6n^3</annotation></semantics></math>
pour chaque, contre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>3</mn><msup><mi>n</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>1/3n^3</annotation></semantics></math> pour la
factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>.</p><p>La commande Xcas correspondante est <code>cholesky</code> et renvoie
la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>.</p>
<!--TOC section id="sec237" Conditionnement-->
<h2 id="sec237" class="section">22.6  Conditionnement</h2><!--SEC END --><p> <a id="hevea_default273"></a> <a id="hevea_default274"></a>
Le conditionnement mesure la sensibilité de la solution renvoyée d’un
système linéaire aux données du problème.</p><p>Soit le système linéaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math> de solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>x=A^{&#x2d;1}b</annotation></semantics></math>, 
supposons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> connu avec une erreur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi></mrow><annotation encoding='application/x-tex'>e</annotation></semantics></math>, alors la solution renvoyée
sera <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>+</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>e</mi></mrow><annotation encoding='application/x-tex'>x+A^{&#x2d;1}e</annotation></semantics></math>, on a donc une erreur relative sur la solution de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mo stretchy="false">&Vert;</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>e</mi><mo stretchy="false">&Vert;</mo></mrow><mrow><mo stretchy="false">&Vert;</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">&Vert;</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>e</mi><mo stretchy="false">&Vert;</mo></mrow><mrow><mo stretchy="false">&Vert;</mo><mi>e</mi><mo stretchy="false">&Vert;</mo></mrow></mfrac><mfrac><mrow><mo stretchy="false">&Vert;</mo><mi>e</mi><mo stretchy="false">&Vert;</mo></mrow><mrow><mo stretchy="false">&Vert;</mo><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow></mfrac><mfrac><mrow><mo stretchy="false">&Vert;</mo><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow><mrow><mo stretchy="false">&Vert;</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow></mfrac><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>e</mi><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><mi>b</mi><mo stretchy="false">&vert;</mo></mrow></mfrac><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> \frac{\|A^{&#x2d;1}e\|}{\|A^{&#x2d;1}b\|} = \frac{\|A^{&#x2d;1}e\|}{\|e\|} 
\frac{\|e\|}{\|b\|}
\frac{\|b\|}{\|A^{&#x2d;1}b\|}  \leq |||A^{&#x2d;1}|||  \frac{|e|}{|b|} |||A|||   </annotation></semantics></math>
(la dernière inégalité s’obtient en écrivant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>b=A(A^{&#x2d;1}b)</annotation></semantics></math>).
On en déduit que le rapport de l’erreur relative sur la solution par l’erreur
relative du second membre est majorée par
le produit de la norme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (en tant qu’application linéaire)
par la norme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A^{&#x2d;1}</annotation></semantics></math>, ce produit est appelé conditionnement
de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (ou parfois nombre de condition de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> en adoptant
la terminologie anglo-saxonne).</p><p>On remarquera que le conditionnement dépend du choix de la norme sur
l’espace vectoriel.
Si on prend comme norme la norme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>L^2</annotation></semantics></math>, le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|||A|||</annotation></semantics></math>
nécessite de maximiser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mrow><mi>&lt;</mi><mi>A</mi><mi>b</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mi>b</mi><mi>&gt;</mi></mrow></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{&amp;lt;Ab|Ab&amp;gt;}</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> de norme 1, ce qui revient
à maximiser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mrow><mi>&lt;</mi><mi>b</mi><mo stretchy="false">&vert;</mo><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi><mi>b</mi><mi>&gt;</mi></mrow></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{&amp;lt;b|A^* A b&amp;gt;}</annotation></semantics></math>. En diagonalisant la matrice hermitienne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A^* A</annotation></semantics></math>, on voit qu’il suffit d’en trouver la plus grande valeur
propre et d’en prendre la racine carrée. Les valeurs propres de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A^*A</annotation></semantics></math> sont appelées valeurs singulières de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (ce sont des
réels positifs). Le même raisonnement pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A^{&#x2d;1}</annotation></semantics></math> (dont les
valeurs singulières sont les inverses des valeurs singulières 
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math><sup><a id="text37" href="#note37">1</a></sup>) nous donne alors le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 50</span>  <em>
Lorsqu’on résoud un système linéaire </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math><em>, </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math><em> matrice connue
précisément et inversible, </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math><em> connu avec une erreur relative en
norme </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>L^2</annotation></semantics></math><em>, l’erreur relative en norme </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>L^2</annotation></semantics></math><em> sur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math><em> est au plus
multipliée par
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>K</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mi>&lambda;</mi> <mi>n</mi></msub></mrow><mrow><msub><mi>&lambda;</mi> <mn>1</mn></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'> K_2(A)= \frac{\lambda_n}{\lambda_1}  </annotation></semantics></math><em>
oú </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda_n</annotation></semantics></math><em> [resp. </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>\lambda_1</annotation></semantics></math><em>] est la plus grande [resp. plus
petite] valeur singulière de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math><em> (racines carrées des
valeurs propres de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A^*A</annotation></semantics></math><em>).<br>
Ce facteur d’amplification des erreurs relatives est évidemment
supérieur ou égal à 1. Il est égal à 1 si la matrice est
unitaire (puisque </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math><em> est une matrice
d’isométrie ou car </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msup><mi>A</mi> <mo>*</mo></msup><mo>=</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>AA^*=I</annotation></semantics></math><em>). 
S’il est de l’ordre de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>c</mi></msup></mrow><annotation encoding='application/x-tex'>2^c</annotation></semantics></math><em> on perdra (au plus) </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math><em> bits de
précision sur la mantisse de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math><em>.
</em></div><p>
Avec Xcas, les <span style="font-weight:bold">valeurs singulières</span><a id="hevea_default275"></a> 
<a id="hevea_default276"></a>
s’obtiennent par l’instruction
<code>SVL(A)</code>, le conditionnement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>L^2</annotation></semantics></math> par <code>COND(A,2)</code>.
Attention, les valeurs singulières de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> ne sont pas les valeurs
absolues des valeurs propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (c’est le cas si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> 
commute avec sa transconjuguée mais ce n’est pas général).
On peut utiliser la méthode de la puissance (cf. infra) pour estimer la plus
grande valeur singulière de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (donc sans diagonaliser complètement
la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A^*A</annotation></semantics></math>), et de même sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A^{&#x2d;1}</annotation></semantics></math> (en utilisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>
ou Cholesky pour trouver les itérées sans calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A^{&#x2d;1}</annotation></semantics></math>).</p><p>On peut aussi prendre la norme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>1</mn></msup></mrow><annotation encoding='application/x-tex'>L^1</annotation></semantics></math> sur l’espace vectoriel, dans ce
cas la norme de matrice correspondante est la norme de colonne (exercice!),
le maximum des sommes valeurs absolues des éléments
des colonnes (<code>colNorm(A)</code> en Xcas) et le conditonnement
est le produit de <code>colNorm(A)</code> par <code>colNorm(inv(A))</code>
qui est renvoyé par <code>COND(A)</code> en Xcas.</p><p>Si la matrice du système <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (de nombre de condition noté
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&kappa;</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\kappa(A)</annotation></semantics></math>) est elle-même connue avec une
certaine incertitude, alors pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>&Delta;</mi><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>||\Delta A||</annotation></semantics></math> suffisamment petit,
la solution de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>+</mo><mi>&Delta;</mi><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>&Delta;</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>+</mo><mi>&Delta;</mi><mi>b</mi></mrow><annotation encoding='application/x-tex'>(A+\Delta A)(x+\Delta x)=b+\Delta b</annotation></semantics></math> vérifie
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>&Delta;</mi><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow></mfrac><mo>&leq;</mo><mfrac><mrow><mi>&kappa;</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>&minus;</mo><mi>&kappa;</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>&Delta;</mi><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow></mfrac></mrow></mfrac><mrow><mo>(</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>&Delta;</mi><mi>b</mi><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><mi>b</mi><mo stretchy="false">&vert;</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>&Delta;</mi><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow></mfrac><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\frac {|\Delta x |}{|x|}\leq
\frac{\kappa(A)}{1&#x2d;\kappa(A)\frac{||\Delta A||}{||A||}}
\left(\frac{|\Delta b|}{|b|}+\frac{||\Delta A||}{||A||}
\right)  </annotation></semantics></math>
En effet, on a 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mi>&Delta;</mi><mi>x</mi><mo>=</mo><mi>&Delta;</mi><mi>b</mi><mo>&minus;</mo><mi>&Delta;</mi><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>&Delta;</mi><mi>x</mi><mo stretchy="false">)</mo><mo>&Rightarrow;</mo><mi>&Delta;</mi><mi>x</mi><mo>=</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>&Delta;</mi><mi>b</mi><mo>&minus;</mo><mi>&Delta;</mi><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>&Delta;</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>A \Delta x =\Delta b &#x2d; \Delta A(x+\Delta x)
\Rightarrow \Delta x = A^{&#x2d;1}(\Delta b &#x2d; \Delta A(x+\Delta x))   </annotation></semantics></math>
donc en norme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&Vert;</mo><mi>&Delta;</mi><mi>x</mi><mo stretchy="false">&Vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mrow><mo>(</mo><mfrac><mrow><mo stretchy="false">&Vert;</mo><mi>&Delta;</mi><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow><mrow><mo stretchy="false">&Vert;</mo><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow></mfrac><mo stretchy="false">&Vert;</mo><mi>A</mi><mi>x</mi><mo stretchy="false">&Vert;</mo><mo>+</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>&Delta;</mi><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow></mfrac><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mo stretchy="false">&Vert;</mo><mi>x</mi><mo stretchy="false">&Vert;</mo><mo>+</mo><mo stretchy="false">&Vert;</mo><mi>&Delta;</mi><mi>x</mi><mo stretchy="false">&Vert;</mo><mo stretchy="false">)</mo><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\| \Delta x \| \leq |||A^{&#x2d;1}||| \left(
\frac{\|\Delta b\|}{\|b\|}\|Ax\|
+ \frac{||| \Delta A |||}{|||A|||} |||A||| (\|x\|+\|\Delta x\|)
\right) </annotation></semantics></math>
puis :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mo stretchy="false">&Vert;</mo><mi>&Delta;</mi><mi>x</mi><mo stretchy="false">&Vert;</mo></mrow><mrow><mo stretchy="false">&Vert;</mo><mi>x</mi><mo stretchy="false">&Vert;</mo></mrow></mfrac><mo>&leq;</mo><mi>&kappa;</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mrow><mo>(</mo><mfrac><mrow><mo stretchy="false">&Vert;</mo><mi>&Delta;</mi><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow><mrow><mo stretchy="false">&Vert;</mo><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow></mfrac><mo>+</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>&Delta;</mi><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mi>A</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow></mfrac><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mfrac><mrow><mo stretchy="false">&Vert;</mo><mi>&Delta;</mi><mi>x</mi><mo stretchy="false">&Vert;</mo></mrow><mrow><mo stretchy="false">&Vert;</mo><mi>x</mi><mo stretchy="false">&Vert;</mo></mrow></mfrac><mo>)</mo></mrow><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\frac{\| \Delta x \|}{\|x\|} \leq \kappa(A)
\left(\frac{\|\Delta b\|}{\|b\|}
+ \frac{||| \Delta A |||}{|||A|||} \left(1+\frac{\| \Delta x \|}{\|x\|}\right) 
\right) </annotation></semantics></math></p>
<!--TOC section id="sec238" Réduction des endomorphismes-->
<h2 id="sec238" class="section">22.7  Réduction des endomorphismes</h2><!--SEC END -->
<!--TOC subsection id="sec239" Le polynôme minimal (Krylov)-->
<h3 id="sec239" class="subsection">22.7.1  Le polynôme minimal (Krylov)</h3><!--SEC END --><p><a id="hevea_default277"></a>
<a id="hevea_default278"></a>
On prend un vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> au hasard et on calcule la relation linéaire
de degré minimal entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>v</mi></mrow><annotation encoding='application/x-tex'>Av</annotation></semantics></math>, ..., <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mi>n</mi></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>A^nv</annotation></semantics></math> en cherchant
le premier vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi></mrow><annotation encoding='application/x-tex'>w</annotation></semantics></math> du noyau de la matrice obtenue en écrivant
les vecteurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>v</mi></mrow><annotation encoding='application/x-tex'>Av</annotation></semantics></math>, etc. en colonne dans cet ordre. Les
coordonnées de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi></mrow><annotation encoding='application/x-tex'>w</annotation></semantics></math> donnent alors par ordre de degré croissant
un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré minimal tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mi>v</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P(A)v=0</annotation></semantics></math> donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> divise le polynôme minimal <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>. Donc si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est de
degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>M</mi></mrow><annotation encoding='application/x-tex'>P=M</annotation></semantics></math>. Sinon, il faut vérifier que le polynôme obtenu 
annule la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>. On peut aussi calculer le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
précédent pour quelques vecteurs aléatoires et prendre le PPCM des
polynômes obtenus, il suffit de s’arrêter lorsque l’espace engendré
par les vecteurs et les images par les puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> engendrent
tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math>. On peut aussi utiliser l’algorithme de Danilevsky (voir
plus bas) qui est intéressant sur les corps finis.</p><p><span style="font-weight:bold">Exemple 1</span><br>
Polynôme minimal de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>4</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\left(\begin{array}{cc} 1 &amp; &#x2d;1 \\ 2 &amp; 4
\end{array}\right) </annotation></semantics></math>. On prend <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v=(1,0)</annotation></semantics></math>, la matrice à réduire est
alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>11</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>10</mn></mtd> <mtd><mn>38</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>&rightarrow;</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>6</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>5</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \left(\begin{array}{ccc} 1 &amp; &#x2d;1 &amp; &#x2d;11 \\ 2 &amp; 10 &amp; 38
\end{array}\right) \rightarrow 
\left(\begin{array}{ccc} 1 &amp; 0 &amp; &#x2d;6 \\ 0 &amp; 1 &amp; 5
\end{array}\right)
 </annotation></semantics></math>
Le noyau est engendré par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>6</mn><mo>,</mo><mn>5</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(&#x2d;6,5,&#x2d;1)</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>5</mn><mi>x</mi><mo>&minus;</mo><mn>6</mn></mrow><annotation encoding='application/x-tex'>P=&#x2d;x^2+5x&#x2d;6</annotation></semantics></math>.</p><p><span style="font-weight:bold">Exemple 2</span><br>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> A=\left(\begin{array}{ccc}
 3 &amp; 2 &amp; &#x2d;2 \\
&#x2d;1 &amp;0 &amp;1 \\
1 &amp; 1 &amp; 0 
\end{array}\right)  </annotation></semantics></math>
en prenant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v=(1,0,0)</annotation></semantics></math> on obtient la matrice :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mn>5</mn></mtd> <mtd><mn>7</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>&rightarrow;</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>3</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> A=\left(\begin{array}{cccc}
1 &amp; 3 &amp; 5 &amp; 7 \\
0 &amp; &#x2d;1 &amp; &#x2d;2 &amp; &#x2d;3 \\
0 &amp; 1 &amp; 2 &amp; 3
\end{array}\right) \rightarrow
\left(\begin{array}{cccc}
1 &amp; 0 &amp; &#x2d;1 &amp; &#x2d;2 \\
0 &amp; 1 &amp; 2 &amp; 3 \\
0 &amp; 0 &amp; 0 &amp; 0 
\end{array}\right)  </annotation></semantics></math>
le permier vecteur du noyau est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(&#x2d;1,2,&#x2d;1)</annotation></semantics></math> d’où un polynôme divisant
le polynôme minimal <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>&#x2d;x^2+2x&#x2d;1</annotation></semantics></math>.</p><p><span style="font-weight:bold">Cout</span><br>
Le calcul de la suite des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub><mo>=</mo><msup><mi>A</mi> <mi>k</mi></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>v_k=A^kv</annotation></semantics></math> se fait par valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> croissantes 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_{k+1}=Av_k</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&times;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>n \times O(n^2)</annotation></semantics></math> opérations soit en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3)</annotation></semantics></math>
(il ne faut pas calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>A^k</annotation></semantics></math> ce qui nécessiterait <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^4)</annotation></semantics></math>
opérations).<br>
On peut améliorer la complexité asymptotique de la manière 
suivante : on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>,</mo><mi>A</mi><mi>v</mi></mrow><annotation encoding='application/x-tex'>v, Av</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>A^2</annotation></semantics></math> avec une multiplication rapide
de matrices à la Strassen, on multiplie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>A^2</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>,</mo><mi>A</mi><mi>v</mi></mrow><annotation encoding='application/x-tex'>v,Av</annotation></semantics></math> obtenant ainsi
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mn>2</mn></msup><mi>v</mi><mo>,</mo><msup><mi>A</mi> <mn>3</mn></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>A^2v, A^3v</annotation></semantics></math>, on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mn>4</mn></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>A</mi> <mn>2</mn></msup><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>A^4=(A^2)^2</annotation></semantics></math> on multiplie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>A^4</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>,</mo><mi>A</mi><mi>v</mi><mo>,</mo><msup><mi>A</mi> <mn>2</mn></msup><mi>v</mi><mo>,</mo><msup><mi>A</mi> <mn>3</mn></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>v,Av,A^2v,A^3v</annotation></semantics></math>
obtenant ainsi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mn>4</mn></msup><mi>v</mi><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>A</mi> <mn>7</mn></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>A^4v,...,A^7v</annotation></semantics></math>, etc. Il
faut faire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>log</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\log_2(n)</annotation></semantics></math> multiplications de matrices, 
on a donc une complexité en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mrow><msub><mi>log</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow></msup><mi>log</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^{\log_2(7)}\log(n))</annotation></semantics></math> avec une 
multiplication à la Strassen, mais il 
faudrait des valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> vraiment grandes (plus d’une dizaine
de millions donc impossible à stocker en mémoire)
pour que cet algorithme soit intéressant comme le montre le calcul

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">fsolve(n^(log(7.)/log(2)-3)*log(n)/log(2)=1,n=1e5)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC subsection id="sec240" Le polynôme caractéristique-->
<h3 id="sec240" class="subsection">22.7.2  Le polynôme caractéristique</h3><!--SEC END --><p>
<a id="hevea_default279"></a>
Pour une matrice générique, le polynôme caractéristique est égal
au polynôme minimal, il est donc intéressant de chercher si le polynôme
annulateur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> sur un vecteur aléatoire est de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, 
car le temps de calcul du polynôme caractéristique est alors en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3)</annotation></semantics></math>. 
Si cette méthode probabiliste échoue, on se
rabat sur une des méthode déterministe ci-dessous:
</p><ul class="itemize"><li class="li-itemize">
on utilise la formule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>det</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\det(\lambda I &#x2d;A)</annotation></semantics></math> déterminé par
une des méthodes de calcul de déterminant ci-dessus. Cela
nécessite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3)</annotation></semantics></math> opérations mais avec des coefficients 
polynômes en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi></mrow><annotation encoding='application/x-tex'>\lambda</annotation></semantics></math>.
</li><li class="li-itemize">on fait une interpolation de Lagrange en donnant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> valeurs
distinctes à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi></mrow><annotation encoding='application/x-tex'>\lambda</annotation></semantics></math>. Ce qui nécessite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^4)</annotation></semantics></math> opérations mais avec
des coefficients indépendants de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi></mrow><annotation encoding='application/x-tex'>\lambda</annotation></semantics></math>, de plus cette méthode 
est facile à programmer de manière parallèle.
</li><li class="li-itemize">si la matrice est à coefficients entiers
on peut utiliser la méthode de Hessenberg (voir ci-dessous), on calcule
une borne à priori sur les coefficients du polynôme caractéristique
(cf. Cohen p.58-59) :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>n</mi></mtd></mtr> <mtr><mtd><mi>n</mi><mo>&minus;</mo><mi>k</mi></mtd></mtr></mtable><mo>)</mo></mrow><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>k</mi><msup><mo stretchy="false">)</mo> <mrow><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow></msup><mo stretchy="false">&vert;</mo><mi>M</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow></msup><mspace width="mediummathspace"/><mo>,</mo></mrow><annotation encoding='application/x-tex'> |P_k| \leq \left( \begin{array}{c} n \\ n&#x2d;k\end{array}\right) 
(n&#x2d;k)^{(n&#x2d;k)/2} |M|^{n&#x2d;k} \ , </annotation></semantics></math>
on calcule le polynôme caractéristique modulo suffisamment
de petits entiers puis on remonte par les restes chinois.
</li></ul>
<!--TOC subsection id="sec241" La méthode de Hessenberg-->
<h3 id="sec241" class="subsection">22.7.3  La méthode de Hessenberg</h3><!--SEC END --><p><a id="hevea_default280"></a>
Pour les matrices à coefficients de taille bornée (modulaires par exemple)
on préfère la méthode de Hessenberg qui est plus
efficace, car elle nécessite de l’ordre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>n^3</annotation></semantics></math> opérations sur
les coefficients.</p><p>On se raméne d’abord à une matrice triangulaire supérieure à
une diagonale près qui est semblable à la
matrice de départ puis on
applique une formule de récurrence pour calculer les coefficients
du polynôme caractéristique.</p><p><span style="font-weight:bold">Algorithme de réduction de Hessenberg:</span><br>
Dans une colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> donnée de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math>, 
on cherche à partir de la ligne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m+1</annotation></semantics></math> un coefficient non nul. S’il n’y en a pas on passe à la colonne
suivante. S’il y en a un en ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>, on échange les lignes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m+1</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math> et les colonnes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m+1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>. Ensuite pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>&geq;</mo><mi>m</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>i\geq m+2</annotation></semantics></math>,
soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>=</mo><msub><mi>H</mi> <mrow><mi>i</mi><mo>,</mo><mi>m</mi></mrow></msub><mo stretchy="false">/</mo><msub><mi>H</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>m</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>u=H_{i,m}/H_{m+1,m}</annotation></semantics></math>, on remplace alors la ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>L_i</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math>
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mi>i</mi></msub><mo>&minus;</mo><mi>u</mi><msub><mi>L</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>L_i&#x2d;uL_{m+1}</annotation></semantics></math> et la colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>C_{m+1}</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>u</mi><msub><mi>C</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>C_{m+1}+uC_i</annotation></semantics></math>
ce qui revient “à remplacer le vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>e_{m+1}</annotation></semantics></math> de la base
par le vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>u</mi><msub><mi>e</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>e_{m+1}+ue_i</annotation></semantics></math>” ou plus précisément
à multiplier à gauche par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>u</mi></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\left(\begin{array}{cc}
1 &amp; 0 \\ &#x2d;u &amp; 1\end{array}\right) </annotation></semantics></math> 
et à droite par la matrice inverse
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mi>u</mi></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\left(\begin{array}{cc}
1 &amp; 0 \\ u &amp; 1\end{array}\right) </annotation></semantics></math> 
(en utilisant les lignes et colonnes
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m+1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math> au lieu de 1 et 2 pour ces matrices). 
Ceci a pour effet d’annuler le coefficient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>H</mi> <mrow><mi>i</mi><mo>,</mo><mi>m</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>H_{i,m}</annotation></semantics></math>
dans la nouvelle matrice.</p><p>On obtient ainsi en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3)</annotation></semantics></math> opérations
une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>H&apos;</annotation></semantics></math> semblable à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> de la forme :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center center"><mtr><mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>1</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>1</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr> <mtr><mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>2</mn><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>3</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>3</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>3</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>3</mn><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>4</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>4</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mn>4</mn><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr> <mtr><mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>n</mi><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>
\left(\begin{array}{cccccc}
H&apos;_{1,1} &amp; H&apos;_{1,2} &amp; ... &amp; H&apos;_{1,n&#x2d;2} &amp; H&apos;_{1,n&#x2d;1} &amp; H&apos;_{1,n}\\
H&apos;_{2,1} &amp; H&apos;_{2,2} &amp; ... &amp; H&apos;_{2,n&#x2d;2} &amp; H&apos;_{2,n&#x2d;1} &amp; H&apos;_{2,n} \\
0       &amp; H&apos;_{3,2} &amp; ... &amp; H&apos;_{3,n&#x2d;2} &amp; H&apos;_{3,n&#x2d;1} &amp; H&apos;_{3,n} \\
0       &amp; 0       &amp; ... &amp; H&apos;_{4,n&#x2d;2} &amp; H&apos;_{4,n&#x2d;1} &amp; H&apos;_{4,n} \\
\vdots  &amp; \vdots  &amp; ... &amp; \vdots &amp; \vdots  &amp;  \vdots \\
0       &amp; 0       &amp; ... &amp; 0 &amp; H&apos;_{n,n&#x2d;1} &amp; H&apos;_{n,n}
\end{array} \right)
 </annotation></semantics></math>
On calcule alors le polynôme caractéristique de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>H&apos;</annotation></semantics></math> par une récurrence
qui s’obtient en développant le déterminant par rapport à la dernière
colonne :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>h</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>det</mtext><mo stretchy="false">(</mo><mi>&lambda;</mi><msub><mi>I</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>H</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">(</mo><mi>&lambda;</mi><mo>&minus;</mo><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><msub><mi>h</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>n</mi><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><msub><mi>h</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>+</mo></mtd></mtr> <mtr><mtd/> <mtd/> <mtd><mo lspace="verythinmathspace" rspace="0em">+</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn><mo>,</mo><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>n</mi><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><msub><mi>h</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>3</mn></mrow></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 h_n(\lambda) = \mbox{det}(\lambda I_n&#x2d;H)&amp;=&amp; 
(\lambda&#x2d;H&apos;_{n,n}) h_{n&#x2d;1}(\lambda) &#x2d;(&#x2d;H&apos;_{n&#x2d;1,n}) (&#x2d;H&apos;_{n,n&#x2d;1}) 
h_{n&#x2d;2}(\lambda) + \\
&amp; &amp; 
    + (&#x2d;H&apos;_{n&#x2d;2,n}) (&#x2d;H&apos;_{n,n&#x2d;1}) (&#x2d;H&apos;_{n&#x2d;1,n&#x2d;2}) h_{n&#x2d;3}(\lambda) &#x2d; ...
 \end{matrix} </annotation></semantics></math>
où les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>h</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>h_i</annotation></semantics></math> s’entendent en gardant les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math> premières lignes/colonnes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>H&apos;</annotation></semantics></math>.
On peut écrire cette formule pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&leq;</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>m\leq n</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>h</mi> <mi>m</mi></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>&lambda;</mi><mo>&minus;</mo><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>m</mi><mo>,</mo><mi>m</mi></mrow></msub><mo stretchy="false">)</mo><msub><mi>h</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>m</mi><mo>&minus;</mo><mi>i</mi><mo>,</mo><mi>m</mi></mrow></msub><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>i</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>m</mi><mo>&minus;</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo>&minus;</mo><mi>j</mi></mrow></msub><msub><mi>h</mi> <mrow><mi>i</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> h_m(\lambda)= (\lambda &#x2d; H&apos;_{m,m}) h_{m&#x2d;1}(\lambda)
&#x2d;\sum_{i=1}^{m&#x2d;1} H&apos;_{m&#x2d;i,m} \prod_{j=1}^{i&#x2d;1} H&apos;_{m&#x2d;j+1,m&#x2d;j} h_{i&#x2d;1}(\lambda) </annotation></semantics></math>
Pour effectuer cette récurrence de manière efficace, on conserve
les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>h</mi> <mi>m</mi></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>h_m(\lambda)</annotation></semantics></math> dans un tableau de polynômes et on utilise une 
variable produit contenant successivement les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo><mi>H</mi><msub><mo>&prime;</mo> <mrow><mi>m</mi><mo>&minus;</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>m</mi><mo>&minus;</mo><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>\prod H&apos;_{m&#x2d;j+1,m&#x2d;j}</annotation></semantics></math>.</p><p><span style="font-weight:bold">Remarques</span>
Une variante de la réduction ci-dessus utilise des matrices de
<span style="font-weight:bold">rotation de Givens</span><a id="hevea_default281"></a> : il s’agit d’une rotation
dans le plan engendré par deux vecteurs de base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>e</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>e_i,e_j</annotation></semantics></math> 
prolongée par l’identité. On doit alors effectuer 
deux combinaisons linéaires de ligne
et deux combinaisons linéaires de colonnes par transformation
donc deux fois plus de calculs, mais l’avantage est que la matrice
de transformation est unitaire (donc facile à inverser, et bien
conditionnée).</p><p>On peut aussi utiliser des <span style="font-weight:bold">matrices de
Householder</span><a id="hevea_default282"></a> 
pour se ramener à une forme de Hessenberg.
La matrice de Householder associée à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> est définie par ;
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>H</mi><mo>=</mo><mi>I</mi><mo>&minus;</mo><mn>2</mn><mfrac><mrow><mi>v</mi><msup><mi>v</mi> <mi>t</mi></msup></mrow><mrow><mo stretchy="false">&Vert;</mo><mi>v</mi><msup><mo stretchy="false">&Vert;</mo> <mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'>H=I&#x2d;2\frac{v v^t}{\|v\|^2} </annotation></semantics></math>
c’est la matrice de la symétrie par rapport à l’hyperplan 
perpendiculaire à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mi>v</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>v</mi></mrow><annotation encoding='application/x-tex'>Hv=&#x2d;v</annotation></semantics></math> et pour tout vecteur
perpendiculaire à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mi>w</mi><mo>=</mo><mi>w</mi></mrow><annotation encoding='application/x-tex'>Hw=w</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> est orthogonale.
On l’utilise en général pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>v=a&#x2d;b</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><mi>a</mi><mo stretchy="false">&Vert;</mo><mo>=</mo><mo stretchy="false">&Vert;</mo><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow><annotation encoding='application/x-tex'>\|a\|=\|b\|</annotation></semantics></math>,
on a alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ha=b</annotation></semantics></math> puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><annotation encoding='application/x-tex'>H(a&#x2d;b)=b&#x2d;a</annotation></semantics></math> car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>v=a&#x2d;b</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>H(a+b)=a+b</annotation></semantics></math>
car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> est orthogonal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>a+b</annotation></semantics></math> (puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><mi>a</mi><mo stretchy="false">&Vert;</mo><mo>=</mo><mo stretchy="false">&Vert;</mo><mi>b</mi><mo stretchy="false">&Vert;</mo></mrow><annotation encoding='application/x-tex'>\|a\|=\|b\|</annotation></semantics></math>).</p><p>On peut enfin utiliser l’algorithme de <span style="font-weight:bold">Danilevsky</span><a id="hevea_default283"></a>. 
Il s’agit un peu
d’un analogue de la méthode du pivot de Gauss pour se ramener
à une matrice companion semblable (avec des 1 sur
la diagonale au-dessus de la diagonale
principale et le polynôme caractéristique en dernière
ligne). Cela se fait ligne par ligne en commençant par
la ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>k=0</annotation></semantics></math>. On multiplie à gauche par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> une matrice identité
dont la ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math> est remplacée par la ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> de la matrice
et à droite par son inverse <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>P^{&#x2d;1}</annotation></semantics></math>, qui est une matrice identité sauf
en ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math>. Comme la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math>-ième ligne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième
ligne de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, le produit à droite par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>P^{&#x2d;1}</annotation></semantics></math> va remplacer
la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième ligne de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> par la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math>-ième ligne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>=</mo><mi>P</mi><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>I=PP^{&#x2d;1}</annotation></semantics></math>.
Le produit à gauche par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> préserve les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> premières lignes.
Quand on programme cet algorithme, on traduit le produit à droite
par une opération sur les colonnes, et le produit à gauche par
une opération sur les lignes, on ne doit faire ces opérations qu’à 
partir de la ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>.</p><p>Exemple sur une matrice 3,3 :
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a:=[[1,2,3],[1,-1,1],[2,-3,3]] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

Réduction de la 1ère ligne :
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">p:=idn(3):; p[1]:=a[0]; inv(p); a*inv(p); b:=p*a*inv(p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

Deuxième ligne :
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">p:=idn(3):; p[2]:=b[1]; inv(p); b*inv(p); c:=p*b*inv(p) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

on lit le polynôme caractéristique en dernière ligne
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">[1,op(revlist(-c[2]))];charpoly(a) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

Notons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mn>0</mn></mrow></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(a_{k,0},...,a_{k,n&#x2d;1})</annotation></semantics></math> la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième ligne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>,
donc la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math>-i‘eme ligne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, alors la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math>-ième ligne de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>P^{&#x2d;1}</annotation></semantics></math> a comme coefficients <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="false">/</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>&#x2d;a_{k,j}/a_{k,k+1}</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>j\neq k</annotation></semantics></math> et 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>1/a_{k,k+1}</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>j=k</annotation></semantics></math>. 
Les opérations de colonnes correspondant à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>AP^{&#x2d;1}</annotation></semantics></math> sont donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mi>j</mi></msub><mo>&leftarrow;</mo><msub><mi>C</mi> <mi>j</mi></msub><mo>&minus;</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="false">/</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>C</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>C_j \leftarrow C_j&#x2d;a_{k,j}/a_{k,k+1}C_{k+1}</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>j \neq k</annotation></semantics></math> et 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&leftarrow;</mo><msub><mi>C</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">/</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>C_{k+1} \leftarrow C_{k+1}/a_{k,k+1}</annotation></semantics></math>. Puis l’opération de ligne
correspondant à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mi>A</mi></mrow><annotation encoding='application/x-tex'>PA</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&leftarrow;</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>j</mi></msub><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>j</mi></mrow></msub><msub><mi>L</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>L_{k+1} \leftarrow \sum_j a_{k,j} L_j</annotation></semantics></math> (on peut
commencer la somme à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math> si on initialise la ligne à
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mn>0</mn></mrow></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>,</mo><mn>0</mn><mo>,</mo><mo>.</mo><mo>.</mo><mn>.0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(0,a_{k,0},..,a_{k,k},0,...0)</annotation></semantics></math>).
Dans l’exemple, pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>k=0</annotation></semantics></math> on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>a_{0,1}=2</annotation></semantics></math> donc on fait
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>C</mi> <mn>1</mn></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><msub><mi>C</mi> <mn>2</mn></msub><mo>,</mo><msub><mi>C</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>C</mi> <mn>2</mn></msub><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><msub><mi>C</mi> <mn>3</mn></msub><mo>=</mo><msub><mi>C</mi> <mn>3</mn></msub><mo>&minus;</mo><mn>3</mn><msub><mi>C</mi> <mn>2</mn></msub><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>C_1=C_1&#x2d;1/2C_2, C_2=C_2/2, C_3=C_3&#x2d;3C_2/2</annotation></semantics></math> puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>L</mi> <mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>L</mi> <mn>2</mn></msub><mo>+</mo><mn>3</mn><msub><mi>L</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>L_2=L_1+2L_2+3L_3</annotation></semantics></math>.
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k=1</annotation></semantics></math>, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>=</mo><mn>55</mn><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>b_{1,2}=55/2</annotation></semantics></math> donc on fait 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>C</mi> <mn>1</mn></msub><mo>&minus;</mo><mn>27</mn><mo stretchy="false">/</mo><mn>55</mn><msub><mi>C</mi> <mn>3</mn></msub><mo>,</mo><msub><mi>C</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>C</mi> <mn>2</mn></msub><mo>+</mo><mn>9</mn><mo stretchy="false">/</mo><mn>55</mn><msub><mi>C</mi> <mn>3</mn></msub><mo>,</mo><msub><mi>C</mi> <mn>3</mn></msub><mo>=</mo><mn>2</mn><mo stretchy="false">/</mo><mn>55</mn><msub><mi>C</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>C_1=C_1&#x2d;27/55C_3, C_2=C_2+9/55C_3, C_3=2/55C_3</annotation></semantics></math> puis
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>3</mn></msub><mo>=</mo><mn>27</mn><mo stretchy="false">/</mo><mn>2</mn><msub><mi>L</mi> <mn>1</mn></msub><mo>&minus;</mo><mn>9</mn><mo stretchy="false">/</mo><mn>2</mn><msub><mi>L</mi> <mn>2</mn></msub><mo>+</mo><mn>55</mn><mo stretchy="false">/</mo><mn>2</mn><msub><mi>L</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>L_3=27/2L_1&#x2d;9/2L_2+55/2L_3</annotation></semantics></math>.</p><p>Si au cours du calcul <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>k</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>a_{k,k+1}=0</annotation></semantics></math>, il faut chercher un “pivot” non nul
sur la ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> à partir de la colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math>, on échange ensuite les
colonnes et les lignes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>k&apos;</annotation></semantics></math> correspondantes. Si tout le reste
de la ligne est nul, alors le polynomôme caractéristique est le
produit du polynôme de la matrice companion lignes et colonnes 
0 à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> incluses et de la matrice lignes et colonnes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math>.
Si on s’intéresse au polynôme minimal, on prend le PPCM
au lieu du produit.</p><p>Le coût de l’algorithme de Danilevsky est de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3)</annotation></semantics></math> opérations
sur le corps. Si on travaille sur les entiers, on peut reconstruire
le polynôme minimal ou caractéristique par les restes chinois,
en estimant la taille des coefficients, on obtient un temps de calcul
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>4</mn></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^4 \ln(n))</annotation></semantics></math>. Si la matrice est à coefficients dépendant 
polynomialement d’un paramètre, on peut reconstruire par interpolation
en majorant le degré du polynôme minimal ou caractéristique. Dans
le cas du polynôme minimal, on prendra garde aux valeurs du paramètre
de mauvaise réduction, c’est-à-dire dont le degré est trop petit, il
ne faut garder pour l’interpolation que les valeurs du paramètre telles
que le degré du polynôme minimal soit maximal. Le nombre
de points d’interpolation nécessaire est égal à 1 plus le degré du
polynome minimal de la matrice multiplié par le degré maximal
de la matrice en le paramètre.
Le polynôme interpolé
est alors bien le polynôme minimal. En effet 
appliqué sur la matrice de départ
on obtient une matrice à coefficients polynômiaux en le paramètre.
Chaque coefficient est un polynôme 
dont le degré en le paramètre est majoré par le nombre de points
d’interpolation utilisés moins 1, et est donc nul car sinon il aurait
trop de racines avec tous les points d’interpolation utilisés.</p>
<!--TOC subsection id="sec242" Les traces et les identités de Newton-->
<h3 id="sec242" class="subsection">22.7.4  Les traces et les identités de Newton</h3><!--SEC END --><p><a id="hevea_default284"></a>
Une autre idée pour calculer le polynôme caractéristique,
on calcule les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mi>k</mi></msup><mo>,</mo><mi>k</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>A^k, k=0..n</annotation></semantics></math> (en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi>A</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>A_{k+1}=AA_k</annotation></semantics></math>), puis les
traces. Si le polynôme caractéristique est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msup><mi>x</mi> <mi>n</mi></msup><mo>+</mo><msub><mi>c</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msup><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>c</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P=x^n+c_{n&#x2d;1}x^{n&#x2d;1}...+c_0</annotation></semantics></math>
alors les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>c_i</annotation></semantics></math> sont au signe et indice près les polynômes
symétriques élémentaires <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>e_j</annotation></semantics></math> en les racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>r_j</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> 
(=valeurs propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, dans une extension
algébrique du corps si nécessaire). On pose
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>e</mi> <mi>j</mi></msub><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mn>1</mn><mo>&leq;</mo><msub><mi>i</mi> <mn>1</mn></msub><mi>&lt;</mi><msub><mi>i</mi> <mn>2</mn></msub><mi>&lt;</mi><mo>.</mo><mo>.</mo><mo>.</mo><mi>&lt;</mi><msub><mi>i</mi> <mi>j</mi></msub><mo>&leq;</mo><mi>n</mi></mrow></munder><msub><mi>r</mi> <mrow><msub><mi>i</mi> <mn>1</mn></msub></mrow></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>r</mi> <mrow><msub><mi>i</mi> <mi>j</mi></msub></mrow></msub></mrow><annotation encoding='application/x-tex'>e_j=\sum_{1\leq i_1&amp;lt;i_2&amp;lt;...&amp;lt;i_j\leq n} r_{i_1}...r_{i_j}  </annotation></semantics></math>
On a alors (en considérant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>t</mi> <mi>n</mi></msup><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">/</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>t^nP(1/t)</annotation></semantics></math>)
<a id="eqref_42"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msub><mi>r</mi> <mi>j</mi></msub><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><msup><mi>t</mi> <mi>k</mi></msup><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><msub><mi>e</mi> <mi>k</mi></msub><mspace width="2em"/><mo stretchy="false">(</mo><mn>42</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>
\prod_{j=1}^n(1&#x2d;r_jt)=\sum_{k=0}^n t^k (&#x2d;1)^k e_k
\qquad (42) </annotation></semantics></math>
On peut passer facilement des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>e_j</annotation></semantics></math> aux <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msubsup><mi>r</mi> <mi>k</mi> <mi>j</mi></msubsup></mrow><annotation encoding='application/x-tex'> p_j=\sum_{k=1}^n r_k^j</annotation></semantics></math> par
les identtés de Newton. On calcule la dérivée par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>
de (<a href="#eq%3Aidnewt1">??</a>) et on multiplie par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>r</mi> <mi>j</mi></msub><mi>t</mi></mrow><mrow><mn>1</mn><mo>&minus;</mo><msub><mi>r</mi> <mi>j</mi></msub><mi>t</mi></mrow></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msub><mi>r</mi> <mi>k</mi></msub><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mi>k</mi><msup><mi>t</mi> <mi>k</mi></msup><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><msub><mi>e</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\sum_{j=1}^n \frac{&#x2d;r_jt}{1&#x2d;r_jt} \prod_{k=1}^n(1&#x2d;r_kt) 
=\sum_{k=0}^n kt^k (&#x2d;1)^k e_k   </annotation></semantics></math>
on développe en série entière 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><msub><mi>r</mi> <mi>j</mi></msub><mi>t</mi></mrow><mrow><mn>1</mn><mo>&minus;</mo><msub><mi>r</mi> <mi>j</mi></msub><mi>t</mi></mrow></mfrac><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mn>&infin;</mn></munderover><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>j</mi></msub><mi>t</mi><msup><mo stretchy="false">)</mo> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>\frac{r_jt}{1&#x2d;r_jt}=\sum_{k=1}^\infty (r_jt)^k </annotation></semantics></math>
on inverse les sommes d’où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mrow><mo>(</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mn>&infin;</mn></munderover><msup><mi>t</mi> <mi>k</mi></msup><mo stretchy="false">(</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msubsup><mi>r</mi> <mi>j</mi> <mi>k</mi></msubsup><mo stretchy="false">)</mo><mo>)</mo></mrow><mo>&times;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><msup><mi>t</mi> <mi>k</mi></msup><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><msub><mi>e</mi> <mi>k</mi></msub><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mi>k</mi><msup><mi>t</mi> <mi>k</mi></msup><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><msub><mi>e</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>&#x2d;\left(\sum_{k=1}^\infty t^k (\sum_{j=1}^n r_j^k) \right) 
\times \sum_{k=0}^n t^k (&#x2d;1)^k e_k = \sum_{k=0}^n k t^k (&#x2d;1)^k e_k </annotation></semantics></math>
on remplace <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msubsup><mi>r</mi> <mi>j</mi> <mi>k</mi></msubsup></mrow><annotation encoding='application/x-tex'>\sum_{j=1}^n r_j^k</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>p_k</annotation></semantics></math> et
on écrit la relation induite pour la puissance <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>t</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>t^k</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><msub><mi>p</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mi>k</mi><mo>&minus;</mo><mi>j</mi></mrow></msup><msub><mi>e</mi> <mrow><mi>k</mi><mo>&minus;</mo><mi>j</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mi>k</mi><msub><mi>e</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>&#x2d;\sum_{j=1}^k p_j (&#x2d;1)^{k&#x2d;j} e_{k&#x2d;j} =(&#x2d;1)^k ke_k </annotation></semantics></math>
ou encore
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>k</mi><msub><mi>e</mi> <mi>k</mi></msub><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><msub><mi>p</mi> <mi>j</mi></msub><msub><mi>e</mi> <mrow><mi>k</mi><mo>&minus;</mo><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>ke_k=\sum_{j=1}^k  (&#x2d;1)^{j&#x2d;1} p_j e_{k&#x2d;j} </annotation></semantics></math>
Ainsi, connaissant les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>k</mi></msub><mo>,</mo><mi>k</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>p_k, k=0..n</annotation></semantics></math>, 
on peut calculer les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mi>k</mi></msub><mo>,</mo><mi>k</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>e_k,k=0..n</annotation></semantics></math> par ordre croissant sur un corps
de caractéristique nulle ou supérieure à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>e</mi> <mn>0</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mn>1</mn><mo>,</mo></mtd></mtr> <mtr><mtd><msub><mi>e</mi> <mn>1</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>p</mi> <mn>1</mn></msub><msub><mi>e</mi> <mn>0</mn></msub><mo>=</mo><msub><mi>p</mi> <mn>1</mn></msub><mo>,</mo></mtd></mtr> <mtr><mtd><mn>2</mn><msub><mi>e</mi> <mn>2</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>p</mi> <mn>1</mn></msub><msub><mi>e</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>p</mi> <mn>2</mn></msub><mo>,</mo></mtd></mtr> <mtr><mtd><mn>3</mn><msub><mi>e</mi> <mn>3</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>p</mi> <mn>1</mn></msub><msub><mi>e</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>p</mi> <mn>2</mn></msub><msub><mi>e</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>3</mn></msub><mo>,</mo></mtd></mtr> <mtr><mtd><mn>4</mn><msub><mi>e</mi> <mn>4</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>p</mi> <mn>1</mn></msub><msub><mi>e</mi> <mn>3</mn></msub><mo>&minus;</mo><msub><mi>p</mi> <mn>2</mn></msub><msub><mi>e</mi> <mn>2</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>3</mn></msub><msub><mi>e</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>p</mi> <mn>4</mn></msub><mo>,</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd/></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 e_0&amp;=&amp;1, \\ 
e_1&amp;=&amp;p_1e_0=p_1, \\ 
2e_2&amp;=&amp;p_1e_1&#x2d;p_2,\\
3e_3&amp;=&amp;p_1e_2&#x2d;p_2e_1+p_3, \\
4e_4&amp;=&amp; p_1e_3&#x2d;p_2e_2+p_3e_1&#x2d;p_4, \\
&amp;...&amp;
 \end{matrix} </annotation></semantics></math>
Le cout de calcul par cette méthode est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^4)</annotation></semantics></math> 
(avec multiplication naïve
des matrices, ce cout est amélioré avec une multiplication
rapide à la Strassen) 
et n’est donc pas compétitif par rapport à 
l’algorithme de Danilevsky. La section suivante présente un
algorithme assez proche, toujours en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^4)</annotation></semantics></math>, mais qui permet 
également de calculer facilement les vecteurs propres lorsqu’on
peut trouver les racines du polynôme caractéristique.</p>
<!--TOC subsection id="sec243" La méthode de
Leverrier-Faddeev-Souriau-->
<h3 id="sec243" class="subsection">22.7.5  La méthode de
Leverrier-Faddeev-Souriau</h3><!--SEC END --><p><a id="hevea_default285"></a> <a id="hevea_default286"></a><a id="hevea_default287"></a>
Cette méthode permet le calcul simultané des coefficients 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>p_i \ (i=0..n)</annotation></semantics></math> du polynôme caractéristique 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>=</mo><mi>det</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(\lambda)=\det(\lambda I&#x2d;A)</annotation></semantics></math> et des coefficients matriciels
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mi>i</mi></msub><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B_i \ (i=0..n&#x2d;1)</annotation></semantics></math> du polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi></mrow><annotation encoding='application/x-tex'>\lambda</annotation></semantics></math> donnant la matrice adjointe
(ou transposée de la comatrice) <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda)</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi></mrow><annotation encoding='application/x-tex'>\lambda I &#x2d;A</annotation></semantics></math> :
<a id="eqref_43"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munder><msub><mi>B</mi> <mi>k</mi></msub><msup><mi>&lambda;</mi> <mi>k</mi></msup><mo>=</mo><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>&leq;</mo><mi>n</mi></mrow></munder><msub><mi>p</mi> <mi>k</mi></msub><msup><mi>&lambda;</mi> <mi>k</mi></msup><mo stretchy="false">)</mo><mi>I</mi><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mi>I</mi><mspace width="2em"/><mo stretchy="false">(</mo><mn>43</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 (\lambda I &#x2d;A)B(\lambda)=(\lambda I &#x2d;A) \sum_{k\leq n&#x2d;1} B_k \lambda^k
= (\sum_{k\leq n} p_k \lambda^k)I =P(\lambda)I
\qquad (43) </annotation></semantics></math>
Remarquons que cette équation donne une démonstration assez simple
de Cayley-Hamilton puisque le reste de la division euclidienne
du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>P(\lambda)I</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi></mrow><annotation encoding='application/x-tex'>\lambda I &#x2d;A </annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(A)</annotation></semantics></math>.</p><p>Pour déterminer simultanément les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>p_k</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>B_k</annotation></semantics></math>,
on a les relations de récurrence :
<a id="eqref_44"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>B</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>p</mi> <mi>n</mi></msub><mi>I</mi><mo>=</mo><mi>I</mi><mo>,</mo><mspace width="1em"/><msub><mi>B</mi> <mi>k</mi></msub><mo>&minus;</mo><mi>A</mi><msub><mi>B</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>I</mi><mspace width="2em"/><mo stretchy="false">(</mo><mn>44</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>
 B_{n&#x2d;1}=p_n I=I, \quad B_k&#x2d;AB_{k+1}=p_{k+1} I
\qquad (44) </annotation></semantics></math>
Il nous manque une relation entre les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>p_k</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>B_k</annotation></semantics></math> pour pouvoir
faire le calcul par valeurs décroissantes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, on va montrer le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 51</span>  <em>
La dérivée du polynôme caractéristique </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P&apos;(\lambda)</annotation></semantics></math><em>,
est égale à la trace de la matrice adjointe 
de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi></mrow><annotation encoding='application/x-tex'>\lambda I&#x2d;A</annotation></semantics></math><em>
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtext>tr</mtext><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \mbox{tr}(B)=P&apos;(\lambda)  </annotation></semantics></math><em>
</em></div><p>
Le théorème nous donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>tr</mtext><mo stretchy="false">(</mo><msub><mi>B</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>\mbox{tr}(B_k) = (k+1)p_{k+1} </annotation></semantics></math>.
Si on prend la trace de (<a href="#eqref_44">44</a>), on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtext>tr</mtext><mo stretchy="false">(</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><msub><mi>p</mi> <mi>n</mi></msub><mo>,</mo><mspace width="1em"/><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mtext>tr</mtext><mo stretchy="false">(</mo><mi>A</mi><msub><mi>B</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'> \mbox{tr}(B_{n&#x2d;1})=n p_n, \quad (k+1)p_{k+1} &#x2d;\mbox{tr}(AB_{k+1})
=np_{k+1}  </annotation></semantics></math>
donc on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>p_{k+1}</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>B_{k+1}</annotation></semantics></math> puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>B_k</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mrow><mtext>tr</mtext><mo stretchy="false">(</mo><mi>A</mi><msub><mi>B</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn><mo>&minus;</mo><mi>n</mi></mrow></mfrac><mo>,</mo><mspace width="1em"/><msub><mi>B</mi> <mi>k</mi></msub><mo>=</mo><mi>A</mi><msub><mi>B</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>I</mi></mrow><annotation encoding='application/x-tex'> p_{k+1}=\frac{\mbox{tr}(AB_{k+1})}{k+1&#x2d;n}, 
\quad B_k=AB_{k+1}+p_{k+1} I  </annotation></semantics></math>
<span style="font-weight:bold">Démonstration du théorème:</span><br>
Soient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>V</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>V_1(\lambda),...V_n(\lambda)</annotation></semantics></math> les vecteurs colonnes 
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi></mrow><annotation encoding='application/x-tex'>\lambda I&#x2d;A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>b_{i,j}(\lambda)</annotation></semantics></math> les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>det</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>V</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msub><mo>&prime;</mo> <mrow><mo stretchy="false">&vert;</mo><mi>&lambda;</mi><mo>=</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub></mrow></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mi>det</mi><mo stretchy="false">(</mo><mi>V</mi><msub><mo>&prime;</mo> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>V</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>det</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mi>V</mi><msub><mo>&prime;</mo> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>V</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo></mtd></mtr> <mtr><mtd/> <mtd/> <mtd><mo lspace="verythinmathspace" rspace="0em">+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>det</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>V</mi><msub><mo>&prime;</mo> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
P&apos;(\lambda_0) &amp;=&amp; \det(V_1(\lambda),V_2(\lambda),...,V_n(\lambda) )&apos;
_{|\lambda=\lambda_0}\\
&amp;=&amp;\det(V&apos;_1(\lambda_0),V_2(\lambda_0),...,V_n(\lambda_0) )+
\det(V_1(\lambda_0),V&apos;_2(\lambda_0),...,V_n(\lambda_0) )+ \\
&amp; &amp; +...+\det(V_1(\lambda_0),V_2(\lambda_0),...,V&apos;_n(\lambda_0) )
 \end{matrix} </annotation></semantics></math>
Il suffit alors de remarquer que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi><msub><mo>&prime;</mo> <mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>V&apos;_i(\lambda_0)</annotation></semantics></math> est le <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>-ième vecteur de la base canonique donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>det</mi><mo stretchy="false">(</mo><msub><mi>V</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><msub><mi>V</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>V</mi><msub><mo>&prime;</mo> <mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>V</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>b</mi> <mrow><mi>i</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \det(V_1(\lambda_0),V_2(\lambda_0),...,V&apos;_i(\lambda_0),...,V_n(\lambda_0) )
=b_{i,i}(\lambda_0)  </annotation></semantics></math>
Finalement :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>b</mi> <mrow><mi>i</mi><mo>,</mo><mi>i</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo lspace="0em" rspace="thinmathspace">tr</mo><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P&apos;(\lambda_0)=\sum_{i=1}^n b_{i,i}(\lambda_0)=\tr(B(\lambda_0))  </annotation></semantics></math></p><p><span style="font-weight:bold">Remarque</span> :<br>
En réindexant les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> de la manière suivante :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>P</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msup><mi>&lambda;</mi> <mi>n</mi></msup><mo>+</mo><msub><mi>p</mi> <mn>1</mn></msub><msup><mi>&lambda;</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><msub><mi>p</mi> <mn>2</mn></msub><msup><mi>&lambda;</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msup><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>p</mi> <mi>n</mi></msub></mtd></mtr> <mtr><mtd><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msup><mi>&lambda;</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mi>I</mi><mo>+</mo><msup><mi>&lambda;</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msup><msub><mi>B</mi> <mn>1</mn></msub><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>B</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
P(\lambda) &amp;=&amp; \lambda^n+p_1\lambda^{n&#x2d;1}+p_2\lambda^{n&#x2d;2}...+p_n \\
B(\lambda) &amp;=&amp; \lambda^{n&#x2d;1}I+\lambda^{n&#x2d;2}B_1+...+B_{n&#x2d;1}
 \end{matrix} </annotation></semantics></math>
on a montré que :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>{</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><msub><mi>A</mi> <mn>1</mn></msub><mo>=</mo><mi>A</mi><mo>,</mo></mtd> <mtd><msub><mi>p</mi> <mn>1</mn></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mtext>tr</mtext><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>,</mo></mtd> <mtd><msub><mi>B</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>A</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>1</mn></msub><mi>I</mi></mtd></mtr> <mtr><mtd><msub><mi>A</mi> <mn>2</mn></msub><mo>=</mo><mi>A</mi><msub><mi>B</mi> <mn>1</mn></msub><mo>,</mo></mtd> <mtd><msub><mi>p</mi> <mn>2</mn></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mtext>tr</mtext><mo stretchy="false">(</mo><msub><mi>A</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>,</mo></mtd> <mtd><msub><mi>B</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>A</mi> <mn>2</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>2</mn></msub><mi>I</mi></mtd></mtr> <mtr><mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd></mtr> <mtr><mtd><msub><mi>A</mi> <mi>k</mi></msub><mo>=</mo><mi>A</mi><msub><mi>B</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo></mtd> <mtd><msub><mi>p</mi> <mi>k</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mn>1</mn><mi>k</mi></mfrac><mtext>tr</mtext><mo stretchy="false">(</mo><msub><mi>A</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>,</mo></mtd> <mtd><msub><mi>B</mi> <mi>k</mi></msub><mo>=</mo><msub><mi>A</mi> <mi>k</mi></msub><mo>+</mo><msub><mi>p</mi> <mi>k</mi></msub><mi>I</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \left\{
\begin{array}{ccc}
A_1=A, &amp; p_1=&#x2d;\mbox{tr}(A), &amp; B_1=A_1+p_1I \\  
A_2=AB_1, &amp; p_2=&#x2d;\frac{1}{2}\mbox{tr}(A_2), &amp; B_2=A_2+p_2I \\ 
\vdots &amp; \vdots &amp; \vdots \\
A_k=AB_{k&#x2d;1}, &amp; p_k=&#x2d;\frac{1}{k}\mbox{tr}(A_k), &amp; B_k=A_k+p_kI
\end{array}
\right. </annotation></semantics></math>
On peut alors vérifier que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>A</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>p</mi> <mi>n</mi></msub><mi>I</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>B_n=A_n+p_nI=0</annotation></semantics></math>.
D’où ce petit programme :
</p><pre class="verbatim">Faddeev(A):={ // renvoie la liste des matrices B et le polynome P
  local Aj,AAj,Id,coef,n,pcara,lmat,j;
  n:=ncols(A);
  Id:=idn(n);     // matrice identite
  Aj:=Id;
  lmat:=[];      // B initialise a liste vide
  pcara:=[1];    // coefficient de plus grand degre de P
  for j from 1 to n do
    lmat:=append(lmat,Aj);  // rajoute Aj a la liste de matrices
    AAj:=Aj*A;
    coef:=-trace(AAj)/j;    
    pcara:=append(pcara,coef);  // rajoute coef au pol. caract.
    Aj:=AAj+coef*Id;
   end_for;
  return lmat,pcara;        // resultat
}:;
</pre>
<!--TOC subsection id="sec244" Les vecteurs propres simples.-->
<h3 id="sec244" class="subsection">22.7.6  Les vecteurs propres simples.</h3><!--SEC END --><p>
On suppose ici qu’on peut factoriser le polynôme caractéristique
(ou calculer dans une extension algébrique d’un corps).
Lorsqu’on a une valeur propre simple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\lambda_0</annotation></semantics></math>, en écrivant
la relation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mi>I</mi><mo stretchy="false">)</mo><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mi>I</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>(A&#x2d;\lambda_0 I)B(\lambda_0)=P(\lambda_0)I=0</annotation></semantics></math>,
on voit que les vecteurs colonnes de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda_0)</annotation></semantics></math>
sont vecteurs propres.
Remarquer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>B(\lambda_0) \neq 0</annotation></semantics></math> sinon on pourrait factoriser
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\lambda&#x2d;\lambda_0</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda)</annotation></semantics></math> et apres simplifications on aurait :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mi>I</mi><mo stretchy="false">)</mo><mfrac><mi>B</mi><mrow><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub></mrow></mfrac><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>P</mi><mrow><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub></mrow></mfrac><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>(A&#x2d;\lambda_0 I)\frac{B}{\lambda&#x2d;\lambda_0}(\lambda_0)=
\frac{P}{\lambda&#x2d;\lambda_0}(\lambda_0)I  </annotation></semantics></math>
or le 2ème membre est inversible en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\lambda_0</annotation></semantics></math> ce qui n’est pas le
cas du premier.
Pour avoir une base des vecteurs propres associés à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\lambda_0</annotation></semantics></math>, on
calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda_0) </annotation></semantics></math> par la méthode de Horner appliquée au
polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda)</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mo>=</mo><msub><mi>&lambda;</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\lambda=\lambda_0</annotation></semantics></math>. En fait il suffit de
calculer chaque colonne l’une à la suite de l’autre et s’arrêter
dès qu’on rencontre une colonne non nulle. Le calcul d’un vecteur
propre associé à une valeur propre simple 
se fait donc génériquement en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^2)</annotation></semantics></math> opérations. </p>
<!--TOC subsection id="sec245" La forme normale de Jordan-->
<h3 id="sec245" class="subsection">22.7.7  La forme normale de Jordan</h3><!--SEC END --><p> <a id="sec:jordan"></a><a id="hevea_default288"></a>
Pour les valeurs propres de multiplicité plus grande que 1, on souhaiterait 
généraliser la méthode ci-dessus pour obtenir une base
de l’espace caractéristique, sous forme de cycles de Jordan.
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda _i</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>n_i</annotation></semantics></math> les valeurs propres comptées avec leur 
multiplicité. On fait un développement de Taylor en
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda _i</annotation></semantics></math>:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mo>&minus;</mo><mi>P</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mi>I</mi></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><mi>&lambda;</mi><mi>I</mi><mo stretchy="false">)</mo><mrow><mo>(</mo><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>B</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mfrac><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo stretchy="false">(</mo><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>)</mo></mrow></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mo stretchy="false">(</mo><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><msup><mo stretchy="false">)</mo> <mrow><msub><mi>n</mi> <mi>i</mi></msub></mrow></msup><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>i</mi></mrow></munder><mo stretchy="false">(</mo><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>j</mi></msub><msup><mo stretchy="false">)</mo> <mrow><msub><mi>n</mi> <mi>j</mi></msub></mrow></msup><mi>I</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} 
&#x2d;P(\lambda )I&amp;=&amp;(A&#x2d;\lambda I)\left(
B(\lambda_i )+ B&apos;(\lambda _i)(\lambda &#x2d;\lambda _i)
+ ... +  \frac{B^{(n&#x2d;1)}(\lambda_i )}{(n&#x2d;1)!} 
(\lambda &#x2d;\lambda _i)^{n&#x2d;1} \right) \\
&amp;=&amp; &#x2d;(\lambda &#x2d;\lambda _i)^{n_i}
\prod _{j\neq i} (\lambda &#x2d;\lambda _j)^{n_j} I 
 \end{matrix} </annotation></semantics></math>
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>&minus;</mo><mi>&lambda;</mi><mi>I</mi><mo>=</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mi>I</mi><mo>&minus;</mo><mo stretchy="false">(</mo><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>A&#x2d;\lambda I=A&#x2d;\lambda _i I &#x2d; (\lambda &#x2d;\lambda _i)I</annotation></semantics></math>, on obtient
pour les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>n_i</annotation></semantics></math> premières puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda &#x2d;\lambda _i</annotation></semantics></math>:
<a id="eqref_45"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mi>I</mi><mo stretchy="false">)</mo><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mi>I</mi><mo stretchy="false">)</mo><mi>B</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd/></mtr> <mtr><mtd><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mi>I</mi><mo stretchy="false">)</mo><mfrac><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mtd> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mtd></mtr> <mtr><mtd><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mi>I</mi><mo stretchy="false">)</mo><mfrac><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>n</mi> <mi>i</mi></msub><mo>!</mo></mrow></mfrac><mo>&minus;</mo><mfrac><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mtd> <mtd><mo>=</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>i</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>j</mi></msub><msup><mo stretchy="false">)</mo> <mrow><msub><mi>n</mi> <mi>j</mi></msub></mrow></msup><mi>I</mi></mtd></mtr></mtable></mrow><mspace width="2em"/><mo stretchy="false">(</mo><mn>45</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \begin{matrix} 
(A&#x2d;\lambda _i I) B(\lambda _i)&amp;=&amp;0\\
(A&#x2d;\lambda _i I) B&apos;(\lambda _i)&amp;=&amp;B(\lambda_i )\\
&amp; ... &amp; \\
(A&#x2d;\lambda _i I) \frac{B^{(n_i&#x2d;1)}(\lambda _i)}{(n_i&#x2d;1)!} &amp;=&amp; 
\frac{B^{(n_i&#x2d;2)}(\lambda _i)}{(n_i&#x2d;2)!}  \\
(A&#x2d;\lambda _i I)\frac{B^{(n_i)}(\lambda_i)}{n_i!} &#x2d;  
\frac{B^{(n_i&#x2d;1)}(\lambda_i)}{(n_i&#x2d;1)!}
&amp;= &amp;&#x2d;\prod_{j\neq i}(\lambda _i&#x2d;\lambda _j)^{n_j} I 
\end{matrix} \qquad (45) </annotation></semantics></math>
Le calcul des matrices <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>n</mi><mo>!</mo></mrow><annotation encoding='application/x-tex'>B^{(n)}(\lambda _i)/n!</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&lt;</mi><msub><mi>n</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>n&amp;lt;n_i</annotation></semantics></math> se fait en
appliquant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>n_i</annotation></semantics></math> fois l’algorithme de Horner (avec reste).</p><div class="theorem"><span style="font-weight:bold">Théorème 52</span>  <em> </em><a id="th:jordan"></a><em>
L’espace caractéristique de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda _i</annotation></semantics></math><em> est égal à
l’image de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>B^{(n_i&#x2d;1)}(\lambda _i)/(n_i&#x2d;1)!</annotation></semantics></math><em>.
</em></div><p>
<span style="font-weight:bold">Preuve :</span><br>
On montre d’abord que Im<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>B^{(n_i&#x2d;1)}(\lambda _i)/(n_i&#x2d;1)!</annotation></semantics></math> est inclus
dans l’espace caractéristique correspondant à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda_i</annotation></semantics></math> en
appliquant l’équation (<a href="#eqref_45">45</a>) et les équations précédentes.
Réciproquement on veut prouver que tout vecteur caractéristique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> est dans 
l’image de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>B^{(n_i&#x2d;1)}(\lambda _i)/(n_i&#x2d;1)!</annotation></semantics></math>. Prouvons le par récurrence
sur le plus petit entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><msup><mo stretchy="false">)</mo> <mi>m</mi></msup><mi>v</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>(A&#x2d;\lambda _i)^{m}v=0</annotation></semantics></math>. Le cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>m=0</annotation></semantics></math> est clair puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>v=0</annotation></semantics></math>.
Supposons le cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> vrai, prouvons le cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m+1</annotation></semantics></math>. On applique l’équation
(<a href="#eqref_45">45</a>) à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>, il suffit alors de prouver que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>w</mi><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mfrac><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>n</mi> <mi>i</mi></msub><mo>!</mo></mrow></mfrac><mi>v</mi></mrow><annotation encoding='application/x-tex'> w=(A&#x2d;\lambda _i)\frac{B^{(n_i)}(\lambda_i)}{n_i!} v </annotation></semantics></math>
appartient à l’image de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>B^{(n_i&#x2d;1)}(\lambda _i)/(n_i&#x2d;1)!</annotation></semantics></math>.
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B^{(n_i)}(\lambda_i)</annotation></semantics></math>
commute avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (car c’est un polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> ou en appliquant
le fait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda)</annotation></semantics></math> inverse de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>&minus;</mo><mi>&lambda;</mi><mi>I</mi></mrow><annotation encoding='application/x-tex'>A&#x2d;\lambda I</annotation></semantics></math>):
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><msup><mo stretchy="false">)</mo> <mi>m</mi></msup><mi>w</mi><mo>=</mo><mfrac><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>n</mi> <mi>i</mi></msub><mo>!</mo></mrow></mfrac><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>v</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> (A&#x2d;\lambda _i)^m w=\frac{B^{(n_i)}(\lambda_i)}{n_i!} 
(A&#x2d;\lambda _i)^{m+1}v=0  </annotation></semantics></math>
et on applique l’hypothèse de récurrence à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi></mrow><annotation encoding='application/x-tex'>w</annotation></semantics></math>.</p><p>Pour calculer les cycles de Jordan, nous allons effectuer une
réduction par le pivot de Gauß simultanément sur les colonnes
des matrices <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>k</mi><mo>!</mo></mrow><annotation encoding='application/x-tex'>B^{(k)}(\lambda _i)/k!</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>&lt;</mi><msub><mi>n</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>k&amp;lt;n_i</annotation></semantics></math>. 
La simultanéité a pour but de conserver les
relations (<a href="#eqref_45">45</a>) à (<a href="#eqref_45">45</a>) pour les matrices
réduites. Pour visualiser l’algorithme, on se représente les
matrices les unes au-dessus des autres, colonnes alignées.
On commence par réduire la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda _i)</annotation></semantics></math> jusqu’à ce
que l’on obtienne une matrice réduite <span style="font-weight:bold">en recopiant</span> les opérations
élémentaires de colonnes faites sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda _i)</annotation></semantics></math> sur toutes les matrices
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>k</mi><mo>!</mo></mrow><annotation encoding='application/x-tex'>B^{(k)}(\lambda _i)/k!</annotation></semantics></math>. On va continuer avec la liste des matrices
réduites issues de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B&apos;(\lambda _i)</annotation></semantics></math>, ..., 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>B^{(n_i&#x2d;1)}(\lambda _i)/(n_i&#x2d;1)!</annotation></semantics></math>, 
mais en déplacant les colonnes non nulles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda _i)</annotation></semantics></math> 
d’une matrice vers le bas
(pour une colonne non nulle de la matrice réduite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(\lambda )</annotation></semantics></math>
les colonnes correspondantes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B^{(k)}(\lambda _i)</annotation></semantics></math> réduite 
sont remplacées par les colonnes correspondantes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B^{(k&#x2d;1)}(\lambda _i)</annotation></semantics></math>
réduite pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> décroissant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n_i&#x2d;1</annotation></semantics></math> vers 1).
À chaque étape, on obtient une famille (éventuellement vide)
de cycles de Jordan, ce sont les vecteurs colonnes correspondants 
aux colonnes non nulles de la matrice réduite du haut de la colonne.
On élimine bien sûr les colonnes correspondant aux fins de cycles
déjà trouvés.</p><p>Par exemple, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>B(\lambda _i)\neq 0</annotation></semantics></math>, son rang est 1 et on a
une colonne non nulle, et un cycle de Jordan de longueur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>n_i</annotation></semantics></math> fait des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>n_i</annotation></semantics></math> vecteurs colonnes des matrices
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>k</mi><mo>!</mo></mrow><annotation encoding='application/x-tex'>B^{(k)}(\lambda _i)/k!</annotation></semantics></math> réduites. 
Plus généralement, on obtiendra plus qu’un cycle de Jordan
(et dans ce cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>B(\lambda _i)= 0</annotation></semantics></math>).</p>
<!--TOC subsection id="sec246" Exemple 1-->
<h3 id="sec246" class="subsection">22.7.8  Exemple 1</h3><!--SEC END --><p> <a id="sec:ex1"></a></p><p><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>3</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> A=\left(\begin{array}{ccc}
 3 &amp; &#x2d;1 &amp; 1 \\
2 &amp;0 &amp;1 \\
1 &amp; &#x2d;1 &amp; 2 
\end{array}\right)  </annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\lambda =2</annotation></semantics></math> est valeur propre de multiplicité 2, on obtient :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>&lambda;</mi> <mn>2</mn></msup><mi>I</mi><mo>+</mo><mi>&lambda;</mi><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mo>&minus;</mo><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>5</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>+</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn></mtd> <mtd><mn>5</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> B(\lambda )= \lambda ^2 I + \lambda \left(\begin{array}{ccc}
 &#x2d;2 &amp; &#x2d;1 &amp; 1 \\
2 &amp; &#x2d;5 &amp;1 \\
1 &amp; &#x2d;1 &amp; &#x2d;3 
\end{array}\right) 
+ \left(\begin{array}{ccc}
 1 &amp; 1 &amp; &#x2d;1 \\
&#x2d;3 &amp; 5 &amp;&#x2d;1 \\
&#x2d;2 &amp; 2 &amp; 2 
\end{array}\right)  </annotation></semantics></math>
on applique l’algorithme de Horner :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>B</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>,</mo></mtd></mtr> <mtr><mtd><mi>B</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} 
B(2)&amp;=&amp;\left(\begin{array}{ccc}
 1 &amp; &#x2d;1 &amp; 1 \\
1&amp; &#x2d;1 &amp;1 \\
0 &amp; 0 &amp; 0 
\end{array}\right) ,\\
B&apos;(2)&amp;=&amp;\left(\begin{array}{ccc}
 2 &amp; &#x2d;1 &amp; 1 \\
2 &amp; &#x2d;1 &amp;1 \\
1 &amp; &#x2d;1 &amp; 1 
\end{array}\right) 
 \end{matrix} </annotation></semantics></math>
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>B(2)\neq 0</annotation></semantics></math>, on pourrait arrêter les calculs en utilisant
une colonne non nulle et le cycle de Jordan associé
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&rightarrow;</mo><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>&rightarrow;</mo><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(2,2,1)\rightarrow (1,1,0) \rightarrow (0,0,0) </annotation></semantics></math>. Expliquons tout
de même l’algorithme général sur cet exemple. La réduction
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(2)</annotation></semantics></math> s’obtient en effectuant les manipulations de colonnes
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>2</mn></msub><mo>+</mo><msub><mi>C</mi> <mn>1</mn></msub><mo>&rightarrow;</mo><msub><mi>C</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>C_2+C_1 \rightarrow C_2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>3</mn></msub><mo>&minus;</mo><msub><mi>C</mi> <mn>1</mn></msub><mo>&rightarrow;</mo><msub><mi>C</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>C_3&#x2d;C_1 \rightarrow C_3</annotation></semantics></math>. 
On effectue les mêmes opérations sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B&apos;(2)</annotation></semantics></math> 
et on obtient :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>,</mo></mtd></mtr> <mtr><mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} \left(\begin{array}{ccc}
 1 &amp; 0 &amp; 0 \\
1&amp; 0 &amp;0 \\
0 &amp; 0 &amp; 0 
\end{array}\right), \\
\left(\begin{array}{ccc}
 2 &amp; 1 &amp; &#x2d;1 \\
2 &amp; 1 &amp; &#x2d;1\\
1 &amp; 0 &amp; 0 
\end{array}\right)
 \end{matrix} </annotation></semantics></math>
L’étape suivante consiste à déplacer vers le bas d’une matrice les
colonnes non nulles de la matrice du haut, on obtient :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \left(\begin{array}{ccc}
 1 &amp; 1 &amp; &#x2d;1 \\
1 &amp; 1 &amp; &#x2d;1\\
0 &amp; 0 &amp; 0 
\end{array}\right)  </annotation></semantics></math>
qui se réduit en :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \left(\begin{array}{ccc}
 1 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0 
\end{array}\right)  </annotation></semantics></math>
on chercherait alors dans les colonnes 2 et 3 de nouveaux cycles (puisque
la colonne 1 a déja été utilisée pour fournir un cycle).</p>
<!--TOC subsection id="sec247" Exemple 2-->
<h3 id="sec247" class="subsection">22.7.9  Exemple 2</h3><!--SEC END --><p> <a id="sec:ex2"></a>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> A=\left(\begin{array}{ccc}
 3 &amp; 2 &amp; &#x2d;2 \\
&#x2d;1 &amp;0 &amp;1 \\
1 &amp; 1 &amp; 0 
\end{array}\right)  </annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\lambda =1</annotation></semantics></math> est valeur propre de multiplicité 3.
On trouve :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>B</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>,</mo></mtd></mtr> <mtr><mtd><mi>B</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>2</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>,</mo></mtd></mtr> <mtr><mtd><mfrac><mrow><mi>B</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
B(1)&amp;=&amp;
\left(\begin{array}{ccc}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 
\end{array}\right), \\
B&apos;(1)&amp;=&amp;\left(\begin{array}{ccc}
2 &amp; 2&amp;&#x2d;2 \\
&#x2d;1 &amp; &#x2d;1 &amp; 1 \\
1 &amp; 1 &amp; &#x2d;1 
\end{array}\right), \\
\frac{ B&apos;{&apos;}(1)}{2}
&amp;=&amp; \left(\begin{array}{ccc}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 
\end{array}\right)
 \end{matrix} </annotation></semantics></math>
Le processus de réduction commence avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B&apos;(1)</annotation></semantics></math> en haut de la liste
de matrices, on effectue les opérations élémentaires de
colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>C</mi> <mn>1</mn></msub><mo>&rightarrow;</mo><msub><mi>C</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>C_2&#x2d;C_1\rightarrow C_2</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>3</mn></msub><mo>+</mo><msub><mi>C</mi> <mn>1</mn></msub><mo>&rightarrow;</mo><msub><mi>C</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>C_3+C_1 \rightarrow C_3</annotation></semantics></math> et on obtient:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>,</mo></mtd></mtr> <mtr><mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
\left(\begin{array}{ccc}
2 &amp; 0&amp;0 \\
&#x2d;1 &amp; 0 &amp; 0 \\
1 &amp; 0 &amp; 0 
\end{array}\right), \\
 \left(\begin{array}{ccc}
1 &amp; &#x2d;1 &amp; 1 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 
\end{array}\right)
 \end{matrix} </annotation></semantics></math>
La première colonne donne le premier cycle de Jordan
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><mo>&rightarrow;</mo><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1,0,0) \rightarrow (2,&#x2d;1,1)</annotation></semantics></math>.
On déplace les premières colonnes d’une matrice vers le bas :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \left(\begin{array}{ccc}
2 &amp; &#x2d;1 &amp; 1 \\
&#x2d;1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1 
\end{array}\right)  </annotation></semantics></math>
qu’on réduit par les opérations <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><msub><mi>C</mi> <mn>2</mn></msub><mo>+</mo><msub><mi>C</mi> <mn>1</mn></msub><mo>&rightarrow;</mo><msub><mi>C</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>2C_2 +C_1 \rightarrow C_2</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><msub><mi>C</mi> <mn>3</mn></msub><mo>&minus;</mo><msub><mi>C</mi> <mn>1</mn></msub><mo>&rightarrow;</mo><msub><mi>C</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>2C_3&#x2d;C_1\rightarrow C_3</annotation></semantics></math> en :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \left(\begin{array}{ccc}
2 &amp; 0 &amp; 0 \\
&#x2d;1 &amp; 1 &amp; 1 \\
1 &amp; 1 &amp; 1 
\end{array}\right)  </annotation></semantics></math>
Puis on effectue <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mn>3</mn></msub><mo>&minus;</mo><msub><mi>C</mi> <mn>2</mn></msub><mo>&rightarrow;</mo><msub><mi>C</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>C_3&#x2d;C_2 \rightarrow C_3</annotation></semantics></math> et la deuxième colonne
nous donne le deuxième cycle de Jordan, réduit ici à un
seul vecteur propre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(0,1,1)</annotation></semantics></math>.</p>
<!--TOC subsection id="sec248" Le polynôme minimal par Faddeev-->
<h3 id="sec248" class="subsection">22.7.10  Le polynôme minimal par Faddeev</h3><!--SEC END --><p>
On vérifie aisément que le degré du facteur 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>&lambda;</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(\lambda&#x2d;\lambda_i)</annotation></semantics></math> dans le polynôme minimal de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est égal
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mi>i</mi></msub><mo>&minus;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>n_i&#x2d;k</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est le plus grand entier tel que :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo>&forall;</mo><mi>j</mi><mi>&lt;</mi><mi>k</mi><mo>,</mo><mspace width="1em"/><msup><mi>B</mi> <mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> \forall j&amp;lt;k, \quad B^{(j)}(\lambda_i)=0  </annotation></semantics></math></p>
<!--TOC subsection id="sec249" Formes normales rationnelles-->
<h3 id="sec249" class="subsection">22.7.11  Formes normales rationnelles</h3><!--SEC END --><p><a id="hevea_default289"></a>
On se place ici dans une problématique différente : trouver une matrice
semblable la plus simple possible sans avoir à introduire d’extension
algébrique pour factoriser le polynôme caractéristique.
Quitte à “compléter” plus tard la factorisation et la jordanisation à
partir de la forme simplifiée. Il existe diverses formes associées
à une matrice et plusieurs algorithmes permettant de les relier entre elles,
forme de Smith, de Frobenius, forme normale de Jordan rationnelle.</p><p>On commence par un algorithme très simple qui donne la décomposition
dite de Dunford<a id="hevea_default290"></a> <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>D</mi><mo>+</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>A=D+N</annotation></semantics></math>
(somme d’une matrice diagonalisable et d’une matrice
nilpotente) sans calculer les valeurs propres (donc en faisant
tous les calculs dans le corps des coefficients de la matrice).
Il utilise la méthode de Newton, la partie diagonalisable
annulant le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> déduit du polynôme caractéristique 
en ramenant à 1 toutes
les multiplicités, la partie nilpotente étant vue comme le
terme d’erreur (la taille de l’erreur se mesurant
par l’exposant nécessaire pour annuler le nilpotent). On résoud
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>q(x)=0</annotation></semantics></math> en considérant la suite récurrente
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>q</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>q</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>u_{n+1}=u_n&#x2d;q(u_n)/q&apos;(u_n)</annotation></semantics></math> avec comme valeur initiale de la suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub><mo>=</mo><mi>A</mi></mrow><annotation encoding='application/x-tex'>u_0=A</annotation></semantics></math>.
On observe que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>q(A)</annotation></semantics></math> est nilpotente car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>q(D)=0</annotation></semantics></math>.

</p><pre class="verbatim">dunford(A):={
  local U,p,q,q1,j,d,n;
  U:=A;
  n:=nrows(U);
  p:=charpoly(U);
  q:=p/gcd(p,p'); // partie sans multiplicite
  q1:=q';
  for (j:=1;j&lt;=n;j:=2*j){
    d:=inv(horner(q1,U))*horner(q,U); // pas de Newton
    if (d==0*d) return U,A-U;
    U:=U-d;
  }
  return U,A-U;
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">J:=[[2,1,0],[0,1,1],[0,0,1]]; P:=trn([[1,2,3],[0,-1,4],[0,0,1]]); A:=P*J*inv(P) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">D,N:=dunford(A); N^2; N^3 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
Mais cet algorithme est un peu trop simple pour être efficace pour de
grandes matrices, une itération est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^4)</annotation></semantics></math>.
Pour le rendre plus efficace, il faut travailler un
peu en utilisant la factorisation la plus poussée possible sur le
polynôme caractéristique (en tout cas au moins la décomposition
<code>sqrfree</code>) et Bézout pour calculer les projecteurs spectraux,
on diminue ainsi la dimension pour accélérer les évaluations du
polynôme d’endomorphisme (en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo></mrow><annotation encoding='application/x-tex'>O(</annotation></semantics></math>dimension<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mo stretchy="false">)</mo> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>)^4</annotation></semantics></math>). Et au demeurant
la forme de Dunford n’a pas beaucoup d’applications pratiques.</p><p>On va maintenant présenter une méthode directe de calcul d’une forme normale
contenant le maximum de zéros (dont la forme dite normale de Jordan
rationnelle peut se déduire) en utilisant le même algorithme que pour 
la forme
normale de Jordan. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>q</mi> <mn>0</mn></msub><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>q</mi> <mi>d</mi></msub><msup><mi>&lambda;</mi> <mi>d</mi></msup></mrow><annotation encoding='application/x-tex'>Q(\lambda)=q_0+...+q_d \lambda^d</annotation></semantics></math> 
un facteur irréductible
de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> et de multiplicité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> 
du polynôme caractéristique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Il
s’agit de construire un sous-espace de dimension <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mi>q</mi></mrow><annotation encoding='application/x-tex'>dq</annotation></semantics></math> formé de “cycles
de Jordan rationnels”.
On part toujours de la relation 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>B</mi> <mi>k</mi></msub><msup><mi>&lambda;</mi> <mi>k</mi></msup><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>(\lambda I &#x2d;A) \sum_{k\leq n&#x2d;1} B_k \lambda^k=P(\lambda)I</annotation></semantics></math>.
On observe que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mi>I</mi><mo>&minus;</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q(\lambda)I&#x2d;Q(A)</annotation></semantics></math> est divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(\lambda I &#x2d;A) </annotation></semantics></math>
donc il existe une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>M(\lambda)</annotation></semantics></math> telle que :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mi>I</mi><mo>&minus;</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munder><msub><mi>B</mi> <mi>k</mi></msub><msup><mi>&lambda;</mi> <mi>k</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><msup><mo stretchy="false">)</mo> <mi>q</mi></msup><mi>M</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> (Q(\lambda) I &#x2d;Q(A)) (\sum_{k\leq n&#x2d;1} B_k \lambda^k)
=Q(\lambda)^q M(\lambda)  </annotation></semantics></math>
On observe aussi que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> a pour coefficient dominant 1 puisqu’il divise
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, on peut donc effectuer des divisions euclidiennes de polynômes
donc de polynômes à coefficients matriciels par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> sans avoir
à diviser des coefficients. Ce qui nous
permet de décomposer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>B</mi> <mi>k</mi></msub><msup><mi>&lambda;</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>B(\lambda)=\sum_{k\leq n&#x2d;1} B_k \lambda^k</annotation></semantics></math> en 
puissances croissantes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>k</mi></munder><msub><mi>C</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mo>,</mo><mspace width="1em"/><mtext>deg</mtext><mo stretchy="false">(</mo><msub><mi>C</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mi>&lt;</mi><mi>q</mi></mrow><annotation encoding='application/x-tex'> B(\lambda)=\sum_k C_k(\lambda) Q(\lambda)^k, \quad \mbox{deg}(C_k)&amp;lt;q  </annotation></semantics></math>
On remplace et on écrit que les coefficients des puissances inférieures
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> sont nulles (la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième étant non nulle
car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>M(\lambda)</annotation></semantics></math> n’est pas divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> pour les mêmes raisons
que pour la forme normale de Jordan). On a donc les relations :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mi>C</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><mspace width="1em"/><msub><mi>C</mi> <mi>k</mi></msub><mo>=</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mi>C</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'> Q(A)C_0 = 0, \quad C_k = Q(A) C_{k+1}  </annotation></semantics></math>
ce qui donne une colonne de matrice 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mrow><mi>q</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&rightarrow;</mo><msub><mi>C</mi> <mrow><mi>q</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo>.</mo><mo>.</mo><mo>.</mo><mo>&rightarrow;</mo><msub><mi>C</mi> <mn>0</mn></msub><mo>&rightarrow;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>C_{q&#x2d;1} \rightarrow C_{q&#x2d;2} ... \rightarrow C_0 \rightarrow 0</annotation></semantics></math>
qui sont images l’une de l’autre en appliquant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q(A)</annotation></semantics></math>. On peut alors
faire l’algorithme de réduction simultanée sur les colonnes des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>C_j</annotation></semantics></math>. 
On observe
ensuite que le nombre de cycles de Jordan de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q(A)</annotation></semantics></math> de longueur donnée 
est un multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math>, en effet il suffit de multiplier
un cycle par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, ..., <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A^{d&#x2d;1}</annotation></semantics></math> pour créer un autre cycle, de plus ces
cycles forment des familles libres car on a supposé <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> irréductible.
On peut donc choisir pour un cycle de longueur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> des bases de la forme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>A</mi><msub><mi>v</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>A</mi> <mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><msub><mi>v</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>&rightarrow;</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>&rightarrow;</mo><mo stretchy="false">(</mo><msub><mi>v</mi> <mn>0</mn></msub><mo>,</mo><mi>A</mi><msub><mi>v</mi> <mn>0</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>A</mi> <mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><msub><mi>v</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>&rightarrow;</mo><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(v_{k&#x2d;1},Av_{k&#x2d;1}...,A^{d&#x2d;1}v_{k&#x2d;1}) \rightarrow ... 
\rightarrow (v_{0},Av_{0}...,A^{d&#x2d;1}v_{0}) \rightarrow (0,...,0) </annotation></semantics></math>
où la flèche <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&rightarrow;</mo></mrow><annotation encoding='application/x-tex'>\rightarrow</annotation></semantics></math> désigne l’image par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q(A)</annotation></semantics></math>.
Si on écrit la matrice de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> dans la base 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mn>0</mn></msub><mo>,</mo><mi>A</mi><msub><mi>v</mi> <mn>0</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>A</mi> <mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><msub><mi>v</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>A</mi><msub><mi>v</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>A</mi> <mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><msub><mi>v</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{0},Av_{0}...,A^{d&#x2d;1}v_{0},...,v_{k&#x2d;1},Av_{k&#x2d;1}...,A^{d&#x2d;1}v_{k&#x2d;1}</annotation></semantics></math>
on obtient un “quasi-bloc de Jordan rationnel” de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>kd</annotation></semantics></math> 
multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center center center center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>q</mi> <mn>0</mn></msub></mtd> <mtd><mspace width="mediummathspace"/></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>1</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>q</mi> <mn>1</mn></msub></mtd> <mtd><mspace width="mediummathspace"/></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>q</mi> <mn>2</mn></msub></mtd> <mtd><mspace width="mediummathspace"/></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mspace width="mediummathspace"/></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>q</mi> <mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mtd> <mtd><mspace width="mediummathspace"/></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd/></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mspace width="mediummathspace"/></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>q</mi> <mn>0</mn></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mspace width="mediummathspace"/></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>q</mi> <mn>1</mn></msub></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mspace width="mediummathspace"/></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mi>&vellip;</mi></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> 
\left( \begin{array}{cccccccccc}
0 &amp; 0 &amp; ... &amp; &#x2d;q_0 &amp;             \ &amp; 0 &amp; 0 &amp; ... &amp; 1 &amp; ... \\
1 &amp; 0 &amp; ... &amp; &#x2d;q_1 &amp;             \ &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; ...\\
0 &amp; 1 &amp; ... &amp; &#x2d;q_2 &amp;             \ &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; ...\\
\vdots &amp; \vdots &amp; ... &amp; \vdots &amp; \ &amp; \vdots &amp; \vdots &amp; ... &amp; \vdots &amp; ...\\
0 &amp; 0 &amp; ... &amp; &#x2d;q_{d&#x2d;1} &amp;         \ &amp; 0 &amp; 0 &amp; ... &amp; 0 &amp; ... \\ 
\\
0 &amp; 0 &amp; ... &amp; 0   &amp;              \ &amp; 0 &amp; 0 &amp; ... &amp; &#x2d;q_{0} &amp; ... \\
0 &amp; 0 &amp; ... &amp; 0   &amp;              \ &amp; 1 &amp; 0 &amp; ... &amp; &#x2d;q_{1} &amp; ... \\
\vdots &amp; \vdots &amp; ... &amp; \vdots &amp; \ &amp; \vdots &amp; \vdots &amp; ... &amp; \vdots &amp; ...
\end{array}
\right)
 </annotation></semantics></math></p><p><span style="font-weight:bold">Exemple</span><br>
Soit la matrice
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd> <mtd><mn>4</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd> <mtd><mn>5</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>5</mn><mn>2</mn></mfrac></mtd> <mtd><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>7</mn></mrow><mn>2</mn></mfrac></mtd> <mtd><mn>2</mn></mtd> <mtd><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>5</mn></mrow><mn>2</mn></mfrac></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>5</mn></mrow><mn>2</mn></mfrac></mtd> <mtd><mn>2</mn></mtd> <mtd><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mtd> <mtd><mfrac><mn>5</mn><mn>2</mn></mfrac></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mfrac><mn>9</mn><mn>2</mn></mfrac></mtd> <mtd><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>7</mn></mrow><mn>2</mn></mfrac></mtd> <mtd><mn>3</mn></mtd> <mtd><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>7</mn></mrow><mn>2</mn></mfrac></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd> <mtd><mn>3</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn></mrow><mn>2</mn></mfrac></mtd> <mtd><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mtd> <mtd><mn>1</mn></mtd> <mtd><mfrac><mn>3</mn><mn>2</mn></mfrac></mtd> <mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> A=\left(\begin{array}{cccccc}
1 &amp; &#x2d;2 &amp; 4 &amp; &#x2d;2 &amp; 5 &amp; &#x2d;4 \\
0 &amp; 1 &amp; \frac{5}{2} &amp; \frac{&#x2d;7}{2} &amp; 2 &amp; \frac{&#x2d;5}{2} \\
1 &amp; \frac{&#x2d;5}{2} &amp; 2 &amp; \frac{&#x2d;1}{2} &amp; \frac{5}{2} &amp; &#x2d;3 \\
0 &amp; &#x2d;1 &amp; \frac{9}{2} &amp; \frac{&#x2d;7}{2} &amp; 3 &amp; \frac{&#x2d;7}{2} \\
0 &amp; 0 &amp; 2 &amp; &#x2d;2 &amp; 3 &amp; &#x2d;1 \\
1 &amp; \frac{&#x2d;3}{2} &amp; \frac{&#x2d;1}{2} &amp; 1 &amp; \frac{3}{2} &amp; \frac{1}{2}
\end{array}\right)  </annotation></semantics></math>
Son polynôme caractéristique est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>2</mn><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>(x&#x2d;2)^2(x^2&#x2d;2)^2</annotation></semantics></math> et on va déterminer
la partie bloc de Jordan rationnel correspondant au facteur irréductible
sur les entiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q(x)=(x^2&#x2d;2)</annotation></semantics></math> de multiplicité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>q=2</annotation></semantics></math>. 
On calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B(x)</annotation></semantics></math> et l’écriture de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> comme
somme de puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> (ici avec <code>xcas</code> en mode <code>xcas</code>) :
</p><pre class="verbatim">A:=[[1,-2,4,-2,5,-4],[0,1,5/2,(-7)/2,2,(-5)/2],[1,(-5)/2,2,1/(-2),5/2,-3],
    [0,-1,9/2,(-7)/2,3,(-7)/2],[0,0,2,-2,3,-1],[1,(-3)/2,1/(-2),1,3/2,1/2]];
P:=det(A-x*idn(6));
B:=normal(P*inv(A-x*idn(6))); // preferer un appel a faddeev bien sur!
ecriture(B,Q,q):={
  local j,k,l,n,C,D,E;
  C:=B;
  D:=B;
  E:=NULL;
  n:=coldim(B);
  for (j:=0;j&lt;q;j++){ 
    for (k:=0;k&lt;n;k++){
      for (l:=0;l&lt;n;l++){
        D[k,l]:=rem(C[k,l],Q,x);
        C[k,l]:=quo(C[k,l],Q,x);
      }
    }
    E:=E,D;
  }
  return E;
};
E:=ecriture(B,x^2-2,2);
QA:=A*A-2*idn(6);
</pre><p>
On vérifie bien que <code>normal(QA*E(0))</code> et
<code>normal(QA*E(1))-E(0))</code> sont nuls. On sait qu’on a un bloc de
taille 2 de cycles de Jordan de longueur 2, donc il n’est pas nécessaire
de faire des réductions ici, il suffit de prendre une colonne non nulle
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>E(0)</annotation></semantics></math>, par exemple la première colonne en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>x=0</annotation></semantics></math>
et la colonne correspondante de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>E(1)</annotation></semantics></math> et leurs images par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, ici
cela donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>4</mn><mo>,</mo><mn>24</mn><mo>,</mo><mn>12</mn><mo>,</mo><mn>32</mn><mo>,</mo><mn>8</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(4,24,12,32,8,&#x2d;4)</annotation></semantics></math> correspondant à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>4</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo>,</mo><mn>8</mn><mo>,</mo><mn>4</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(0,4,&#x2d;4,8,4,&#x2d;4)</annotation></semantics></math>,
on calcule les images par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, la matrice de l’endomorphisme
restreint à ce sous-espace est alors le bloc de taille 4 :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>2</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \left( \begin{array}{cccc}
0 &amp; 2 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 2 \\
0 &amp; 0 &amp; 1 &amp; 0
\end{array} \right)  </annotation></semantics></math></p><p>Cette forme normale minimise le nombre de coefficients non nuls,
mais présente un inconvénient, la partie nilpotente ne commute pas
avec la partie bloc-diagonale, contrairement à la forme normale
rationnelle de Jordan qui contient des blocs identités au-dessus
de la diagonale de blocs.
Pour créer la forme normale rationnelle de Jordan, on doit donc remplacer
les blocs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\left( \begin{array}{ccc} ... &amp; 0 &amp; 1 \\ ... &amp; 0 &amp; 0 
\\ ... \end{array} \right)</annotation></semantics></math>
par des matrices identités. Supposons constitués les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> premiers blocs de
taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> numérotés de 0 à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>j&#x2d;1</annotation></semantics></math> avec comme base de vecteurs
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi> <mrow><mn>0</mn><mo>,</mo><mn>0</mn></mrow></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>v</mi> <mrow><mn>0</mn><mo>,</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>v</mi> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(v_{0,0},...,v_{0,d&#x2d;1},...,v_{j&#x2d;1,d&#x2d;1})</annotation></semantics></math>. 
Il s’agit de trouver un vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{j,0}</annotation></semantics></math> pour commencer le bloc
suivant. On définit alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{j,l}</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{j,l&#x2d;1}</annotation></semantics></math>
en appliquant la relation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>+</mo><msub><mi>v</mi> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>Av_{j,l&#x2d;1}=v_{j,l}+v_{j&#x2d;1,l&#x2d;1}</annotation></semantics></math>.
Il faut donc chercher <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{j,0}</annotation></semantics></math> tel que 
<a id="eqref_46"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>q</mi> <mn>0</mn></msub><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub><mo>&minus;</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>&minus;</mo><msub><mi>q</mi> <mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>v</mi> <mrow><mi>j</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mspace width="2em"/><mo stretchy="false">(</mo><mn>46</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 Av_{j,d&#x2d;1}=&#x2d;q_0 v_{j,0}&#x2d;...&#x2d;q_{d&#x2d;1} v_{j,d&#x2d;1}+v_{j&#x2d;1,d&#x2d;1} 
\qquad (46) </annotation></semantics></math>
En utilisant les relations de récurrence précédentes, on voit que
cela revient à fixer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>Q(A)v_{j,0}</annotation></semantics></math> en fonction des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>&prime;</mo><mo>,</mo><mi>l</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{j&apos;,l}</annotation></semantics></math> avec
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&prime;</mo><mi>&lt;</mi><mi>j</mi></mrow><annotation encoding='application/x-tex'>j&apos;&amp;lt;j</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> quelconque). Ce qui est toujours possible en utilisant
la colonne de matrices <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mrow><mi>j</mi><mo>&prime;</mo></mrow></msub></mrow><annotation encoding='application/x-tex'>C_{j&apos;}</annotation></semantics></math> qui s’obtiennent en
fonction des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>C</mi> <mrow><mi>j</mi><mo>&prime;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>C_{j&apos;+1}</annotation></semantics></math> en appliquant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q(A)</annotation></semantics></math>.</p><p>Plus précisément, calculons les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{j,l}</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{j,0}</annotation></semantics></math>
et des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>&prime;</mo><mo>,</mo><mi>l</mi><mo>&prime;</mo></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{j&apos;,l&apos;}</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&prime;</mo><mi>&lt;</mi><mi>j</mi></mrow><annotation encoding='application/x-tex'>j&apos;&amp;lt;j</annotation></semantics></math>). On utilise les coefficients binomiaux 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mrow><mo>(</mo><msup><mo/><mi>l</mi></msup><msub><mo/><mi>m</mi></msub><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\left( ^l_m\right)</annotation></semantics></math> calculés par la règle du triangle de Pascal et
on montre par récurrence que :
<a id="eqref_47"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>=</mo><msup><mi>A</mi> <mi>l</mi></msup><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub><mo>&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mtext>\small inf</mtext><mo stretchy="false">(</mo><mi>l</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></munderover><mrow><mo>(</mo><msup><mo/><mi>l</mi></msup><msub><mo/><mi>m</mi></msub><mo>)</mo></mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>&minus;</mo><mi>m</mi><mo>,</mo><mi>l</mi><mo>&minus;</mo><mi>m</mi></mrow></msub><mspace width="2em"/><mo stretchy="false">(</mo><mn>47</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
v_{j,l} = A^l v_{j,0} &#x2d; \sum_{m=1}^{\mbox{\small inf}(l,j)} 
\left( ^l _m\right) v_{j&#x2d;m,l&#x2d;m}
\qquad (47) </annotation></semantics></math>
On remplace dans (<a href="#eqref_46">46</a>) d’où :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>A</mi> <mi>d</mi></msup><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub><mo>&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mtext>\small inf</mtext><mo stretchy="false">(</mo><mi>d</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></munderover><mrow><mo>(</mo><msup><mo/><mi>d</mi></msup><msub><mo/><mi>m</mi></msub><mo>)</mo></mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>&minus;</mo><mi>m</mi><mo>,</mo><mi>l</mi><mo>&minus;</mo><mi>m</mi></mrow></msub><mo>+</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow> <mi>d</mi></munderover><msub><mi>q</mi> <mi>l</mi></msub><mo stretchy="false">(</mo><msup><mi>A</mi> <mi>l</mi></msup><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub><mo>&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mtext>\small inf</mtext><mo stretchy="false">(</mo><mi>l</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></munderover><mrow><mo>(</mo><msup><mo/><mi>l</mi></msup><msub><mo/><mi>m</mi></msub><mo>)</mo></mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>&minus;</mo><mi>m</mi><mo>,</mo><mi>l</mi><mo>&minus;</mo><mi>m</mi></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> A^d v_{j,0} &#x2d; \sum_{m=1}^{\mbox{\small inf}(d,j)} 
\left( ^d _m\right)v_{j&#x2d;m,l&#x2d;m}
+ \sum_{l=0}^d 
q_l (A^l v_{j,0} &#x2d; \sum_{m=1}^{\mbox{\small inf}(l,j)} \left( ^l _m\right) 
v_{j&#x2d;m,l&#x2d;m} )=0
 </annotation></semantics></math>
finalement :
<a id="eqref_48"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow> <mi>d</mi></munderover><msub><mi>q</mi> <mi>l</mi></msub><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mtext>\small inf</mtext><mo stretchy="false">(</mo><mi>l</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></munderover><mrow><mo>(</mo><msup><mo/><mi>l</mi></msup><msub><mo/><mi>m</mi></msub><mo>)</mo></mrow><msub><mi>v</mi> <mrow><mi>j</mi><mo>&minus;</mo><mi>m</mi><mo>,</mo><mi>l</mi><mo>&minus;</mo><mi>m</mi></mrow></msub><mspace width="2em"/><mo stretchy="false">(</mo><mn>48</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 Q(A) v_{j,0}= \sum_{l=1}^d 
q_l \sum_{m=1}^{\mbox{\small inf}(l,j)} \left( ^l _m\right) v_{j&#x2d;m,l&#x2d;m} 
\qquad (48) </annotation></semantics></math></p><p><span style="font-weight:bold">Application à l’exemple :</span><br>
Ici <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mn>0</mn><mo>,</mo><mn>0</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><mo>,</mo><mn>24</mn><mo>,</mo><mn>12</mn><mo>,</mo><mn>32</mn><mo>,</mo><mn>8</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v_{0,0}=(4,24,12,32,8,&#x2d;4)</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi>v</mi> <mrow><mi>j</mi><mo>,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{0,1}=Av_{j,0}</annotation></semantics></math> dont une préimage
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q(A)</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mrow><mn>1</mn><mo>,</mo><mn>0</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>4</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo>,</mo><mn>8</mn><mo>,</mo><mn>4</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>w_{1,0}=(0,4,&#x2d;4,8,4,&#x2d;4)</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi>w</mi> <mrow><mn>1</mn><mo>,</mo><mn>0</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>w_{1,1}=Aw_{1,0}</annotation></semantics></math>.
On applique (<a href="#eqref_48">48</a>), comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>q</mi> <mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>q_1=0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>q</mi> <mn>2</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>q_2=1</annotation></semantics></math>
on doit avoir :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mi>v</mi> <mrow><mn>1</mn><mo>,</mo><mn>0</mn></mrow></msub><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow> <mn>2</mn></munderover><msub><mi>q</mi> <mi>l</mi></msub><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mtext>\small inf</mtext><mo stretchy="false">(</mo><mi>l</mi><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></munderover><mrow><mo>(</mo><msup><mo/><mi>l</mi></msup><msub><mo/><mi>m</mi></msub><mo>)</mo></mrow><msub><mi>v</mi> <mrow><mn>1</mn><mo>&minus;</mo><mi>m</mi><mo>,</mo><mi>l</mi><mo>&minus;</mo><mi>m</mi></mrow></msub><mo>=</mo><mn>2</mn><msub><mi>v</mi> <mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'> Q(A) v_{1,0} = \sum_{l=1}^2
q_l \sum_{m=1}^{\mbox{\small inf}(l,1)} \left( ^l _m\right) v_{1&#x2d;m,l&#x2d;m} 
 =2v_{0,1}  </annotation></semantics></math>
donc  :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center"><mtr><mtd><msub><mi>v</mi> <mrow><mn>1</mn><mo>,</mo><mn>0</mn></mrow></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mn>2</mn><mi>A</mi><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>4</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo>,</mo><mn>8</mn><mo>,</mo><mn>4</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>8</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>32</mn><mo>,</mo><mn>0</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>48</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>16</mn><mo>,</mo><mn>16</mn><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><msub><mi>v</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>A</mi><msub><mi>v</mi> <mrow><mn>1</mn><mo>,</mo><mn>0</mn></mrow></msub><mo>&minus;</mo><msub><mi>v</mi> <mrow><mn>0</mn><mo>,</mo><mn>0</mn></mrow></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">(</mo><mn>4</mn><mo>,</mo><mn>40</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn><mo>,</mo><mn>64</mn><mo>,</mo><mn>24</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>20</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow><annotation encoding='application/x-tex'>\begin{array}{ccccc}
 v_{1,0}&amp;=&amp;2A(0,4,&#x2d;4,8,4,&#x2d;4)&amp;=&amp;(&#x2d;8,&#x2d;32,0,&#x2d;48,&#x2d;16,16) \\
 v_{1,1}&amp;=&amp;Av_{1,0}&#x2d;v_{0,0}&amp;=&amp;(4,40,&#x2d;4,64,24,&#x2d;20) 
\end{array}
 </annotation></semantics></math>
On vérifie bien que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msub><mi>v</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>2</mn><msub><mi>v</mi> <mrow><mn>1</mn><mo>,</mo><mn>0</mn></mrow></msub><mo>+</mo><msub><mi>v</mi> <mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>Av_{1,1}=2v_{1,0}+v_{0,1}</annotation></semantics></math>.</p>
<!--TOC subsection id="sec250" Fonctions analytiques-->
<h3 id="sec250" class="subsection">22.7.12  Fonctions analytiques</h3><!--SEC END --><p>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> une fonction analytique et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> une matrice. Pour calculer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(M)</annotation></semantics></math>, on calcule la forme normale de Jordan de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>D</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>M=P(D+N)P^{&#x2d;1}</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>=</mo></mrow><annotation encoding='application/x-tex'>D=</annotation></semantics></math>diag<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>d</mi> <mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(d_1,...,d_m)</annotation></semantics></math> est diagonale et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> nilpotente
d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. On calcule
aussi le développement de Taylor formel de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> à l’ordre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math>, on a alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mrow><mo>(</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mfrac><mrow><mtext>diag</mtext><mo stretchy="false">(</mo><msup><mi>f</mi> <mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>d</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>f</mi> <mrow><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>d</mi> <mi>m</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mi>j</mi><mo>!</mo></mrow></mfrac><msup><mi>N</mi> <mi>j</mi></msup><mo>)</mo></mrow><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> f(N)=P \left(\sum_{j=0}^{n&#x2d;1} \frac{\mbox{diag}(f^{(j)}(d_1),...,
f^{(j)}(d_m))}{j!} N^j \right) P^{&#x2d;1} </annotation></semantics></math></p>
<!--TOC section id="sec251" Quelques autres algorithmes utiles-->
<h2 id="sec251" class="section">22.8  Quelques autres algorithmes utiles</h2><!--SEC END -->
<!--TOC subsection id="sec252" Complexité asymptotique-->
<h3 id="sec252" class="subsection">22.8.1  Complexité asymptotique</h3><!--SEC END --><p>
Pour calculer le produit de matrices, on peut utiliser
l’algorithme de <span style="font-weight:bold">Strassen</span>, on présente ici la variante
de <span style="font-weight:bold">Winograd</span><a id="hevea_default291"></a><a id="hevea_default292"></a>. Soit à calculer :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><msub><mi>a</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>a</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>a</mi> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>a</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable><mo>)</mo></mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><msub><mi>b</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>b</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>b</mi> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>b</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable><mo>)</mo></mrow><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><msub><mi>c</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>c</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>c</mi> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd> <mtd><msub><mi>c</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \left(\begin{array}{cc} a_{1,1} &amp; a_{1,2} \\
a_{2,1} &amp; a_{2,2} \end{array}\right) 
\left(\begin{array}{cc} b_{1,1} &amp; b_{1,2} \\
b_{2,1} &amp; b_{2,2} \end{array}\right)
=\left(\begin{array}{cc} c_{1,1} &amp; c_{1,2} \\
c_{2,1} &amp; c_{2,2} \end{array}\right)
 </annotation></semantics></math>
On calcule :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>s</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>a</mi> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>a</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>s</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>s</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>a</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>s</mi> <mn>3</mn></msub><mo>=</mo><msub><mi>a</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>a</mi> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>s</mi> <mn>4</mn></msub><mo>=</mo><msub><mi>a</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><msub><mi>s</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>t</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>b</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><msub><mi>b</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>t</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>b</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><msub><mi>t</mi> <mn>1</mn></msub><mo>,</mo><mspace width="1em"/><msub><mi>t</mi> <mn>3</mn></msub><mo>=</mo><msub><mi>b</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><msub><mi>b</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>t</mi> <mn>4</mn></msub><mo>=</mo><msub><mi>b</mi> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>t</mi> <mn>2</mn></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} 
s_1=a_{2,1}+a_{2,2}, \quad s_2=s_1&#x2d;a_{1,1}, \quad 
s_3=a_{1,1}&#x2d; a_{2,1}, \quad s_4=a_{1,2}&#x2d;s_2
\\
t_1=b_{1,2}&#x2d;b_{1,1}, \quad t_2=b_{2,2}&#x2d;t_1,
\quad t_3=b_{2,2}&#x2d;b_{1,2}, \quad t_4=b_{2,1}&#x2d;t_2
 \end{matrix} </annotation></semantics></math>
puis :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>p</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>a</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><msub><mi>b</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>p</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>a</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><msub><mi>b</mi> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>p</mi> <mn>3</mn></msub><mo>=</mo><msub><mi>s</mi> <mn>1</mn></msub><msub><mi>t</mi> <mn>1</mn></msub><mo>,</mo><mspace width="1em"/><msub><mi>p</mi> <mn>4</mn></msub><mo>=</mo><msub><mi>s</mi> <mn>2</mn></msub><msub><mi>t</mi> <mn>2</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>p</mi> <mn>5</mn></msub><mo>=</mo><msub><mi>s</mi> <mn>3</mn></msub><msub><mi>t</mi> <mn>3</mn></msub><mo>,</mo><mspace width="1em"/><msub><mi>p</mi> <mn>6</mn></msub><mo>=</mo><msub><mi>s</mi> <mn>4</mn></msub><msub><mi>b</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>p</mi> <mn>7</mn></msub><mo>=</mo><msub><mi>a</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub><msub><mi>t</mi> <mn>4</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>u</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>p</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>2</mn></msub><mspace width="1em"/><msub><mi>u</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>p</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>4</mn></msub><mo>,</mo><mspace width="1em"/><msub><mi>u</mi> <mn>3</mn></msub><mo>=</mo><msub><mi>u</mi> <mn>2</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>5</mn></msub><mo>,</mo><mspace width="1em"/><msub><mi>u</mi> <mn>4</mn></msub><mo>=</mo><msub><mi>u</mi> <mn>3</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>7</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>u</mi> <mn>5</mn></msub><mo>=</mo><msub><mi>u</mi> <mn>3</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>3</mn></msub><mo>,</mo><mspace width="1em"/><msub><mi>u</mi> <mn>6</mn></msub><mo>=</mo><msub><mi>u</mi> <mn>2</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>3</mn></msub><mo>,</mo><mspace width="1em"/><msub><mi>u</mi> <mn>7</mn></msub><mo>=</mo><msub><mi>u</mi> <mn>6</mn></msub><mo>+</mo><msub><mi>p</mi> <mn>6</mn></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 p_1=a_{1,1} b_{1,1}, \quad
p_2=a_{1,2}b_{2,1}, \quad
p_3=s_1 t_1, \quad p_4=s_2 t_2 \\
p_5=s_3 t_3, \quad p_6=s_4 b_{2,2},
\quad p_7=a_{2,2} t_4 \\
u_1= p_1+p_2 \quad u_2=p_1+p_4,
\quad u_3=u_2+p_5, \quad u_4=u_3+p_7\\
u_5=u_3+p_3, \quad
u_6=u_2+p_3, \quad u_7=u_6+p_6
 \end{matrix} </annotation></semantics></math>
Alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>c</mi> <mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mn>7</mn></msub><mo>,</mo><msub><mi>c</mi> <mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mn>4</mn></msub><mo>,</mo><msub><mi>c</mi> <mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mn>5</mn></msub></mrow><annotation encoding='application/x-tex'>c_{1,1}=u_1, c_{1,2}=u_7, c_{2,1}=u_4, c_{2,2}=u_5</annotation></semantics></math>.<br>
Cet algorithme utilise 7 multiplications et 15 additions
ce qui économise 1 multiplication et permet en appliquant
récursivement cet algorithme pour des matrices blocs
de réduire la complexité d’un produit de grandes matrices
normalement en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo>=</mo><msup><mi>n</mi> <mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3=n^{\ln(8)/\ln(2)})</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mrow><mi>ln</mi><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>ln</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^{\ln(7)/\ln(2)})</annotation></semantics></math> (la preuve
est analogue à celle de la multiplication des polynômes
par l’algorithme de Karatsuba).</p><p>En utilisant une factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math> par blocs, on peut montrer
que cette complexité asymptotique se généralise au
calcul de l’inverse. On peut d’ailleurs améliorer l’exposant,
mais la constante non explicitée dans le <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi></mrow><annotation encoding='application/x-tex'>O</annotation></semantics></math> augmente aussi.
En pratique, Strassen n’est pas utilisée pour des matrices
de taille plus petites que plusieurs centaines de lignes et colonnes.</p><p>De même on peut gagner sur le calcul du polynôme minimal en
faisant des opérations de multiplication par bloc.</p>
<!--TOC section id="sec253" Quelques méthodes alternatives au pivot-->
<h2 id="sec253" class="section">22.9  Quelques méthodes alternatives au pivot</h2><!--SEC END -->
<!--TOC subsection id="sec254" Factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math>-->
<h3 id="sec254" class="subsection">22.9.1  Factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math></h3><!--SEC END --><p><a id="hevea_default293"></a>
La factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> 
consiste à écrire une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> comme produit d’une matrice
orthogonale (ou unitaire dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{C}</annotation></semantics></math>) et d’une matrice triangulaire
supérieure. Les matrices orthogonales ayant un conditionnement
de 1 (en norme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>L^2</annotation></semantics></math>) cette factorisation peut s’obtenir de manière 
numériquement stable.</p><p>Il existe plusieurs algorithmes pour effectuer cette factorisation.
On peut voir cette factorisation comme l’orthonormalisation de
Gram-Schmidt appliqué aux vecteurs colonnes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est non 
singulière. Mais la procédure de Gram-Schmidt n’est pas
numériquement stable (car on retranche d’un vecteur
une combinaison linéaire des vecteurs précdents pour rendre
le nouveau vecteur orthogonal et les erreurs d’arrondi s’accumulent
rendant l’orthogonalité plus aléatoire).
La méthode de Householder<a id="hevea_default294"></a> 
utilise des matrices de symétrie
par rapport à un hyperplan et ne souffre pas de ce problème d’instabilité.
Pour annuler les coefficients de la première colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>c_1</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>,
on construit le vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>=</mo><msub><mi>c</mi> <mn>1</mn></msub><mo>&pm;</mo><mo stretchy="false">&Vert;</mo><msub><mi>c</mi> <mn>1</mn></msub><mo stretchy="false">&Vert;</mo><msub><mi>e</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>u=c_1 \pm \|c_1\| e_1</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>e_1</annotation></semantics></math>
est le premier vecteur de base et le signe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&pm;</mo></mrow><annotation encoding='application/x-tex'>\pm</annotation></semantics></math> est
le signe de la première composante de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>c_1</annotation></semantics></math> (pour assurer
la stabilité numérique). On fait alors la symétrie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1</annotation></semantics></math> par rapport
à l’hyperplan <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> orthogonal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math>, qui laisse <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math> invariant
et transforme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>u</mi></mrow><annotation encoding='application/x-tex'>&#x2d;u</annotation></semantics></math>. Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math> est vecteur directeur
de la bissectrice intérieure ou extérieure de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>c_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>e_1</annotation></semantics></math>, la symétrie
échange ces deux vecteurs, éventuellement au signe près.
La matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>Q</mi> <mn>1</mn></msub><mi>A</mi></mrow><annotation encoding='application/x-tex'>A_1=Q_1A</annotation></semantics></math> a donc comme première colonne un multiple de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>e_1</annotation></semantics></math>, on continue ensuite en faisant le même raisonnement
sur la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>A_1</annotation></semantics></math> en se limitant et lignes et colonnes d’indice
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&geq;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\geq 2</annotation></semantics></math>. Après <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> itérations, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>Q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mn>1</mn></msub><mi>A</mi></mrow><annotation encoding='application/x-tex'>A_{n&#x2d;1}=Q_{n&#x2d;1}...Q_1A</annotation></semantics></math>
qui est triangulaire supérieure d’où la factorisation annoncée.</p><p>Matriciellement, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>=</mo><mi>I</mi><mo>&minus;</mo><mn>2</mn><mi>v</mi><msup><mi>v</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>Q_1=I&#x2d;2vv^*</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mi>u</mi><mo stretchy="false">/</mo><mo stretchy="false">&Vert;</mo><mi>u</mi><mo stretchy="false">&Vert;</mo></mrow><annotation encoding='application/x-tex'>v=u/\|u\|</annotation></semantics></math>, pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mi>A</mi></mrow><annotation encoding='application/x-tex'>Q_1A</annotation></semantics></math>
il faut effectuer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>&minus;</mo><mn>2</mn><mi>v</mi><msup><mi>v</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A&#x2d;2vv^*A</annotation></semantics></math>, on calcule donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo>=</mo><msup><mi>v</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>w=v^*A</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>n^2</annotation></semantics></math>
opérations (ou une opération est une addition et une
multiplication) puis on soustrait <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>v</mi><msub><mo stretchy="false">)</mo> <mi>i</mi></msub><msub><mi>w</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>(2v)_i w_j</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{ij}</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>n^2</annotation></semantics></math>
opérations. En faisant de même aux étapes qui suivent, sans
tenir compte de la simplification progressive du vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>, on 
effectue <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><msup><mi>n</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>2n^3</annotation></semantics></math> opérations. La constante 2 peut être 
un peu améliorée en tenant compte des 0 initiaux de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> aux
étapes 2 et ultérieures, elle est toutefois supérieure à LU
(et Cholesky), mais en contrepartie
la méthode est très stable numériquement.</p><p>On peut aussi utiliser des rotations (méthode de Givens) pour
annuler les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> sous la diagonale. C’est par exemple
très efficace pour des matrices tridiagonales.</p><p>Lorsque la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> n’est pas carrée, mais possède <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> lignes
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> colonnes, la factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> est encore possible, la matrice
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est alors une matrice carrée d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> a les mêmes
dimensions que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>. En particulier si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> a plus de lignes que de
colonnes (matrice verticale), <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> aussi. Par exemple si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est de 
rang maximal <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> se décompose en un premier bloc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>,</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>c,c</annotation></semantics></math> inversible <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>R_1</annotation></semantics></math> et un deuxième bloc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>c</mi><mo>,</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>n&#x2d;c,c</annotation></semantics></math> entièrement nul.</p><p><span style="font-weight:bold">Applications :</span><br>
On peut alors écrire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math> sous la forme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>QRx=b</annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mi>x</mi><mo>=</mo><msup><mi>Q</mi> <mo>*</mo></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>Rx=Q^*b</annotation></semantics></math> qui est un système triangulaire supérieur,
donc résoudre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^2)</annotation></semantics></math> opérations une fois 
la factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> effectuée.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a:=[[1.,2.,3.],[4.,5.,6.],[7.,8.,0.]]; q,r:=qr(a); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>Mais c’est surtout pour résoudre <span style="font-weight:bold">au sens des moindres carrés</span>
un système sur-déterminé que la factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> trouve tout
son intérêt. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> la matrice d’un système sur-déterminé
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> lignes et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> colonnes, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&gt;</mi><mi>c</mi></mrow><annotation encoding='application/x-tex'>n&amp;gt;c</annotation></semantics></math> (matrice “verticale” ou mince).
Le système n’a en général pas de solution, on cherche alors
à minimiser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><mi>A</mi><mi>x</mi><mo>&minus;</mo><mi>b</mi><msubsup><mo stretchy="false">&Vert;</mo> <mn>2</mn> <mn>2</mn></msubsup></mrow><annotation encoding='application/x-tex'>\| Ax&#x2d;b \|_2^2</annotation></semantics></math>. Ceci revient à
chercher la projection orthogonale de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> sur Im<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(A)</annotation></semantics></math>.
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>Ax</annotation></semantics></math> cette projection, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mi>A</mi><mi>x</mi><mo>+</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>b=Ax+p</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> orthogonal
à Im<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(A)</annotation></semantics></math> donc dans Ker<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>A</mi> <mo>*</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(A^*)</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>b</mi><mo>=</mo><msup><mi>A</mi> <mo>*</mo></msup><mo stretchy="false">(</mo><mi>A</mi><mi>x</mi><mo>+</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>A^*b=A^*(Ax+p)=A^*Ax</annotation></semantics></math>.
</p><div class="theorem"><span style="font-weight:bold">Proposition 53</span>  <em>
La solution </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math><em> du problème de minimisation de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><mi>A</mi><mi>x</mi><mo>&minus;</mo><mi>b</mi><msub><mo stretchy="false">&Vert;</mo> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>\| Ax&#x2d;b \|_2</annotation></semantics></math><em>
est donnée par </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi><mi>x</mi><mo>=</mo><msup><mi>A</mi> <mo>*</mo></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>A^*Ax=A^*b</annotation></semantics></math><em>
</em></div><p>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>A=QR</annotation></semantics></math> on a alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>R</mi> <mo>*</mo></msup><mi>R</mi><mi>x</mi><mo>=</mo><msup><mi>R</mi> <mo>*</mo></msup><msup><mi>Q</mi> <mo>*</mo></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>R^* R x=R^* Q^*b</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est de rang maximal
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math>, on décompose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo stretchy="false">(</mo> <mrow><msub><mi>R</mi> <mn>2</mn></msub></mrow> <mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(^{R_1}_{R_2})</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>R_1</annotation></semantics></math> inversible de
taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>2</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>R_2=0</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>R</mi> <mo>*</mo></msup><mo>=</mo><mo stretchy="false">(</mo><msubsup><mi>R</mi> <mn>1</mn> <mo>*</mo></msubsup><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>R^*=(R_1^*, 0)</annotation></semantics></math> et le système devient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>R</mi> <mn>1</mn> <mo>*</mo></msubsup><msub><mi>R</mi> <mn>1</mn></msub><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><msubsup><mi>R</mi> <mn>1</mn> <mo>*</mo></msubsup><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo><msup><mi>Q</mi> <mo>*</mo></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>R_1^*R_1x =(R_1^*,0) Q^*b </annotation></semantics></math>
et comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>R_1</annotation></semantics></math> est inversible, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>1</mn></msub><mi>x</mi><mo>=</mo></mrow><annotation encoding='application/x-tex'>R_1x=</annotation></semantics></math> les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> premières lignes
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>Q</mi> <mo>*</mo></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>Q^*b</annotation></semantics></math>.
Il vaut mieux résoudre ce système que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi><mi>x</mi><mo>=</mo><msup><mi>A</mi> <mo>*</mo></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>A^* Ax=A^*b</annotation></semantics></math> car
le conditionnement de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A^* A</annotation></semantics></math> est le carré du conditionnement
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (le nombre d’opérations est un peu supérieur :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> a une constante nettement plus grande que Cholesky mais
il n’y a pas de multiplication de matrice à faire, et le résultat
est plus précis).</p><p>Notons qu’on peut résoudre de manière assez analogue
un système sous-déterminé au sens des moindres carrés.
On considère toujours le système <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math> mais cette fois-ci
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est une matrice “horizontale” (nombre de lignes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&lt;</mi><mi>c</mi></mrow><annotation encoding='application/x-tex'>n&amp;lt;c</annotation></semantics></math> le nombre
de colonnes). Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>&Element;</mo></mrow><annotation encoding='application/x-tex'>b \in </annotation></semantics></math>Im<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(A)</annotation></semantics></math> (on peut génériquement supposer
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est de rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>), 
il y a une infinité de solutions, on
cherche alors la solution de norme minimale. On cherche donc le
projeté orthogonal de l’espace affine des solutions (dirigé selon Ker<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(A)</annotation></semantics></math>)
sur l’orthogonal de Ker<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(A)</annotation></semantics></math> qui est Im<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>A^*</annotation></semantics></math>. Ainsi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>A</mi> <mo>*</mo></msup><mi>y</mi></mrow><annotation encoding='application/x-tex'>x=A^*y</annotation></semantics></math>
vérifie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msup><mi>A</mi> <mo>*</mo></msup><mi>y</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>AA^*y=b</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est de rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msup><mi>A</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>AA^* </annotation></semantics></math> est inversible et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mi>A</mi><msup><mi>A</mi> <mo>*</mo></msup><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>y=(AA^*)^{&#x2d;1}b</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><mi>A</mi><msup><mi>A</mi> <mo>*</mo></msup><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>x=A (AA^*)^{&#x2d;1}b</annotation></semantics></math>.
En utilisant la factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>A^*</annotation></semantics></math> (attention pas celle de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>), on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msup><mi>A</mi> <mo>*</mo></msup><mo>=</mo><msup><mi>R</mi> <mo>*</mo></msup><mi>R</mi></mrow><annotation encoding='application/x-tex'>AA^*=R^*R</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>Q</mi><mi>R</mi><mo stretchy="false">(</mo><msup><mi>R</mi> <mo>*</mo></msup><mi>R</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>x=QR(R^*R)^{&#x2d;1}b</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est de rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>,
on a alors en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo>=</mo><msubsup><mo stretchy="false">(</mo> <mn>0</mn> <mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>R=(^{R_1}_{0})</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>R_1</annotation></semantics></math> matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>n,n</annotation></semantics></math> inversible :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>=</mo><mi>Q</mi><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><msub><mi>R</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow><msubsup><mi>R</mi> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msubsup><msubsup><mi>R</mi> <mn>1</mn> <mrow><msup><mo>*</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow></msubsup><mi>b</mi><mo>=</mo><mi>Q</mi><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><msup><mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow> <mrow><msup><mo>*</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow></msup></mtd></mtr> <mtr><mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow><mi>b</mi><mo>=</mo><msub><mi>Q</mi> <mn>1</mn></msub><msup><mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow> <mrow><msup><mo>*</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow></msup><mi>b</mi></mrow><annotation encoding='application/x-tex'>x=Q\left(\begin{array}{c}R_1\\0\end{array}\right)R_1^{&#x2d;1} R_1^{*^{&#x2d;1}}b=Q\left(\begin{array}{c}
{R_1}^{*^{&#x2d;1}} \\ 0\end{array}\right)b=Q_1 {R_1}^{*^{&#x2d;1}} b </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1</annotation></semantics></math> désigne les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> premières colonnes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.
</p><div class="theorem"><span style="font-weight:bold">Proposition 54</span>  <em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math><em> une matrice ayant </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><em> lignes et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mi>&gt;</mi><mi>n</mi></mrow><annotation encoding='application/x-tex'>c&amp;gt;n</annotation></semantics></math><em> colonnes.
Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math><em> est de rang maximal </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><em>, posons </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mo>=</mo><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>A^*=QR</annotation></semantics></math><em>, </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>R_1</annotation></semantics></math><em> les </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><em>
premières lignes de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>R_1</annotation></semantics></math><em>, </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1</annotation></semantics></math><em> les </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><em> premières colonnes
de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math><em>. La solution de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math><em> de norme
minimale est donnée par </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mi>c</mi></mrow><annotation encoding='application/x-tex'>Q_1c</annotation></semantics></math><em> où </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math><em> est la solution de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>R</mi> <mn>1</mn> <mo>*</mo></msubsup><mi>c</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>R_1^*c=b</annotation></semantics></math><em>
(système triangulaire).
</em></div><p><span style="font-weight:bold">Exemple 1 : la régression linéaire</span> :<br>
On se donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> points de coordonnées <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>y</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x_i,y_i)</annotation></semantics></math> où les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math>
sont distincts 2 à 2 et on cherche
la droite qui approche le mieux ces points au sens de l’écart en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>
au carré. Il s’agit donc de trouver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\beta</annotation></semantics></math> qui minimisent :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><msub><mi>x</mi> <mi>i</mi></msub><mo>&minus;</mo><msub><mi>y</mi> <mi>i</mi></msub><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\sum_{j=1}^n (\alpha+\beta x_i&#x2d;y_i)^2  </annotation></semantics></math>
Ici on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mn>1</mn></mtd> <mtd><msub><mi>x</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><msub><mi>x</mi> <mi>n</mi></msub></mtd></mtr> <mtr><mtd/></mtr></mtable><mo>)</mo></mrow><mo>,</mo><mspace width="1em"/><mi>x</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>&alpha;</mi></mtd></mtr> <mtr><mtd><mi>&beta;</mi></mtd></mtr></mtable><mo>)</mo></mrow><mo>,</mo><mspace width="1em"/><mi>b</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><msub><mi>y</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mi>n</mi></msub></mtd></mtr> <mtr><mtd/></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>A=\left( \begin{array}{cc}
1 &amp; x_1 \\
... &amp; ... \\
1 &amp; x_n  \\
\end{array} \right), \quad 
x=\left( \begin{array}{c} \alpha \\ \beta \end{array}\right),
\quad
b=\left( \begin{array}{c}
y_1  \\
...  \\
y_n  \\
\end{array} 
\right) </annotation></semantics></math>
Pour trouver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\alpha, \beta</annotation></semantics></math> de manière précise, on préferera
donc calculer la factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> plutôt que calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A^*A</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>R_1</annotation></semantics></math> est
une matrice carrée d’ordre 2, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> une matrice carrée d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, 
la première colonne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est le vecteur de coordonnées
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&pm;</mo><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>\pm (1,...,1)/\sqrt{n}</annotation></semantics></math>.</p><p>Exemple : on se donne les points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">)</mo><mo>,</mo><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mo stretchy="false">(</mo><mn>3</mn><mo>,</mo><mn>5</mn><mo stretchy="false">)</mo><mo>,</mo><mo stretchy="false">(</mo><mn>4</mn><mo>,</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(1,2), (2,1), (3,5), (4,4)</annotation></semantics></math>. La
matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> sont donc<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">A:=evalf(tran([seq(1,4),seq(j,j,1,4)])); b:=[2,1,5,4]; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">q,r:=qr(A); y0,m:=normal(r[0..1,0..1]^-1*trn(q)[0..1]*b); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">purge(x);droite(y=m*x+y0); scatterplot(seq(j,j,1,4),b);linear_regression_plot(seq(j,j,1,4),b)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p><span style="font-weight:bold">Exemple 2: régression polynomiale</span> :<br>
C’est une généralisation de l’exemple précédent, on cherche un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(x)</annotation></semantics></math>
de degré fixé tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>y</mi> <mi>i</mi></msub><mo>&minus;</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\sum_i (y_i&#x2d;P(x_i))^2</annotation></semantics></math> soit minimal. Si on
choisit la base canonique des polynômes, la
matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est alors une matrice de Vandermonde 
et son conditionnement est en général très mauvais. 
De plus, plus le degré augmente, plus l’extrapolation 
est hasardeuse :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a:=[[0,-3],[1,-1],[2,0],[3,1],[4,3],[5,4],[6,5],[10,9]]:; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">scatterplot(a); linear_regression_plot(a[0..6]); polynomial_regression_plot(a[0..6],4);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>On préfèrera utiliser une base de polynômes orthogonaux pour
le produit scalaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>i</mi></msub><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mi>Q</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sum_i P(x_i)Q(x_i)</annotation></semantics></math>
ou minimiser une autre fonctionnelle quadratique, par
exemple une intégrale du carré de la différence entre une
fonction à approcher et un polynôme ou un
polynôme trigonométrique.</p><p><span style="font-weight:bold">Remarque</span> : La factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> peut s’obtenir
en calculant la factorisation de Cholesky de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A^* A</annotation></semantics></math> qui donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math>,
mais on lui préfère une méthode de calcul direct pour des
raisons de stabilité, en tout cas pour des matrices denses (pour des
matrices creuses des considérations d’efficacité peuvent faire
préférer la factorisation de Cholesky).</p>
<!--TOC subsection id="sec255" Méthodes itératives de
Jacobi, Gauss-Seidel, relaxation-->
<h3 id="sec255" class="subsection">22.9.2  Méthodes itératives de
Jacobi, Gauss-Seidel, relaxation</h3><!--SEC END --><p><a id="hevea_default295"></a> <a id="hevea_default296"></a>
<a id="sec:jacobi"></a>
Lorsqu’on a une matrice creuse (peu d’éléments non nuls),
l’algorithme du pivot de Gauss a tendance à densifier rapidement
la matrice réduite (surtout avec le pivot partiel où on ne
controle pas le nombre de zéros de la ligne contenant le pivot). Il
peut alors être intéressant d’utiliser des méthodes alternatives
ne faisant intervenir que des produits de matrice, donnant éventuellement
un résultat seulement approché. </p><p>Par exemple pour calculer
l’inverse d’une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>M</mi><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>A=M&#x2d;N</annotation></semantics></math>, avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> facile à inverser (par
exemple diagonale) et 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> petit en norme et creuse, on peut écrire :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>A</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mo>&minus;</mo><mi>N</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">(</mo><mi>I</mi><mo>&minus;</mo><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>N</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mi>I</mi><mo>+</mo><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>N</mi><mo>+</mo><mo stretchy="false">(</mo><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>N</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">)</mo><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A^{&#x2d;1}=(M&#x2d;N)^{&#x2d;1} =
(M(I&#x2d;M^{&#x2d;1}N))^{&#x2d;1}=(I+M^{&#x2d;1}N+(M^{&#x2d;1}N)^2+...)M^{&#x2d;1} </annotation></semantics></math></p><p>De même pour résoudre un système linéaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math>
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>M</mi><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>A=M&#x2d;N</annotation></semantics></math>,
on considère la suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>N</mi><msub><mi>x</mi> <mi>n</mi></msub><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Mx_{n+1}&#x2d;Nx_n=b</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_{n+1}</annotation></semantics></math> est obtenu
en résolvant le système :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>M</mi><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>b</mi><mo>+</mo><mi>N</mi><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mspace width="1em"/><msub><mi>x</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>Mx_{n+1}=b+N x_n, \quad x_0=0 </annotation></semantics></math>
pour laquelle on vérifiera les hypothèses du théorème du point
fixe, il suffit par exemple de vérifier que la plus
grande valeur singulière de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>N</mi></mrow><annotation encoding='application/x-tex'>M^{&#x2d;1}N</annotation></semantics></math> est strictement plus petite que 1.
Lorsque la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> n’est pas creuse, le procédé est intéressant
pour résoudre approximativement un système si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est grand
et si chaque itération est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^2)</annotation></semantics></math> (ceci veut
dire qu’on ne calcule pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>M^{&#x2d;1}</annotation></semantics></math> sauf si c’est
évident, par exemple si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> est diagonale), 
mais le procédé n’est pas intéressant pour le calcul de
l’inverse de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>.</p><p>Notons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> la partie diagonale de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> sa partie triangulaire inférieure stricte, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> sa partie
triangulaire supérieure stricte,
La méthode de Jacobi utilise pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> la
diagonale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, alors
que la méthode de Gauss-Seidel prend pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> la partie triangulaire
inférieure <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>+</mo><mi>L</mi></mrow><annotation encoding='application/x-tex'>D+L</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (diagonale comprise). 
Pour Jacobi, on a donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msup><mi>D</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mo stretchy="false">(</mo><mi>D</mi><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>+</mo><msup><mi>D</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>A</mi><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x_{n+1}=D^{&#x2d;1}(b+(D&#x2d;A)x_n)=x_n+D^{&#x2d;1}(b&#x2d;Ax_n) </annotation></semantics></math>
En Xcas, l’instruction préprogrammée est <code>jacobi_linsolve</code>, 
on peut aussi programmer la méthode par

</p><pre class="verbatim">jacobi(A,b,eps,N):={
  local D,x0,x1,n,j;
  n:=size(A);
  D:=diag(A).^-1;
  x0:=seq(0,n);
  pour j de 1 jusque N faire
    x1:=b-A*x0;
    si l2norm(x1)&lt;eps alors return x0; fsi;
    x0:=x0+D .*x1;
  fpour;
  return "non convergent";
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


Un cas simple où on a convergence :
</p><div class="theorem"><span style="font-weight:bold">Proposition 55</span>  <em> 
Lorsque la matrice </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math><em> est
à diagonale strictement dominante, c’est-à-dire que
l’élément diagonal est en valeur absolue strictement supérieur
à la somme des éléments non diagonaux de la même ligne :
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub><mo stretchy="false">&vert;</mo><mi>&gt;</mi><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>i</mi></mrow></munder><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|a_{ii}| &amp;gt; \sum_{j\neq i} |a_{ij}|  </annotation></semantics></math><em>
la méthode de Jacobi converge.
</em></div><p>
En effet,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>N</mi><mi>x</mi><msub><mo stretchy="false">&Vert;</mo> <mn>&infin;</mn></msub><mi>&lt;</mi><mo stretchy="false">&Vert;</mo><mi>x</mi><msub><mo stretchy="false">&Vert;</mo> <mn>&infin;</mn></msub></mrow><annotation encoding='application/x-tex'>\|M^{&#x2d;1}Nx\|_\infty &amp;lt; \| x\|_\infty</annotation></semantics></math> car :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>N</mi><mi>x</mi><msub><mo stretchy="false">)</mo> <mi>i</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>i</mi></mrow></munder><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>i</mi></mrow></munder><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">&Vert;</mo><mi>x</mi><msub><mo stretchy="false">&Vert;</mo> <mn>&infin;</mn></msub><mi>&lt;</mi><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mrow><mi>i</mi><mi>i</mi></mrow></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">&Vert;</mo><mi>x</mi><msub><mo stretchy="false">&Vert;</mo> <mn>&infin;</mn></msub><mspace width="1em"/><mo>&Rightarrow;</mo><mspace width="1em"/><mo stretchy="false">&vert;</mo><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>N</mi><mi>x</mi><msub><mo stretchy="false">)</mo> <mi>i</mi></msub><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mo stretchy="false">&Vert;</mo><mi>x</mi><msub><mo stretchy="false">&Vert;</mo> <mn>&infin;</mn></msub></mrow><annotation encoding='application/x-tex'>|(Nx)_i| \leq \sum_{j \neq i} |a_{ij}| |x_j| \leq \sum_{j \neq i}
|a_{ij}| \|x\|_\infty &amp;lt; |a_{ii}| \| x\|_\infty  
\quad  \Rightarrow \quad |M^{&#x2d;1}(Nx)_i| &amp;lt;  \| x\|_\infty  </annotation></semantics></math>
On retrouve ce cas pour une petite perturbation d’une matrice
diagonale, par exemple <br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">n:=500;A:=2*idn(n)+1e-4*ranm(n,n,uniformd,-1,1):;b:=seq(1,n):; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">time(c:=linsolve(A,b));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">time(d:=jacobi(A,b,1e-12,50));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">maxnorm(d-c)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> assez grand, la méthode de Jacobi devient plus rapide. Cela
se vérifie encore plus vite si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est une matrice creuse.</p><p>Pour Gauss-Seidel,
le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>M^{&#x2d;1}</annotation></semantics></math> n’est pas effectué, on résoud
directement le système triangulaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>b</mi><mo>+</mo><mi>N</mi><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Mx_{n+1}=b+Nx_n</annotation></semantics></math> soit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>+</mo><mi>L</mi><mo stretchy="false">)</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>b</mi><mo>&minus;</mo><mi>U</mi><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>(D+L)x_{n+1}=b&#x2d;Ux_n </annotation></semantics></math> 
Gauss-Seidel
est moins adapté à la parallélisation que Jacobi.
On adapte le programme précédent

</p><pre class="verbatim">seidel(A,b,N,eps):={
  local L,U,x0,x1,n,j;
  n:=size(A);
  L:=diag(A,left);
  U:=A-L;
  x0:=seq(0.0,n);
  pour j de 1 jusque N faire
    x1:=b-U*x0;
    x1:=linsolve(L,x1);
    si l2norm(x1-x0)&lt;eps*l2norm(x0) alors return x0; fsi;
    x0:=x1;
  fpour;
  return "non convergent";
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>

</p><p>Dans la méthode de relaxation, on pose pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> la matrice triangulaire
inférieure <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo>=</mo><mfrac><mn>1</mn><mi>&omega;</mi></mfrac><mi>D</mi><mo>+</mo><mi>L</mi></mrow><annotation encoding='application/x-tex'>M=\frac1\omega D+L</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&omega;</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\omega &amp;gt;0</annotation></semantics></math>, donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>=</mo><mo stretchy="false">(</mo><mfrac><mn>1</mn><mi>&omega;</mi></mfrac><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>D</mi><mo>&minus;</mo><mi>U</mi></mrow><annotation encoding='application/x-tex'>N=(\frac1\omega&#x2d;1) D&#x2d;U</annotation></semantics></math>
et on utilise la récurrence <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>b</mi><mo>+</mo><mi>N</mi><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Mx_{n+1}=b+Nx_n</annotation></semantics></math> donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>b</mi><mo>+</mo><mo stretchy="false">(</mo><mi>M</mi><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Mx_{n+1}=b+(M&#x2d;A)x_n</annotation></semantics></math> puis
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>&minus;</mo><mi>A</mi><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>M(x_{n+1}&#x2d;x_n)=b&#x2d;Ax_n</annotation></semantics></math> puis
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mo>+</mo><mi>&omega;</mi><mi>L</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>&omega;</mi><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>A</mi><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(D+\omega L) (x_{n+1}&#x2d;x_n) = \omega(b&#x2d;Ax_n) </annotation></semantics></math>
On remarque que Gauss-Seidel correspond à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&omega;</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\omega=1</annotation></semantics></math>.
L’instruction correspondante de Xcas est <code>gauss_seidel_linsolve</code> et
peut prendre en paramètre le coefficient de relaxation, 
dont la valeur par défaut est 1.</p><div class="theorem"><span style="font-weight:bold">Proposition 56</span>  <em> (Convergence ): 
si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>M</mi><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>A=M&#x2d;N</annotation></semantics></math><em> est une matrice symétrique définie positive
et si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mo>*</mo></msup><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>M^*+N</annotation></semantics></math><em> est définie positive, alors la méthode converge. 
</em></div><p>
On utilise la norme correspondant à
la forme quadratique de matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et on calcule la norme subordonnée
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>N</mi></mrow><annotation encoding='application/x-tex'>M^{&#x2d;1}N</annotation></semantics></math>, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>N</mi><mi>x</mi><mo>=</mo><mi>x</mi><mo>&minus;</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'> M^{&#x2d;1}Nx=x&#x2d;y</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>A</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>y=M^{&#x2d;1}Ax</annotation></semantics></math> donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mo stretchy="false">&Vert;</mo><msup><mi>M</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>N</mi><mi>x</mi><msubsup><mo stretchy="false">&Vert;</mo> <mi>A</mi> <mn>2</mn></msubsup></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>&lt;</mi><mi>x</mi><mo>&minus;</mo><mi>y</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>&gt;</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mi>&lt;</mi><mi>x</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mi>x</mi><mi>&gt;</mi><mo>+</mo><mi>&lt;</mi><mi>y</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mi>y</mi><mi>&gt;</mi><mo>&minus;</mo><mi>&lt;</mi><mi>y</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mi>x</mi><mi>&gt;</mi><mo>&minus;</mo><mi>&lt;</mi><mi>x</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mi>y</mi><mi>&gt;</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mi>&lt;</mi><mi>x</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mi>x</mi><mi>&gt;</mi><mo>+</mo><mi>&lt;</mi><mi>y</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mi>y</mi><mi>&gt;</mi><mo>&minus;</mo><mi>&lt;</mi><mi>y</mi><mo stretchy="false">&vert;</mo><mi>M</mi><mi>y</mi><mi>&gt;</mi><mo>&minus;</mo><mi>&lt;</mi><mi>M</mi><mi>y</mi><mo stretchy="false">&vert;</mo><mi>y</mi><mi>&gt;</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mi>&lt;</mi><mi>x</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mi>x</mi><mi>&gt;</mi><mo>&minus;</mo><mi>&lt;</mi><mi>y</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><msup><mi>M</mi> <mo>*</mo></msup><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>N</mi><mo stretchy="false">)</mo><mi>y</mi><mi>&gt;</mi></mtd></mtr> <mtr><mtd/> <mtd><mi>&lt;</mi></mtd> <mtd><mi>&lt;</mi><mi>x</mi><mo stretchy="false">&vert;</mo><mi>A</mi><mi>x</mi><mi>&gt;</mi><mo>=</mo><mo stretchy="false">&Vert;</mo><mi>x</mi><msubsup><mo stretchy="false">&Vert;</mo> <mi>A</mi> <mn>2</mn></msubsup></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} 
\| M^{&#x2d;1}Nx \|^2_A&amp;=&amp;&amp;lt;x&#x2d;y|A (x&#x2d;y))&amp;gt; \\
&amp;=&amp;&amp;lt;x|Ax&amp;gt;+&amp;lt;y|Ay&amp;gt;&#x2d;&amp;lt;y|Ax&amp;gt;&#x2d;&amp;lt;x|Ay&amp;gt; \\
&amp;=&amp;&amp;lt;x|Ax&amp;gt;+&amp;lt;y|Ay&amp;gt;&#x2d;&amp;lt;y|My&amp;gt; &#x2d;&amp;lt;My|y&amp;gt;\\
&amp;=&amp;&amp;lt;x|Ax&amp;gt;&#x2d;&amp;lt;y|(M^*+N)y&amp;gt;\\
&amp; &amp;lt; &amp; &amp;lt;x|Ax&amp;gt;=\|x\|_A^2
 \end{matrix} </annotation></semantics></math>
Conséquence : si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> symétrique définie positive, alors 
Gauss-Seidel converge, car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mo>*</mo></msup><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>N</mi><mo>=</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'>M^*+N=D</annotation></semantics></math>. Pour la relaxation,
on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>M</mi> <mo>*</mo></msup><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>N</mi><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">/</mo><mi>&omega;</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'>M^*+N=(2/\omega &#x2d;1)D</annotation></semantics></math> qui est définie positive si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&omega;</mi><mi>&lt;</mi><mn>2</mn></mrow><annotation encoding='application/x-tex'>\omega&amp;lt;2</annotation></semantics></math>.</p><p><span style="font-weight:bold">Remarque </span>: Jacobi et Gauss-Seidel sont implémentées dans les commandes
Xcas <span style="font-family:monospace">jacobi_linsolve</span> et <span style="font-family:monospace">gauss_seidel_linsolve</span>.</p>
<!--TOC subsection id="sec256" Méthode du gradient à pas constant-->
<h3 id="sec256" class="subsection">22.9.3  Méthode du gradient à pas constant</h3><!--SEC END --><p><a id="hevea_default297"></a>
<a id="hevea_default298"></a>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est une matrice symétrique définie positive (relativement
à un produit scalaire noté <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><mo stretchy="false">&vert;</mo><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;|&amp;gt;</annotation></semantics></math>), on
considère la fonctionnelle :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>&lt;</mi><mi>A</mi><mi>v</mi><mo stretchy="false">&vert;</mo><mi>v</mi><mi>&gt;</mi><mo>&minus;</mo><mi>&lt;</mi><mi>b</mi><mo stretchy="false">&vert;</mo><mi>v</mi><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>J(v)=\frac{1}{2} &amp;lt;Av|v&amp;gt;&#x2d;&amp;lt;b|v&amp;gt; </annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>J(v)</annotation></semantics></math> tend vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>+\infty</annotation></semantics></math> lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><mi>v</mi><mo stretchy="false">&Vert;</mo></mrow><annotation encoding='application/x-tex'>\|v\|</annotation></semantics></math> tend vers l’infini, 
car si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mn>1</mn></msub><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\lambda_1&amp;gt;0</annotation></semantics></math> est la plus petite valeur propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>,
on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>&geq;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msub><mi>&lambda;</mi> <mn>1</mn></msub><mo stretchy="false">&Vert;</mo><mi>v</mi><msup><mo stretchy="false">&Vert;</mo> <mn>2</mn></msup><mo>&minus;</mo><mo stretchy="false">&Vert;</mo><mi>b</mi><mo stretchy="false">&Vert;</mo><mo stretchy="false">&Vert;</mo><mi>v</mi><mo stretchy="false">&Vert;</mo></mrow><annotation encoding='application/x-tex'>J(v)\geq \frac{1}{2} \lambda_1 \|v\|^2&#x2d;\|b\|\|v\|</annotation></semantics></math>.
Elle admet donc un minimum global, qui vérifie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>J</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mo>&Del;</mo><mi>J</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>J&apos;(v)=\nabla J(v)=0</annotation></semantics></math>
Or <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mi>v</mi></msub><mi>J</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>&lt;</mi><mi>A</mi><mi>v</mi><mo>&minus;</mo><mi>b</mi><mo stretchy="false">&vert;</mo><mi>w</mi><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>d_vJ(w)=&amp;lt;Av&#x2d;b|w&amp;gt;</annotation></semantics></math>, en effet
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mi>A</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>h</mi><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>h</mi><mi>w</mi><mo stretchy="false">)</mo><mi>&gt;</mi><mo>&minus;</mo><mi>&lt;</mi><mi>A</mi><mi>v</mi><mo stretchy="false">&vert;</mo><mi>v</mi><mi>&gt;</mi><mo>=</mo><mi>h</mi><mi>&lt;</mi><mi>A</mi><mi>w</mi><mo stretchy="false">&vert;</mo><mi>v</mi><mi>&gt;</mi><mo>+</mo><mi>h</mi><mi>&lt;</mi><mi>A</mi><mi>v</mi><mo stretchy="false">&vert;</mo><mi>w</mi><mi>&gt;</mi><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>h</mi><mi>&lt;</mi><mi>A</mi><mi>v</mi><mo stretchy="false">&vert;</mo><mi>w</mi><mi>&gt;</mi><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&amp;lt;A(v+hw)|(v+hw)&amp;gt;&#x2d;&amp;lt;Av|v&amp;gt;=h&amp;lt;Aw|v&amp;gt;+h&amp;lt;Av|w&amp;gt;+O(h^2)=2h&amp;lt;Av|w&amp;gt;+O(h^2) </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&Del;</mo><mi>J</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mi>v</mi><mo>&minus;</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>\nabla J (v)=Av&#x2d;b</annotation></semantics></math>
Donc le minimum global est l’unique solution de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>v</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Av=b</annotation></semantics></math>.</p><p>La méthode du gradient à pas constant consiste à résoudre le
système <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>v</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Av=b</annotation></semantics></math> en minimisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>J</mi></mrow><annotation encoding='application/x-tex'>J</annotation></semantics></math>. Pour cela on calcule une suite récurrente
de premier terme par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>v_0=0</annotation></semantics></math>, et au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math> on suit la
direction opposée au gradient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>J</mi></mrow><annotation encoding='application/x-tex'>J</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math> selon un pas constant :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>v</mi> <mi>k</mi></msub><mo>&minus;</mo><mi>&rho;</mi><mo stretchy="false">(</mo><mi>A</mi><msub><mi>v</mi> <mi>k</mi></msub><mo>&minus;</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v_{n+1}=v_k&#x2d;\rho (Av_k&#x2d;b) </annotation></semantics></math>
La plus grande et plus petite valeur propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>&minus;</mo><mi>&rho;</mi><mi>A</mi></mrow><annotation encoding='application/x-tex'>I&#x2d;\rho A</annotation></semantics></math> sont 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo>&minus;</mo><mi>&rho;</mi><msub><mi>&lambda;</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>1&#x2d;\rho \lambda_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo>&minus;</mo><mi>&rho;</mi><msub><mi>&lambda;</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>1&#x2d;\rho \lambda_n</annotation></semantics></math>, si ces deux valeurs propres
sont en module strictement inférieure à 1, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math> va
converger à vitesse géométrique (de raison max(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mn>1</mn><mo>&minus;</mo><mi>&rho;</mi><msub><mi>&lambda;</mi> <mn>1</mn></msub><mo stretchy="false">&vert;</mo><mo>,</mo><mo stretchy="false">&vert;</mo><mn>1</mn><mo>&minus;</mo><mi>&rho;</mi><msub><mi>&lambda;</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|1&#x2d;\rho
\lambda_1|,|1&#x2d;\rho \lambda_n|</annotation></semantics></math>) vers l’unique point fixe de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>I</mi><mo>&minus;</mo><mi>&rho;</mi><mi>A</mi><mo stretchy="false">)</mo><mi>v</mi><mo>+</mo><mi>&rho;</mi><mi>b</mi></mrow><annotation encoding='application/x-tex'>f(v)=(I&#x2d;\rho A)v+\rho b</annotation></semantics></math>, qui est la solution du système <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>v</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Av=b</annotation></semantics></math>.
Il suffit de choisir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math> (si on a une estimation sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>\lambda_1</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda_n</annotation></semantics></math>).</p><p>Par exemple, pour la matrice du laplacien discret (2 sur la diagonale,
et -1 sur les 2 diagonales de part et d’autre), les valeurs propres
sont les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>k</mi><mi>&pi;</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>2(1&#x2d;\cos(k\pi/(n+1)))</annotation></semantics></math>, il faut donc que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mi>&lt;</mi><mn>1</mn><mo>&minus;</mo><mn>2</mn><mi>&rho;</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> &#x2d;1 &amp;lt; 1&#x2d;2\rho (1+\cos(\pi/(n+1)))</annotation></semantics></math>
soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn><mi>&lt;</mi><mi>&rho;</mi><mi>&lt;</mi><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>0&amp;lt;\rho&amp;lt;\frac1{1+\cos(\pi/(n+1))}</annotation></semantics></math>.
La valeur optimale est obtenue lorsque les 2 valeurs extrêmales ont
même valeur absolue
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>2</mn><mi>&rho;</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&minus;</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo>&minus;</mo><mn>2</mn><mi>&rho;</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mo>&Rightarrow;</mo><mspace width="mediummathspace"/><mi>&rho;</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'>2\rho (1+\cos(\pi/(n+1))&#x2d;1=1&#x2d;2\rho (1&#x2d;\cos(\pi/(n+1)) 
\ \Rightarrow \ 
\rho = \frac{1}{2}
 </annotation></semantics></math>
La vitesse de convergence est assez lente, car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>I</mi><mo>&minus;</mo><mi>&rho;</mi><mi>A</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|I&#x2d;\rho A|</annotation></semantics></math> a pour
valeur propre maximale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>cos</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\cos(\pi/(n+1))</annotation></semantics></math>, par exemple pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding='application/x-tex'>n=20</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>cos</mi><mo stretchy="false">(</mo><mi>p</mi><mi>i</mi><mo stretchy="false">/</mo><mn>21</mn><mo>.</mo><mo stretchy="false">)</mo><mo>&equiv;</mo><mn>0.988</mn></mrow><annotation encoding='application/x-tex'>\cos(pi/21.) \equiv 0.988</annotation></semantics></math> est très proche de 1.</p>
<!--TOC subsection id="sec257" Méthode itérative du gradient conjugué-->
<h3 id="sec257" class="subsection">22.9.4  Méthode itérative du gradient conjugué</h3><!--SEC END --><p><a id="hevea_default299"></a>
Il s’agit de résoudre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math>, où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est définie positive. 
Si on a une base orthogonale pour le produit scalaire induit par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, 
on peut calculer la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>-ième coordonnée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> 
dans cette base en faisant le produit scalaire de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>Ax=b</annotation></semantics></math> par le <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>-ième vecteur de la base. 
On construit donc petit à petit une base orthogonale 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">{</mo><msub><mi>p</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>p</mi> <mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>\{ p_1,...,p_n \}</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> par un procédé à la Gram-Schmidt, 
mais on ne part pas de la base canonique : 
on construit cette famille orthogonale pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> 
en meme temps qu’on calcule les composantes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>&geq;</mo><mn>1</mn></mrow></msub><msub><mi>&alpha;</mi> <mi>j</mi></msub><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x=\sum_{j\geq 1} \alpha_j p_j</annotation></semantics></math>, alors 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mi>b</mi><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mi>j</mi></msub><mi>&gt;</mi><mo>=</mo><mi>&lt;</mi><mi>A</mi><mi>x</mi><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mi>j</mi></msub><mi>&gt;</mi><mo>=</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mi>&lt;</mi><mi>A</mi><msub><mi>p</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mi>j</mi></msub><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;b|p_j&amp;gt;=&amp;lt;Ax|p_j&amp;gt;=\alpha_j &amp;lt;Ap_j|p_j&amp;gt; </annotation></semantics></math>
Posons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>&leq;</mo><mi>i</mi></mrow></msub><msub><mi>&alpha;</mi> <mi>j</mi></msub><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_i=\sum_{j\leq i} \alpha_j p_j</annotation></semantics></math>, on a donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mi>b</mi><mo>&minus;</mo><mi>A</mi><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mi>j</mi></msub><mi>&gt;</mi><mo>=</mo><mn>0</mn><mtext> si </mtext><mi>j</mi><mo>&leq;</mo><mi>i</mi><mo>,</mo><mspace width="1em"/><mi>&lt;</mi><mi>b</mi><mo>&minus;</mo><mi>A</mi><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mi>j</mi></msub><mi>&gt;</mi><mo>=</mo><msub><mi>&alpha;</mi> <mi>j</mi></msub><mi>&lt;</mi><mi>A</mi><msub><mi>p</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mi>j</mi></msub><mi>&gt;</mi><mtext> sinon.</mtext></mrow><annotation encoding='application/x-tex'>&amp;lt;b&#x2d;Ax_i|p_j&amp;gt;=0 \mbox{ si } j\leq i, \quad 
&amp;lt;b&#x2d;Ax_i|p_j&amp;gt;=\alpha_j &amp;lt;Ap_j|p_j&amp;gt; \mbox{ sinon.} </annotation></semantics></math>
On peut donc construire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math> comme une suite récurrente de 
la manière suivante : 
</p><ol class="enumerate" type=1><li class="li-enumerate">
on initialise par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>x_0=0</annotation></semantics></math>, 
</li><li class="li-enumerate">à la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math>-ième itération, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>b</mi><mo>&minus;</mo><mi>A</mi><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>r_{i+1}=b&#x2d;Ax_i</annotation></semantics></math>, on a donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mi>j</mi></msub><mi>&gt;</mi><mo>=</mo><mn>0</mn><mtext> si </mtext><mi>j</mi><mo>&leq;</mo><mi>i</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;r_{i+1}|p_j&amp;gt;=0 \mbox{ si } j\leq i  </annotation></semantics></math>
</li><li class="li-enumerate">On en déduit que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{i+1}</annotation></semantics></math> est combinaison linéaire des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub><mo>,</mo><mi>j</mi><mo>&leq;</mo><mi>i</mi></mrow><annotation encoding='application/x-tex'>p_j, j
\leq i</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>r_{i+1}=0</annotation></semantics></math> donc on a terminé : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x=x_i</annotation></semantics></math>.
</li><li class="li-enumerate">Sinon, on complète la famille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>-orthogonale par un nouveau vecteur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>p_{i+1}</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{i+1}&#x2d;p_{i+1}</annotation></semantics></math> soit dans Vect(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">{</mo><msub><mi>p</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>p</mi> <mi>i</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>\{
p_1,...,p_{i}\}</annotation></semantics></math>) et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>-orthogonal. On observe que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{i+1}</annotation></semantics></math> est combinaison
linéaire des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>p_j</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&leq;</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>j \leq i+1</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><msub><mi>r</mi> <mi>i</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>r</mi> <mi>k</mi></msub><mi>&gt;</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>&amp;lt;r_i|r_k&amp;gt;=0</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mi>&lt;</mi><mi>k</mi></mrow><annotation encoding='application/x-tex'>i&amp;lt;k</annotation></semantics></math>
puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>r_k</annotation></semantics></math> est orthogonal aux <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>p_j</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&leq;</mo><mi>i</mi><mi>&lt;</mi><mi>k</mi></mrow><annotation encoding='application/x-tex'>j \leq i &amp;lt;k</annotation></semantics></math>.
</li><li class="li-enumerate">On calcule la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>i+1</annotation></semantics></math>-ième composante de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> 
sur la famille orthogonale augmentée :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&alpha;</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mrow><mi>&lt;</mi><mi>b</mi><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi></mrow><mrow><mi>&lt;</mi><mi>A</mi><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\alpha_{i+1}=\frac{&amp;lt;b|p_{i+1}&amp;gt;}{&amp;lt;Ap_{i+1}|p_{i+1}&amp;gt;} </annotation></semantics></math>
On peut maintenant ajouter la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>i+1</annotation></semantics></math>-ième composante de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math> 
pour obtenir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>x</mi> <mi>i</mi></msub><mo>+</mo><msub><mi>&alpha;</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_{i+1}=x_i+\alpha_{i+1}p_{i+1}</annotation></semantics></math>. 
</li><li class="li-enumerate">Pour calculer efficacement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>p_{i+1}</annotation></semantics></math>, on observe que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>r</mi> <mi>k</mi></msub><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mi>A</mi><msub><mi>p</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>r_{k+1}&#x2d;r_k=A(x_{k&#x2d;1}&#x2d;x_{k})=&#x2d;\alpha_k A p_k </annotation></semantics></math>
Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{i+1}&#x2d;p_{i+1}</annotation></semantics></math> est orthogonal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>p_k</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>&lt;</mi><mi>i</mi></mrow><annotation encoding='application/x-tex'>k&amp;lt;i</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><mi>A</mi><msub><mi>p</mi> <mi>k</mi></msub><mi>&gt;</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mfrac><mn>1</mn><mi>&alpha;</mi></mfrac> <mi>k</mi></msub><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><mi>A</mi><msub><mi>p</mi> <mi>k</mi></msub><mi>&gt;</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mfrac><mn>1</mn><mi>&alpha;</mi></mfrac> <mi>k</mi></msub><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>r</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>r</mi> <mi>k</mi></msub><mi>&gt;</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>&amp;lt;r_{i+1}&#x2d;p_{i+1}|Ap_k&amp;gt;=&#x2d;\frac1\alpha_k&amp;lt;r_{i+1}|Ap_k&amp;gt;=&#x2d;\frac1\alpha_k&amp;lt;r_{i+1}|r_{k+1}&#x2d;r_k&amp;gt;=0 </annotation></semantics></math>
Ainsi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>&beta;</mi> <mi>i</mi></msub><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>r_{i+1}&#x2d;p_{i+1}=\beta_{i} p_i </annotation></semantics></math> et :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><mi>A</mi><msub><mi>p</mi> <mi>i</mi></msub><mi>&gt;</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mfrac><mn>1</mn><mi>&alpha;</mi></mfrac> <mi>i</mi></msub><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi><mo>=</mo><msub><mi>&beta;</mi> <mi>i</mi></msub><mi>&lt;</mi><msub><mi>p</mi> <mi>i</mi></msub><mo stretchy="false">&vert;</mo><mi>A</mi><msub><mi>p</mi> <mi>i</mi></msub><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;r_{i+1}&#x2d;p_{i+1}|Ap_i&amp;gt;=&#x2d;\frac1\alpha_i&amp;lt;r_{i+1}|r_{i+1}&amp;gt;=
\beta_i&amp;lt;p_i|Ap_i&amp;gt; </annotation></semantics></math>
</li><li class="li-enumerate">De plus :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&alpha;</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mrow><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi></mrow><mrow><mi>&lt;</mi><mi>A</mi><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\alpha_{i+1}=\frac{&amp;lt;r_{i+1}|r_{i+1}&amp;gt;}{&amp;lt;Ap_{i+1}|p_{i+1}&amp;gt;} </annotation></semantics></math>
En effet, comme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mi>A</mi><msub><mi>x</mi> <mi>i</mi></msub><mo>+</mo><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>b=Ax_i+r_{i+1}</annotation></semantics></math> et comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{i+1}</annotation></semantics></math> est orthogonal aux <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub><mo>,</mo><mi>j</mi><mo>&leq;</mo><mi>i</mi></mrow><annotation encoding='application/x-tex'>p_j, j \leq i</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mi>b</mi><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi><mo>=</mo><mi>&lt;</mi><mi>A</mi><msub><mi>x</mi> <mi>i</mi></msub><mo>+</mo><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi><mo>=</mo><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi><mo>=</mo><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;b|p_{i+1}&amp;gt;=&amp;lt;Ax_i+r_{i+1}|p_{i+1}&amp;gt;=&amp;lt;r_{i+1}|p_{i+1}&amp;gt;=&amp;lt;r_{i+1}|r_{i+1}&amp;gt; </annotation></semantics></math>
</li><li class="li-enumerate">Donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&beta;</mi> <mi>i</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><mi>&lt;</mi><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>&gt;</mi></mrow><mrow><mi>&lt;</mi><msub><mi>r</mi> <mi>i</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>r</mi> <mi>i</mi></msub><mi>&gt;</mi></mrow></mfrac><mo>,</mo><mspace width="1em"/><msub><mi>p</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>&beta;</mi> <mi>i</mi></msub><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>\beta_i=&#x2d;\frac{&amp;lt;r_{i+1}|r_{i+1}&amp;gt;}{&amp;lt;r_{i}|r_{i}&amp;gt;},
\quad p_{i+1}=r_{i+1}&#x2d;\beta_i p_i </annotation></semantics></math>
</li></ol><p>
On s’arrête en au plus la dimension itérations 
lorsque la famille orthogonale est devenue une base. En grande
dimension, on peut décider de s’arrêter prématurément
sur une solution approchée en testant
si la norme de la valeur du résidu vérifie
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><msub><mi>r</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&Vert;</mo><mo>=</mo><mo stretchy="false">&Vert;</mo><mi>b</mi><mo>&minus;</mo><mi>A</mi><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">&Vert;</mo><mi>&lt;</mi><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\|r_{i+1}\|=\|b&#x2d;Ax_i\|&amp;lt;\varepsilon</annotation></semantics></math>.</p><p>La commande <code>conjugate_gradient(A,b)</code> de Xcas permet de faire ce
calcul, on peut préciser une valeur initiale de recherche <code>x0</code>
et une précision <code>eps</code> en tapant 
<code>conjugate_gradient(A,b,x0,eps)</code>.
Voir aussi le programme en langage Xcas depuis le 
menu <span style="font-family:monospace">Exemple, analyse, gradconj</span></p>
<!--TOC section id="sec258" Réduction approchée des endomorphismes-->
<h2 id="sec258" class="section">22.10  Réduction approchée des endomorphismes</h2><!--SEC END --><p>
On pourrait trouver des valeurs propres approchées d’une matrice
en calculant le polynome caractéristique ou minimal puis en le
factorisant numériquement. Mais cette méthode n’est pas idéale
relativement aux erreurs d’arrondis (calcul du polynome caractéristiaue,
de ses racines, et nouvelle approximation en calculant le noyau
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>&minus;</mo><mi>&lambda;</mi><mi>I</mi></mrow><annotation encoding='application/x-tex'>A&#x2d;\lambda I</annotation></semantics></math>), lorsqu’on veut calculer quelques valeurs propres
on préfère utiliser des méthodes itératives directement sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>
ce qui évite la propagation des erreurs d’arrondi.</p>
<!--TOC subsection id="sec259" Méthode de la puissance-->
<h3 id="sec259" class="subsection">22.10.1  Méthode de la puissance</h3><!--SEC END --><p> <a id="hevea_default300"></a>
Elle permet de déterminer la plus grande valeur propre en valeur absolue
d’une matrice diagonalisable lorsque celle-ci est unique.
Supposons en effet que les valeurs propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> soient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_1,...,x_n</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>2</mn></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x_1| \leq |x_2| \leq ... \leq |x_{n&#x2d;1}| &amp;lt; |x_n|</annotation></semantics></math>
et soient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>e</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>e_1,...,e_n</annotation></semantics></math> une base de vecteurs propres correspondants.
On choisit un vecteur aléatoire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> et on calcule la suite
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub><mo>=</mo><mi>A</mi><msub><mi>v</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><msup><mi>A</mi> <mi>k</mi></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>v_k=Av_{k&#x2d;1}=A^k v </annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> a pour coordonnées <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>V</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>V</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>V_1,...,V_n)</annotation></semantics></math> 
dans la base propre, alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>V</mi> <mi>j</mi></msub><msubsup><mi>x</mi> <mi>j</mi> <mi>k</mi></msubsup><msub><mi>e</mi> <mi>j</mi></msub><mo>=</mo><msubsup><mi>x</mi> <mi>n</mi> <mi>k</mi></msubsup><msub><mi>w</mi> <mi>k</mi></msub><mo>,</mo><mspace width="1em"/><msub><mi>w</mi> <mi>k</mi></msub><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>V</mi> <mi>j</mi></msub><msup><mrow><mo>(</mo><mfrac><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow></mfrac><mo>)</mo></mrow> <mi>k</mi></msup><msub><mi>e</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'> v_k = \sum_{j=1}^n V_j x_j^k e_j 
= x_n^k w_k, \quad w_k=\sum_{j=1}^n V_j \left(\frac{x_j}{x_n}\right)^k e_j
 </annotation></semantics></math>
L’hypothèse que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math> est l’unique valeur propre
de module maximal entraine alors 
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>lim</mi> <mrow><mi>k</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msub><msub><mi>w</mi> <mi>k</mi></msub><mo>=</mo><msub><mi>V</mi> <mi>n</mi></msub><msub><mi>e</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>\lim_{k \rightarrow +\infty} w_k = V_n e_n</annotation></semantics></math> puisque la suite
géométrique de raison <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">/</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_j/x_n</annotation></semantics></math> converge vers 0.
Autrement dit, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>V</mi> <mi>n</mi></msub><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>V_n\neq 0</annotation></semantics></math> (ce qui a une probabilité 1 d’être
vrai pour un vecteur aléatoire), 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math> est équivalent à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>V</mi> <mi>n</mi></msub><msubsup><mi>x</mi> <mi>n</mi> <mi>k</mi></msubsup><msub><mi>e</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>V_n x_n^k e_n</annotation></semantics></math>. Lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
est grand, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math> est presque colinéaire au vecteur propre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>e_n</annotation></semantics></math> (que l’on peut estimer par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math> divisé par sa norme), 
ce que l’on détecte en testant si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{k+1}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math>
sont presques colinéaires. De plus le facteur de colinéarité
entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{k+1}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math> est presque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math>, la valeur propre
de module maximal.</p><p>En pratique, pour éviter des débordements d’exposant des
coordonnées des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math> on normalise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math> à chaque
étape, on pose donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi>v</mi> <mi>k</mi></msub><mo>,</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>w</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">/</mo><mo stretchy="false">&Vert;</mo><msub><mi>w</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&Vert;</mo></mrow><annotation encoding='application/x-tex'>w_{k+1}=Av_k, v_{k+1}=w_{k+1}/\|w_{k+1}\|</annotation></semantics></math> 
et on estime <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math> en calculant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>k</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>w</mi> <mi>k</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\lambda_k=(w_k|v_k)</annotation></semantics></math>.</p><p>Lorsque la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est symétrique réelle ou hermitienne
complexe, on peut utiliser comme
test d’arrêt <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>k</mi></msub><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">&Vert;</mo><mo>&leq;</mo><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\| w_k&#x2d;\lambda_k v_k\| \leq \varepsilon </annotation></semantics></math>. En effet,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est alors diagonalisable dans une base orthonormale,
on écrit la relation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">&Vert;</mo><mo>&leq;</mo><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\| (A&#x2d;\lambda_k)v_k \| \leq \varepsilon</annotation></semantics></math>
dans cette base et on obtient qu’il existe une valeur propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>
à distance inférieure ou égale à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math> de
la valeur propre estimée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda_k</annotation></semantics></math>. Ce résultat n’est
malheureusement plus vrai si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est quelconque, car deux
vecteurs propres peuvent faire un angle très petit. Par
exemple la matrice 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mo>&minus;</mo><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mn>1</mn><mi>&epsi;</mi></mfrac></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>A=\left(\begin{array}{cc} 
&#x2d;1 &amp; 0\\
&#x2d;\frac1\epsilon&amp; 1
\end{array}\right) </annotation></semantics></math>
a pour valeurs propres <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>&#x2d;1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn></mrow><annotation encoding='application/x-tex'>1</annotation></semantics></math> mais
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mrow><mo>(</mo><msup><mo/><mi>&epsi;</mi></msup><msub><mo/><mn>1</mn></msub><mo>)</mo></mrow><mo>=</mo><mrow><mo>(</mo><msup><mo/><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&epsi;</mi></mrow></msup><msub><mo/><mn>0</mn></msub><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>A\left(^\epsilon_1\right)=\left(^{&#x2d;\epsilon}_0\right)</annotation></semantics></math> donc 0 semble
être une valeur propre approchée. Il vaut alors mieux tester
l’écart entre deux estimations consécutives de la valeur
propre, en effet au premier ordre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&lambda;</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>&approx;</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>j</mi></munder><msub><mi>&beta;</mi> <mi>j</mi></msub><msup><mrow><mo>(</mo><mfrac><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow></mfrac><mo>)</mo></mrow> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>\lambda_k&#x2d;x_n \approx \sum_j \beta_j \left( \frac{x_j}{x_n}\right)^k </annotation></semantics></math>
où la somme porte sur les indices <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> des valeurs propres
de module sous-dominant. En général cette somme se
réduit au seul indice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>=</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>j=n&#x2d;1</annotation></semantics></math>, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda_{k+1}&#x2d;\lambda_k</annotation></semantics></math> se
comporte comme une suite géométrique (de raison <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">/</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_j/x_n</annotation></semantics></math>),
on peut alors estimer l’erreur par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>&lambda;</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&epsi;</mi><mo>,</mo><mspace width="1em"/><mi>&epsi;</mi><msub><mo>&approx;</mo> <mrow><mi>k</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow></msub><mfrac><mrow><mo stretchy="false">&vert;</mo><msub><mi>&lambda;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>k</mi></msub><mo stretchy="false">&vert;</mo></mrow><mrow><mn>1</mn><mo>&minus;</mo><mo stretchy="false">&vert;</mo><mfrac><mrow><msub><mi>&lambda;</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><msub><mi>&lambda;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mrow><msub><mi>&lambda;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>k</mi></msub></mrow></mfrac><mo stretchy="false">&vert;</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>|\lambda_k&#x2d;x_n| \leq \epsilon, \quad
\epsilon \approx_{k \rightarrow +\infty} \frac{|\lambda_{k+1}&#x2d;\lambda_k|}
{1&#x2d;|\frac{\lambda_{k+2}&#x2d;\lambda_{k+1}}{\lambda_{k+1}&#x2d;\lambda_k}|}
 </annotation></semantics></math>
Mais cette estimation n’est plus correcte s’il y a plusieurs indices
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> sous-dominants (cas par exemple d’une paire 
de valeurs propres conjuguées
pour une matrice réelle).</p><p>Exercice : tester la convergence de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub><mo>=</mo><msup><mi>A</mi> <mi>k</mi></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>v_k=A^kv</annotation></semantics></math> vers l’espace propre
associé à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>\lambda=3</annotation></semantics></math> pour la matrice <code>[[1,-1],[2,4]]</code>
et le vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v=(1,0)</annotation></semantics></math>. Attention à ne pas calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>A^k</annotation></semantics></math> pour
déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math>, utiliser la relation de récurrence!</p><p>Si on n’observe pas de convergence ou si elle est trop lente, alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x_{n&#x2d;1}|</annotation></semantics></math> est proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x_n|</annotation></semantics></math> ou égal, il est judicieux
de faire subir à la matrice un shift, on remplace <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>&minus;</mo><mi>&lambda;</mi><mi>I</mi></mrow><annotation encoding='application/x-tex'>A&#x2d;\lambda I</annotation></semantics></math>. On peut prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi></mrow><annotation encoding='application/x-tex'>\lambda</annotation></semantics></math> aléatoirement, ou bien
mieux faire des itérations inverses sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>&minus;</mo><mi>&lambda;</mi><mi>I</mi></mrow><annotation encoding='application/x-tex'>A&#x2d;\lambda I</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi></mrow><annotation encoding='application/x-tex'>\lambda</annotation></semantics></math>
est une estimation d’une valeur propre (voir les itérations inverses
ci-dessous).</p><p>Lorsqu’on applique cette méthode a une matrice réelle, il peut arriver
quíl y ait deux valeurs propres conjuguées de module maximal. On
peut appliquer la méthode ci-dessus avec un shift complexe non réel,
mais on doit alors travailler en arithmétique complexe 
ce qui est plus couteux. Le même
type de raisonnement que ci-dessus montre que pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> grand,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{k+2}</annotation></semantics></math> est presque colinéaire à l’espace engendré par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_k</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>v_{k+1}</annotation></semantics></math>, 
la recherche d’une relation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>+</mo><mi>b</mi><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>v</mi> <mi>k</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> av_{k+2}+ b v_{k+1} + v_k=0</annotation></semantics></math> 
permet alors de calculer les valeurs propres qui sont les deux racines
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>x</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>ax^2+bx+1=0</annotation></semantics></math>.</p><p>La convergence est de type série géométrique, on gagne le même nombre
de décimales à chaque itération. </p><p>Applications : 
</p><ul class="itemize"><li class="li-itemize">
la méthode de la puissance peut donner
une estimation du nombre de condition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>L^2</annotation></semantics></math> d’une
matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>. On calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>=</mo><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>B=A^* A</annotation></semantics></math> puis on effectue
cette méthode sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> pour avoir une estimation
de la plus grande valeur propre, puis “sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>B</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>B^{&#x2d;1}</annotation></semantics></math>”
par itérations inverses et on fait le rapport des racines carrées.
C’est une méthode intéressante si la matrice
est creuse et symétrique (pour pouvoir faire Cholesky creux
pour les itérations inverses).
</li><li class="li-itemize">la méthode de la puissance peut donner une estimation
rapide de la taille de la plus grande racine d’un polynôme (en
module), en itérant sur la matrice companion du polynôme,
matrice qui contient beaucoup de 0, donc le produit avec un vecteur
se fait en temps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n)</annotation></semantics></math>, où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est le degré du polynôme.
<pre class="verbatim">f(P,eps,N):={
  local k,l,n,v,old,new,oldratio,tmp;
  l:=coeffs(P);
  n:=degree(P);
  l:=revlist(l[1..n]/l[0]);
  v:=randvector(n,uniformd,-1,1);
  oldratio:=inf;
  for k from 1 to N do
    old:=maxnorm(v);
    tmp := -l[0]*v[n-1];
    for j from 1 to n-1 do
      v[j] =&lt; v[j-1]-l[j]*v[n-1];
    od;
    v[0] =&lt; tmp;
    new:=maxnorm(v);
    if (abs(new/old-oldratio)&lt;eps) return new/old;
    oldratio:=new/old;
  od;
  retourne undef;
}:;
</pre>
</li></ul><p>Ceci peut par exemple servir à déterminer pour un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> donné
squarefree (de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> et coefficient dominant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>p_n</annotation></semantics></math>)
l’écart minimal entre 2 racines, on calcule<br>
<code>R:=normal(resultant(P,subst(P,x=x+y),x)/x^degree(P))</code><br>
c’est un polynôme bicarré dont on cherche la plus petite racine
en calculant le carré de la plus grande racine en module
de <code>numer(subst(R,y=1/sqrt(x)))</code>.</p><p>On peut obtenir un minorant à priori de cette plus petit racine en calculant 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtext>resultant</mtext><mo stretchy="false">(</mo><mi>P</mi><mo>,</mo><mi>P</mi><mo>&prime;</mo><mo stretchy="false">)</mo><mo>=</mo><mo>&pm;</mo><msubsup><mi>p</mi> <mi>n</mi> <mrow><mn>2</mn><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msubsup><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mn>1</mn><mo>&leq;</mo><mi>i</mi><mi>&lt;</mi><mi>j</mi><mo>&leq;</mo><mi>n</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>r</mi> <mi>i</mi></msub><mo>&minus;</mo><msub><mi>r</mi> <mi>j</mi></msub><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'> 
\mbox{resultant}(P,P&apos;)= 
\pm p_n^{2n&#x2d;1} \prod_{1 \leq i &amp;lt; j \leq n} (r_i&#x2d;r_j)^2 
 </annotation></semantics></math>
on isole l’écart minimal au carré, on majore les autres carrés en
majorant les racines, et
on peut minorer le résultant à priori par 1 si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est à coefficients
entiers.</p>
<!--TOC subsection id="sec260" Itérations inverses-->
<h3 id="sec260" class="subsection">22.10.2  Itérations inverses</h3><!--SEC END --><p> <a id="hevea_default301"></a>
La méthode précédente permet de calculer la valeur propre
de module maximal d’une matrice. Pour trouver une valeur
propre proche d’une quantité donnée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>, on peut appliquer
la méthode précédente à la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><mi>x</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>(A&#x2d;xI)^{&#x2d;1}</annotation></semantics></math> (en pratique
on effectue <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>&minus;</mo><mi>x</mi><mi>I</mi></mrow><annotation encoding='application/x-tex'>A&#x2d;xI</annotation></semantics></math> et on résoud <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><mi>x</mi><mi>I</mi><mo stretchy="false">)</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>(A&#x2d;xI)u_{n+1}=u_n</annotation></semantics></math>). En effet,
les valeurs propres de cette matrice sont les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>(x_i&#x2d;x)^{&#x2d;1}</annotation></semantics></math> dont
la norme est maximale lorsqu’on se rapproche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math>. Attention
à ne pas prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> trop proche d’une valeur propre, car le calcul
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><mi>x</mi><mi>I</mi><mo stretchy="false">)</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>(A&#x2d;xI)u_{n+1}=u_n</annotation></semantics></math> est alors peu précis (la matrice étant
mal conditionnée).</p>
<!--TOC subsection id="sec261" Elimination des valeurs propres trouvées-->
<h3 id="sec261" class="subsection">22.10.3  Elimination des valeurs propres trouvées</h3><!--SEC END --><p>
Si la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est symétrique, et
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>e_n</annotation></semantics></math> est un vecteur propre normé écrit en colonne, on peut considérer
la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>=</mo><mi>A</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><msub><mi>e</mi> <mi>n</mi></msub><msubsup><mi>e</mi> <mi>n</mi> <mi>t</mi></msubsup></mrow><annotation encoding='application/x-tex'>B=A&#x2d;x_n e_n e_n^t</annotation></semantics></math> qui possède les mêmes valeurs
propres et mêmes vecteurs propres que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> avec même multiplicité, 
sauf <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math> qui est remplacé par 0. 
En effet les espaces propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> sont orthogonaux
entre eux, donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>B</mi><msub><mi>e</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>x</mi> <mi>n</mi></msub><msub><mi>e</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><msub><mi>e</mi> <mi>n</mi></msub><msubsup><mi>e</mi> <mi>n</mi> <mi>t</mi></msubsup><msub><mi>e</mi> <mi>n</mi></msub><mo>=</mo><mn>0</mn><mo>,</mo><mi>B</mi><msub><mi>e</mi> <mi>k</mi></msub><mo>=</mo><msub><mi>x</mi> <mi>k</mi></msub><msub><mi>e</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><msub><mi>e</mi> <mi>n</mi></msub><msubsup><mi>e</mi> <mi>n</mi> <mi>t</mi></msubsup><msub><mi>e</mi> <mi>k</mi></msub><mo>=</mo><msub><mi>x</mi> <mi>k</mi></msub><msub><mi>e</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'> Be_n=x_ne_n &#x2d;x_n e_n e_n^t e_n = 0,
Be_k = x_k e_k &#x2d; x_n e_n e_n^t e_k = x_k e_k </annotation></semantics></math>
On peut donc calculer
la 2ème valeur propre (en valeur absolue), l’éliminer
et ainsi de suite.</p><p>Si la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> n’est pas symétrique, il faut considérer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>=</mo><mi>A</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><msub><mi>e</mi> <mi>n</mi></msub><msubsup><mi>f</mi> <mi>n</mi> <mi>t</mi></msubsup><mo stretchy="false">/</mo><msub><mi>e</mi> <mi>n</mi></msub><mo>.</mo><msub><mi>f</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>B=A&#x2d;x_n e_n f_n^t /e_n.f_n</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>f</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>f_n</annotation></semantics></math> est vecteur propre
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>A^t</annotation></semantics></math> associé à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math>. En effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>f</mi> <mi>k</mi></msub><mo>.</mo><msub><mi>e</mi> <mi>j</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f_k.e_j=0</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>&ne;</mo><mi>j</mi></mrow><annotation encoding='application/x-tex'>i \neq j</annotation></semantics></math>
car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msub><mi>e</mi> <mi>k</mi></msub><mo>.</mo><msub><mi>f</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>x</mi> <mi>k</mi></msub><msub><mi>e</mi> <mi>k</mi></msub><mo>.</mo><msub><mi>f</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>e</mi> <mi>k</mi></msub><mo>.</mo><msup><mi>A</mi> <mi>t</mi></msup><msub><mi>f</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>x</mi> <mi>j</mi></msub><msub><mi>e</mi> <mi>k</mi></msub><msub><mi>f</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Ae_k.f_j=x_ke_k.f_j=e_k.A^tf_j=x_je_kf_j</annotation></semantics></math> et donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>f</mi> <mi>k</mi></msub><mo>.</mo><msub><mi>e</mi> <mi>k</mi></msub><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f_k.e_k \neq 0</annotation></semantics></math>
(sinon <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>e_k</annotation></semantics></math> est dans l’orthogonal de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup><mo>=</mo></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n=</annotation></semantics></math>Vect<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>f</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>f</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(f_1,...,f_n)</annotation></semantics></math>.</p>
<!--TOC subsection id="sec262" Décomposition de Schur-->
<h3 id="sec262" class="subsection">22.10.4  Décomposition de Schur</h3><!--SEC END --><p><a id="hevea_default302"></a>
<a id="hevea_default303"></a>
Il s’agit d’une factorisation de matrice sous la forme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mi>P</mi><mi>S</mi><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> A = P S P^{&#x2d;1} </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est unitaire et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math> diagonale supérieure.
Existence (théorique) : 
on prend une valeur propre et un vecteur propre correspondant,
puis on projette sur l’orthogonal de ce vecteur propre et on s’y
restreint, on prend à nouveau une valeur propre et un vecteur propre
correspondant, etc.</p><p>On peut approcher cette factorisation par un algorithme itératif
qui utilise la <span style="font-weight:bold">factorisation </span><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math><a id="hevea_default304"></a> 
d’une matrice quelconque comme
produit d’une matrice unitaire par une matrice triangulaire supérieure
à coefficients positifs sur la diagonale. On fait l’hypothèse que les
valeurs propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math> sur la diagonale sont classées par ordre de module 
strictement décroissant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>&lambda;</mi> <mn>1</mn></msub><mo stretchy="false">&vert;</mo><mi>&gt;</mi><mo stretchy="false">&vert;</mo><msub><mi>&lambda;</mi> <mn>2</mn></msub><mo stretchy="false">&vert;</mo><mi>&gt;</mi><mo>.</mo><mo>.</mo><mo>.</mo><mi>&gt;</mi><mo stretchy="false">&vert;</mo><msub><mi>&lambda;</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|\lambda_1|&amp;gt;|\lambda_2|&amp;gt;...&amp;gt;|\lambda_n|</annotation></semantics></math> 
(développement inspiré par Peter J. Olver dans le cas symétrique
<code>http://www.math.umn.edu/~olver/aims_/qr.pdf</code>). On peut toujours
s’y ramener quitte à remplacer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>&minus;</mo><mi>&alpha;</mi><mi>I</mi></mrow><annotation encoding='application/x-tex'>A&#x2d; \alpha I</annotation></semantics></math>.
Posons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mn>1</mn></msub><mo>=</mo><mi>A</mi></mrow><annotation encoding='application/x-tex'>A_1=A</annotation></semantics></math>, et par récurrence <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>Q</mi> <mi>n</mi></msub><msub><mi>R</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>A_n=Q_nR_n</annotation></semantics></math> (avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Q_n</annotation></semantics></math> unitaire et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math>
triangulaire supérieure à coefficients diagonaux positifs), 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>R</mi> <mi>n</mi></msub><msub><mi>Q</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>A_{n+1}=R_nQ_n</annotation></semantics></math>. On a alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msup><mi>A</mi> <mi>k</mi></msup></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>R</mi> <mn>1</mn></msub><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>R</mi> <mn>1</mn></msub><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>R</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>R</mi> <mn>1</mn></msub><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><msub><mi>R</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>2</mn></msub><msub><mi>R</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>2</mn></msub><msub><mi>R</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>2</mn></msub><msub><mi>R</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><msub><mi>R</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>Q</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>R</mi> <mn>2</mn></msub><msub><mi>Q</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><msub><mi>R</mi> <mn>2</mn></msub><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mn>2</mn></msub><msub><mi>R</mi> <mn>2</mn></msub><msub><mi>R</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>Q</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>3</mn></msub><msub><mi>R</mi> <mn>3</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mn>3</mn></msub><msub><mi>R</mi> <mn>3</mn></msub><msub><mi>R</mi> <mn>2</mn></msub><msub><mi>R</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>R</mi> <mi>k</mi></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>R</mi> <mn>1</mn></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 A^k  
&amp; = &amp; (Q_1 R_1) (Q_1 R_1) (Q_1 R_1) ... (Q_1 R_1) (Q_1 R_1) \\
&amp; = &amp; Q_1 (R_1 Q_1) (R_1 Q_1) (R_1 ... Q_1) (R_1 Q_1) R_1 \\
&amp; = &amp; Q_1 (Q_2 R_2) (Q_2 R_2) .. (Q_2 R_2) R_1 \\
&amp; = &amp; Q_1 Q_2 (R_2 Q_2) R_2 .. Q_2 R_2 R_1 \\
&amp; = &amp; Q_1 Q_2 (Q_3 R_3) ... Q_3 R_3 R_2 R_1 \\
&amp; = &amp; Q_1 ... Q_k R_k ...R_1
 \end{matrix} </annotation></semantics></math>
D’autre part <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>P</mi><mi>S</mi><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A=PSP^{&#x2d;1}</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mi>k</mi></msup><mo>=</mo><mi>P</mi><msup><mi>S</mi> <mi>k</mi></msup><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>A^k = P S^k P^{&#x2d;1}</annotation></semantics></math>. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> la forme diagonale
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> la matrice de passage <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi><mo>=</mo><mi>U</mi><mi>D</mi><msup><mi>U</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>S=UDU^{&#x2d;1}</annotation></semantics></math>, où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> est triangulaire supérieure
et où on choisit la normalisation des coefficients sur la diagonale de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> valant 1.
On a donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>A</mi> <mi>k</mi></msup><mo>=</mo><mi>P</mi><mi>U</mi><msup><mi>D</mi> <mi>k</mi></msup><msup><mi>U</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> A^k = P U D^{k} U^{&#x2d;1} P^{&#x2d;1}  </annotation></semantics></math>
Ensuite, on suppose
qu’on peut factoriser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>U</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mi>L</mi><mover><mi>U</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>U^{&#x2d;1}P^{&#x2d;1}=L\tilde{U}</annotation></semantics></math> sans permutations, donc
qu’on ne rencontre pas de pivot nul, et quitte à multiplier 
les vecteurs unitaires de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>P^{&#x2d;1}</annotation></semantics></math> par une constante complexe de module 1
on peut supposer que les pivots sont positifs donc que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>U</mi><mo stretchy="false">&tilde;</mo></mover></mrow><annotation encoding='application/x-tex'>\tilde{U}</annotation></semantics></math> a
des coefficients positifs sur la diagonale, on a alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>A</mi> <mi>k</mi></msup><mo>=</mo><mi>P</mi><mi>U</mi><msup><mi>D</mi> <mi>k</mi></msup><mi>L</mi><mover><mi>U</mi><mo stretchy="false">&tilde;</mo></mover><mo>=</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>R</mi> <mi>k</mi></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'> A^k = P U D^k L \tilde{U} = Q_1 ... Q_k R_k ...R_1  </annotation></semantics></math>
puis en multipliant par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mover><mi>U</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">&vert;</mo><mi>D</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>\tilde{U}^{&#x2d;1} |D|^{&#x2d;k}</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mi>U</mi><msup><mi>D</mi> <mi>k</mi></msup><mi>L</mi><mo stretchy="false">&vert;</mo><mi>D</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi></mrow></msup><mo>=</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>R</mi> <mi>k</mi></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>R</mi> <mn>1</mn></msub><msup><mover><mi>U</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">&vert;</mo><mi>D</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'> P U D^k L |D|^{&#x2d;k} =  Q_1 ... Q_k R_k ...R_1 \tilde{U}^{&#x2d;1} |D|^{&#x2d;k}  </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>k</mi></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>R</mi> <mn>1</mn></msub><msup><mover><mi>U</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">&vert;</mo><mi>D</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>R_k ...R_1 \tilde{U}^{&#x2d;1} |D|^{&#x2d;k}</annotation></semantics></math> est triangulaire supérieure à coefficients positifs
sur la diagonale et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>Q_1 ... Q_k</annotation></semantics></math> est unitaire. On regarde ensuite les entrées 
de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>D</mi> <mi>k</mi></msup><mi>L</mi><mo stretchy="false">&vert;</mo><mi>D</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>D^k L |D|^{&#x2d;k}</annotation></semantics></math>, sous la diagonale elles convergent (géométriquement) vers 0,
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi><msup><mi>D</mi> <mi>k</mi></msup><mi>L</mi><mo stretchy="false">&vert;</mo><mi>D</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>UD^k L |D|^{&#x2d;k}</annotation></semantics></math> tend vers une matrice triangulaire supérieure
dont les coefficients diagonaux valent <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>i</mi><mi>k</mi><mi>arg</mi><mo stretchy="false">(</mo><msub><mi>&lambda;</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{i k\arg(\lambda_j)}</annotation></semantics></math>. On montre que cela
entraine que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>Q_1 ... Q_k </annotation></semantics></math> est équivalent à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">/</mo><mo stretchy="false">&vert;</mo><mi>D</mi><mo stretchy="false">&vert;</mo><msup><mo stretchy="false">)</mo> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>P(D/|D|)^k</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub><mo>&approx;</mo><mi>P</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">/</mo><mo stretchy="false">&vert;</mo><mi>D</mi><mo stretchy="false">&vert;</mo><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mo>,</mo><mspace width="1em"/><msub><mi>R</mi> <mi>k</mi></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>R</mi> <mn>1</mn></msub><msup><mover><mi>U</mi><mo stretchy="false">&tilde;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">&vert;</mo><mi>D</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi></mrow></msup><mo>&approx;</mo><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">/</mo><mo stretchy="false">&vert;</mo><mi>D</mi><mo stretchy="false">&vert;</mo><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi></mrow></msup><mi>U</mi><msup><mi>D</mi> <mi>k</mi></msup><mi>L</mi><mo stretchy="false">&vert;</mo><mi>D</mi><msup><mo stretchy="false">&vert;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'> Q_1 ... Q_k \approx P (D/|D|)^{k}, \quad  
R_k ...R_1 \tilde{U}^{&#x2d;1} |D|^{&#x2d;k} \approx (D/|D|)^{&#x2d;k} UD^k L |D|^{&#x2d;k}  </annotation></semantics></math>
Donc, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>Q_k</annotation></semantics></math> tend à devenir diagonale, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>k</mi></msub><msub><mi>Q</mi> <mi>k</mi></msub><mo>=</mo><msub><mi>A</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>R_k Q_k=A_{k+1}</annotation></semantics></math> triangulaire supérieure. De plus
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>A</mi> <mn>2</mn></msub><msubsup><mi>Q</mi> <mn>1</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>=</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>A</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> A=Q_1 A_2 Q_1^{&#x2d;1} = ... = Q_1 ... Q_k A_{k+1} (Q_1 ... Q_k)^{&#x2d;1}  </annotation></semantics></math>
la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>A_{k+1}</annotation></semantics></math> est donc semblable à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>.</p><p>En pratique, on n’impose pas la positivité des coefficients diagonaux de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math>
dans la factorisation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math>, ce qui ne change
évidemment pas le fait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>Q_k</annotation></semantics></math> s’approche d’une matrice diagonale et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>A_k</annotation></semantics></math> d’une matrice
triangulaire supérieure (avec convergence à vitesse géométrique).
On commence aussi par mettre la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> sous forme de Hessenberg
(par conjugaison par des matrices de Householder),
c’est-à-dire presque triangulaire supérieure (on autorise des
coefficients non nuls dans la partie inférieure seulement sur la sous-diagonale, 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>a_{ij}=0</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mi>&gt;</mi><mi>j</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>i&amp;gt;j+1</annotation></semantics></math>). Cela réduit considérablement le temps de calcul de la
décomposition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math>, le produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mi>Q</mi></mrow><annotation encoding='application/x-tex'>RQ</annotation></semantics></math> ayant encore cette
propriété, une itération se fait en temps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^2)</annotation></semantics></math> au lieu de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3)</annotation></semantics></math>. Le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mi>Q</mi></mrow><annotation encoding='application/x-tex'>RQ</annotation></semantics></math> à partir de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est d’ailleurs fait directement,
on parle d’itération <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> implicite.</p><p>On utilise aussi des “shifts” pour accélerer la convergence, c’est-à-dire qu’au lieu
de faire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mi>Q</mi></mrow><annotation encoding='application/x-tex'>RQ</annotation></semantics></math> sur la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>A_k</annotation></semantics></math> on le fait sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mi>I</mi></mrow><annotation encoding='application/x-tex'>A_k &#x2d; \alpha_k I</annotation></semantics></math> où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda_k</annotation></semantics></math> est choisi pour accélerer la convergence vers 0 du coefficient d’indice
ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> (idéalement il faut prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\alpha_k</annotation></semantics></math> proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda_n</annotation></semantics></math> la
valeur propre de module minimal, afin de minimiser 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>&lambda;</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mo stretchy="false">&vert;</mo><msub><mi>&lambda;</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|\lambda_n&#x2d;\alpha_k|/|\lambda_{n&#x2d;1}&#x2d;\alpha_k|</annotation></semantics></math>). 
En effet, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>&lambda;</mi> <mi>k</mi></msub><mi>I</mi><mo>=</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>R</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>A_k &#x2d; \lambda_k I = Q_k R_k</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>R</mi> <mi>k</mi></msub><msub><mi>Q</mi> <mi>k</mi></msub><mo>+</mo><msub><mi>&lambda;</mi> <mi>k</mi></msub><mi>I</mi></mrow><annotation encoding='application/x-tex'>A_{k+1}=R_kQ_k+\lambda_k I</annotation></semantics></math> alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mi>I</mi><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mi>I</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>R</mi> <mn>1</mn></msub><msub><mi>Q</mi> <mn>1</mn></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">)</mo><msub><mi>R</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mn>3</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>A</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mi>I</mi><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">)</mo><msub><mi>R</mi> <mn>1</mn></msub><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>R</mi> <mn>1</mn></msub><msub><mi>Q</mi> <mn>1</mn></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mn>3</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">)</mo><msub><mi>R</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><msub><mi>Q</mi> <mn>1</mn></msub><msub><mi>R</mi> <mn>1</mn></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>I</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>A</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>2</mn></msub><mi>I</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>A</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mn>3</mn></msub><mi>I</mi><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><msub><mi>A</mi> <mn>2</mn></msub><mo>&minus;</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><mi>I</mi><mo stretchy="false">)</mo><msub><mi>R</mi> <mn>1</mn></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>R</mi> <mi>k</mi></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>R</mi> <mn>1</mn></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 (A&#x2d;\alpha_1 I) ... (A&#x2d;\alpha_k I) &amp;= &amp;
Q_1R_1(Q_1R_1&#x2d;(\alpha_2&#x2d;\alpha_1)I) ...(Q_1R_1&#x2d;(\alpha_k&#x2d;\alpha_1)I)
\\ &amp;=&amp; Q_1 (R_1Q_1 &#x2d; (\alpha_2&#x2d;\alpha_1)I)R_1 
(Q_1R_1&#x2d;(\alpha_3&#x2d;\alpha_1)I) ...(Q_1R_1&#x2d;(\alpha_k&#x2d;\alpha_1)I)
\\ &amp;=&amp; Q_1 (A_2 &#x2d; \alpha_1 I &#x2d;(\alpha_2&#x2d;\alpha_1)I) R_1 
Q_1(R_1Q_1&#x2d;(\alpha_3&#x2d;\alpha_1)I) R_1...(Q_1R_1&#x2d;(\alpha_k&#x2d;\alpha_1)I)
\\ &amp;=&amp; Q_1 (A_2 &#x2d; \alpha_2 I) (A_2 &#x2d; \alpha_3 I) ... (A_2 &#x2d; \alpha_{k}I) R_1
\\ &amp;=&amp; ...
\\&amp;=&amp;Q_1 ... Q_k R_k ...R_1
 \end{matrix} </annotation></semantics></math>
On peut aussi éliminer la dernière
ligne et la dernière colonne de la matrice pour accélerer les calculs dès que le coefficient
en ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> est suffisamment petit.</p><p>On remarque que pour une matrice réelle si on choisit des shifts conjugués,
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>Q</mi> <mi>k</mi></msub><msub><mi>R</mi> <mi>k</mi></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>R</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1...Q_k R_k...R_1</annotation></semantics></math> est réel. Or si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi><mo>=</mo><mover><mi>Q</mi><mo>&#x000AF;</mo></mover><mover><mi>R</mi><mo>&#x000AF;</mo></mover></mrow><annotation encoding='application/x-tex'>QR=\overline{Q}\overline{R}</annotation></semantics></math>
et si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> est inversible
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mover><mi>Q</mi><mo>&#x000AF;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>Q</mi><mo>=</mo><mover><mi>R</mi><mo>&#x000AF;</mo></mover><msup><mi>R</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> \overline{Q}^{&#x2d;1} Q = \overline{R} R^{&#x2d;1}  </annotation></semantics></math>
On a donc une matrice symétrique (car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mover><mi>Q</mi><mo>&#x000AF;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>Q</mi> <mi>t</mi></msup></mrow><annotation encoding='application/x-tex'>\overline{Q}^{&#x2d;1}=Q^t</annotation></semantics></math>) 
et triangulaire supérieure. On en déduit que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mover><mi>Q</mi><mo>&#x000AF;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>Q</mi><mo>=</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'>\overline{Q}^{&#x2d;1} Q=D</annotation></semantics></math> est diagonale, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><mover><mi>Q</mi><mo>&#x000AF;</mo></mover><mi>D</mi></mrow><annotation encoding='application/x-tex'>Q=\overline{Q} D</annotation></semantics></math>. On peut
donc rendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> réelle en divisant chaque colonne par un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>i</mi><mi>&theta;</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{i\theta}</annotation></semantics></math>, et
rendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> réelle en conjuguant par la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>.
Mais ce procédé de retour au réel après élimination de 2 valeurs propres
complexes conjuguées d’une matrice réelle
se heurte à un problème de conditionnement parce que le choix d’un shift
intéressant pour la convergence va rendre la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> proche d’une matrice non
inversible (les deux derniers coefficients diagonaux de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> sont proches de 0).
On a alors seulement
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mover><mi>Q</mi><mo>&#x000AF;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>Q</mi><mi>R</mi><mo>=</mo><mover><mi>R</mi><mo>&#x000AF;</mo></mover></mrow><annotation encoding='application/x-tex'> \overline{Q}^{&#x2d;1} Q R = \overline{R}  </annotation></semantics></math>
Si on décompose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mover><mi>Q</mi><mo>&#x000AF;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>Q</mi></mrow><annotation encoding='application/x-tex'>\overline{Q}^{&#x2d;1} Q</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>R</mi><mo>&#x000AF;</mo></mover></mrow><annotation encoding='application/x-tex'>\overline{R}</annotation></semantics></math> par blocs 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;2,n&#x2d;2</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn><mo>,</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;2,2</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>2,n&#x2d;2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>2,2</annotation></semantics></math>, on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mi>Q</mi><msub><mi>Q</mi> <mn>11</mn></msub></mtd> <mtd><mi>Q</mi><msub><mi>Q</mi> <mn>12</mn></msub></mtd></mtr> <mtr><mtd><mi>Q</mi><msub><mi>Q</mi> <mn>21</mn></msub></mtd> <mtd><mi>Q</mi><msub><mi>Q</mi> <mn>22</mn></msub></mtd></mtr></mtable><mo>)</mo></mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><msub><mi>R</mi> <mn>11</mn></msub></mtd> <mtd><msub><mi>R</mi> <mn>12</mn></msub></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mi>R</mi> <mn>22</mn></msub></mtd></mtr></mtable><mo>)</mo></mrow></mtd> <mtd><mo>=</mo></mtd> <mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mi>Q</mi><msub><mi>Q</mi> <mn>11</mn></msub><msub><mi>R</mi> <mn>11</mn></msub></mtd> <mtd><mi>Q</mi><msub><mi>Q</mi> <mn>21</mn></msub><msub><mi>R</mi> <mn>11</mn></msub></mtd></mtr> <mtr><mtd><mi>Q</mi><msub><mi>Q</mi> <mn>11</mn></msub><msub><mi>R</mi> <mn>12</mn></msub><mo>+</mo><mi>Q</mi><msub><mi>Q</mi> <mn>12</mn></msub><msub><mi>R</mi> <mn>22</mn></msub></mtd> <mtd><mi>Q</mi><msub><mi>Q</mi> <mn>21</mn></msub><msub><mi>R</mi> <mn>12</mn></msub><mo>+</mo><mi>Q</mi><msub><mi>Q</mi> <mn>22</mn></msub><msub><mi>R</mi> <mn>22</mn></msub></mtd></mtr></mtable><mo>)</mo></mrow></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><msub><mover><mi>R</mi><mo>&#x000AF;</mo></mover> <mn>11</mn></msub></mtd> <mtd><msub><mover><mi>R</mi><mo>&#x000AF;</mo></mover> <mn>12</mn></msub></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><msub><mover><mi>R</mi><mo>&#x000AF;</mo></mover> <mn>22</mn></msub></mtd></mtr></mtable><mo>)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
\left(\begin{array}{cc}
QQ_{11} &amp; QQ_{12} \\
QQ_{21} &amp; QQ_{22} 
\end{array} \right)
\left(\begin{array}{cc}
R_{11} &amp; R_{12} \\
0 &amp; R_{22} 
\end{array} \right)
&amp;=&amp; \left(\begin{array}{cc}
QQ_{11} R_{11} &amp; QQ_{21}R_{11} \\
QQ_{11} R_{12} + QQ_{12} R_{22} &amp; QQ_{21} R_{12} + QQ_{22} R_{22} 
\end{array} \right)  \\
&amp;=&amp;
\left(\begin{array}{cc}
\overline{R}_{11} &amp; \overline{R}_{12} \\
0 &amp; \overline{R}_{22} 
\end{array} \right)
 \end{matrix} </annotation></semantics></math>
Donc on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><msub><mi>Q</mi> <mn>11</mn></msub><mo>=</mo><msub><mover><mi>R</mi><mo>&#x000AF;</mo></mover> <mn>11</mn></msub><msubsup><mi>R</mi> <mn>11</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding='application/x-tex'>QQ_{11} =\overline{R}_{11} R_{11}^{&#x2d;1}</annotation></semantics></math>.
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est unitaire, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>Q</mi><mo>=</mo><msup><mover><mi>Q</mi><mo>&#x000AF;</mo></mover> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>Q</mi><mo>=</mo><msup><mi>Q</mi> <mi>t</mi></msup><mspace width="thinmathspace"/><mi>Q</mi></mrow><annotation encoding='application/x-tex'>QQ=\overline{Q}^{&#x2d;1} Q=Q^t \, Q</annotation></semantics></math> est symétrique, donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><msub><mi>Q</mi> <mn>11</mn></msub></mrow><annotation encoding='application/x-tex'>QQ_{11}</annotation></semantics></math> est diagonale puisque symétrique et triangulaire supérieure. On peut donc
ramener <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>11</mn></msub></mrow><annotation encoding='application/x-tex'>Q_{11}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mn>11</mn></msub></mrow><annotation encoding='application/x-tex'>R_{11}</annotation></semantics></math> en des matrices réelles.
L’algorihtme des itérations <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mi>R</mi></mrow><annotation encoding='application/x-tex'>QR</annotation></semantics></math> implicites traite de manière
efficace le cas des
couples de valeurs propres complexes conjuguées ou plus
généralement de clusters de valeurs propres, c’est l’algorithme
de Francis (aussi appelé <em>bulge chasing</em> en anglais, qu’on
pourrait traduire par “à la poursuite du bourrelet”, cela vient
de la forme que prend la matrice après application d’un shift,
elle a des entrées non nulles en première colonne plus bas
que la sous-diagonale qui forment un bourrelet non nul, 
l’annulation de ces entrées par des transformations de Householder
déplace le bourrelet sur la colonne suivante).</p><p>Revenons à la localisation des valeurs propres 
On suppose qu’on a maintenant une matrice
unitaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et une matrice triangulaire supérieure <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math>
(aux erreurs d’arrondi près) telles que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>P</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>A</mi><mi>P</mi><mo>=</mo><mi>S</mi></mrow><annotation encoding='application/x-tex'> P^{&#x2d;1} A P = S  </annotation></semantics></math>
Que peut-on en déduire ?
<sup><a id="text38" href="#note38">2</a></sup>
On va d’abord arrondir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> en une matrice exacte à coefficients rationnels, dont les dénominateurs
sont une puissance de 2 (en fait c’est exactement ce que donne l’écriture d’un flottant
en base 2, une fois ramené tous les exposants à la même valeur). On a donc une matrice
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>P_e</annotation></semantics></math> presque unitaire exacte et telle que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>S</mi> <mi>e</mi></msub><mo>=</mo><msubsup><mi>P</mi> <mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msubsup><mi>A</mi><msub><mi>P</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'> S_e = P_e^{&#x2d;1} A P_e   </annotation></semantics></math>
est semblable à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, et presque triangulaire supérieure.
(comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>P_e</annotation></semantics></math> est presque unitaire, sa norme et la norme de son inverse
sont proches de 1 donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>S_e</annotation></semantics></math> est proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math>, les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>S_e</annotation></semantics></math>
sont de la même taille que les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> : le changement de base est bien
conditionné et c’est la raison pour laquelle on a choisi d’effectuer des 
transformations unitaires). </p><p>Notons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&mu;</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>&mu;</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>\mu_1, ..., \mu_n</annotation></semantics></math> les coefficients
diagonaux de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>S_e</annotation></semantics></math>, soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math> un majorant de la norme des coefficients
sous-diagonaux de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>S_e</annotation></semantics></math>, et soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\delta</annotation></semantics></math> un minorant de l’écart entre 2 <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&mu;</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\mu_j</annotation></semantics></math> distincts.
On a donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>e</mi></msub><mo>=</mo><mi>U</mi><mo>+</mo><mi>E</mi></mrow><annotation encoding='application/x-tex'>S_e=U+E</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> est triangulaire supérieure, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi></mrow><annotation encoding='application/x-tex'>E</annotation></semantics></math> est triangulaire inférieure
avec des 0 sous la diagonale et des coefficients de module majorés par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math>.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math> est suffisamment petit devant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\delta</annotation></semantics></math>, on va montrer qu’on peut
localiser les valeurs propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>S_e</annotation></semantics></math> (qui sont celles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>) au moyen des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&mu;</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\mu_j</annotation></semantics></math>.</p><p>En effet, fixons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> et soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> un cercle de centre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&mu;</mi><mo>=</mo><msub><mi>&mu;</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\mu=\mu_j</annotation></semantics></math> et de rayon 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>&leq;</mo><mi>&delta;</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\alpha \leq \delta/2</annotation></semantics></math>. 
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est une matrice diagonalisable, on sait que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtext>nombre de valeurs propres</mtext><mo>&Element;</mo><mi>C</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>i</mi><mi>&pi;</mi></mrow></mfrac><mtext>trace</mtext><msub><mo>&Integral;</mo> <mi>C</mi></msub><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> \mbox{nombre de valeurs propres} \in C =  \frac{1}{2i\pi}  \mbox{trace} \int_C (A&#x2d;zI)^{&#x2d;1}  </annotation></semantics></math>
En prenant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><msub><mi>S</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>A=S_e</annotation></semantics></math>, et en écrivant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>S</mi> <mi>e</mi></msub><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><mo>+</mo><mi>E</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mi>I</mi><mo>+</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>E</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> (S_e&#x2d;zI)^{&#x2d;1} = (U&#x2d;zI+E)^{&#x2d;1} = ( I + (U&#x2d;zI)^{&#x2d;1}E)^{&#x2d;1}(U&#x2d;zI)^{&#x2d;1}   </annotation></semantics></math>
on développe le second terme si la norme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>E</mi></mrow><annotation encoding='application/x-tex'>(U&#x2d;zI)^{&#x2d;1}E</annotation></semantics></math> est strictement inférieure à 1
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>S</mi> <mi>e</mi></msub><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>&minus;</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>E</mi><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>E</mi><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>E</mi><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'> (S_e&#x2d;zI)^{&#x2d;1} = (U&#x2d;zI)^{&#x2d;1} &#x2d;(U&#x2d;zI)^{&#x2d;1}E(U&#x2d;zI)^{&#x2d;1} + (U&#x2d;zI)^{&#x2d;1}E(U&#x2d;zI)^{&#x2d;1}E(U&#x2d;zI)^{&#x2d;1} + ... </annotation></semantics></math>
puis on calcule la trace
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtext>trace</mtext><mo stretchy="false">(</mo><msub><mi>S</mi> <mi>e</mi></msub><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>j</mi></munder><mo stretchy="false">(</mo><msub><mi>&mu;</mi> <mi>j</mi></msub><mo>&minus;</mo><mi>z</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>&eta;</mi></mrow><annotation encoding='application/x-tex'> \mbox{trace}(S_e&#x2d;zI)^{&#x2d;1} = \sum_j (\mu_j&#x2d;z)^{&#x2d;1} + \eta  </annotation></semantics></math>
avec
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>&eta;</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mn>2</mn><mi>&pi;</mi><mi>&alpha;</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>E</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow><mrow><mn>1</mn><mo>&minus;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>E</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> |\eta| \leq 2\pi \alpha || (U&#x2d;zI)^{&#x2d;1} || \frac{|| (U&#x2d;zI)^{&#x2d;1}E ||}{1&#x2d;|| (U&#x2d;zI)^{&#x2d;1}E ||} </annotation></semantics></math>
Au final, le nombre de valeurs propres dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> est donné par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>1</mn><mo>+</mo><mover><mi>&eta;</mi><mo stretchy="false">&tilde;</mo></mover><mo>,</mo><mspace width="1em"/><mo stretchy="false">&vert;</mo><mover><mi>&eta;</mi><mo stretchy="false">&tilde;</mo></mover><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&alpha;</mi><msub><mtext>max</mtext> <mrow><mi>z</mi><mo>&Element;</mo><mi>C</mi></mrow></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>E</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow><mrow><mn>1</mn><mo>&minus;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>U</mi><mo>&minus;</mo><mi>z</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>E</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> 1 + \tilde{\eta}, \quad |\tilde{\eta}| \leq 
\alpha \mbox{max}_{z \in C} || (U&#x2d;zI)^{&#x2d;1} || \frac{|| (U&#x2d;zI)^{&#x2d;1}E ||}{1&#x2d;|| (U&#x2d;zI)^{&#x2d;1}E ||}  </annotation></semantics></math>
Il suffit donc que le max soit plus petit que 1 pour avoir l’existence d’une valeur
propre et une seule de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>S_e</annotation></semantics></math> dans le cercle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> (à distance au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&mu;</mi></mrow><annotation encoding='application/x-tex'>\mu</annotation></semantics></math>).
Ce sera le cas si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&#x03B5;</mi><mo>&leq;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo>(</mo><mfrac><mi>&delta;</mi><mrow><mn>2</mn><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><msub><mi>S</mi> <mi>e</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo></mrow></mfrac><mo>)</mo></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mfrac><mi>&alpha;</mi><msqrt><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msqrt></mfrac></mrow><annotation encoding='application/x-tex'> \varepsilon \leq \frac{1}{2} \left( \frac{\delta}{2 ||S_e||} \right)^{n&#x2d;1} 
\frac{\alpha}{\sqrt{n&#x2d;1}} </annotation></semantics></math>
on choisit donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> pour réaliser l’égalité ci-dessus,
sous réserve que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\delta</annotation></semantics></math> ne soit pas trop petit, rappelons que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> doit être
plus petit ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\delta/2</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\delta</annotation></semantics></math> est petit, il peut être nécessaire
d’utiliser une précision plus grande pour les calculs de la décomposition de Schur
en arithmétique flottante.</p><p>Typiquement, on peut espérer (pour un écart <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\delta</annotation></semantics></math> pas trop petit) pouvoir
localiser les racines d’un polynôme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> par cette méthode avec précision
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> bits en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><msup><mi>b</mi> <mn>2</mn></msup><mo>+</mo><msup><mi>n</mi> <mn>2</mn></msup><msup><mi>b</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3 b^2 + n^2 b^3)</annotation></semantics></math> opérations pour le calcul de la décomposition
de Schur en flottant (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>3</mn></msup><msup><mi>b</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>n^3b^2</annotation></semantics></math> pour Hessenberg initial puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>2</mn></msup><msup><mi>b</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>n^2b^2</annotation></semantics></math> par itération
et un nombre d’itérations proportionnel à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>). 
Pour le calcul exact de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>e</mi></msub></mrow><annotation encoding='application/x-tex'>S_e</annotation></semantics></math>, il faut inverser une matrice
de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> avec des coefficients de taille proportionnelle à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>4</mn></msup><mi>b</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^4b\ln(n))</annotation></semantics></math>
opérations (en modulaire, la taille des coefficients de l’inverse est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>b</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(nb \ln(n))</annotation></semantics></math>)
puis calculer un produit avec une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>n,n</annotation></semantics></math> de coefficients de taille
proportionnelle à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>, soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>4</mn></msup><msup><mi>b</mi> <mn>2</mn></msup><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mi>b</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^4b^2\ln(nb))</annotation></semantics></math> opérations. Asymptotiquement,
on peut faire mieux avec des méthodes de multiplication et d’opérations matricielles
par blocs. Pour éviter la perte d’un facteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, 
on peut aussi ne pas faire de calculs en mode exact et controler
les erreurs sur la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math>.
On peut regrouper les valeurs propres par “clusters” si elles sont trop
proches à la précision de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> bits. Pour la recherche des racines
d’un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, on peut montrer, en calculant le résultant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math> qui est en module plus grand ou égal à 1, et en l’écrivant
comme produit des carrés de différences des racines, et en majorant toutes
les différences de racine sauf une à l’aide de la norme infinie
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, qu’il faut au pire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>b=O(n)</annotation></semantics></math> bits pour séparer les racines).</p>
<!--TOC section id="sec263" Quelques références-->
<h2 id="sec263" class="section">22.11  Quelques références</h2><!--SEC END --><p> <a id="sec:ref"></a></p><ul class="itemize"><li class="li-itemize">
Comme toujours on renvoie à l’excellent livre de Henri Cohen:
A Course in Computational Algebraic Number Theory</li><li class="li-itemize">Gantmacher: Théorie des matrices</li><li class="li-itemize">Press et al.: Numerical recipies in Fortran/C/Pascal.<br>
Pour des algorithmes numériques (sur les matrices et autres).</li></ul>
<!--TOC section id="sec264" Exercices (algèbre linéaire)-->
<h2 id="sec264" class="section">22.12  Exercices (algèbre linéaire)</h2><!--SEC END -->
<!--TOC subsection id="sec265" Instructions-->
<h3 id="sec265" class="subsection">22.12.1  Instructions</h3><!--SEC END --><ul class="itemize"><li class="li-itemize">
Les commandes d’algèbre linéaire de Xcas sont
regroupées dans le menu <span style="font-family:monospace">Cmds-&gt;Alglin</span>.
En maple V, la commande <span style="font-family:monospace">?linalg</span> affiche
la liste des commandes d’algèbre linéaire. 
</li><li class="li-itemize">En maple V il est conseillé d’exécuter <span style="font-family:monospace">with(linalg);</span>,
sinon il faut précéder
chaque commande de <span style="font-family:monospace">linalg::</span>.
Attention
il faut utiliser le caractère <span style="font-family:monospace">&amp;</span> avant la multiplication
et il faut souvent utiliser <span style="font-family:monospace">evalm</span> dans les programmes
utilisant des matrices et vecteurs. Notez aussi que les
matrices sont toujours passées par référence en maple V,
en Xcas le choix revient à l’utilisateur (affectation par <code>:=</code>
par valeur ou par <code>=&lt;</code> par référence)
</li><li class="li-itemize">Pour travailler avec des
coefficients modulaires, en Xcas
on fait suivre les coefficients ou matrices de <span style="font-family:monospace">% n</span>
(utiliser <code>% 0</code> pour enlever les modulos),
en maple V, on utilise les noms de commandes
avec une majuscule (forme inerte) suivi de <span style="font-family:monospace">mod n</span>.
</li></ul>
<!--TOC subsection id="sec266" Exercices-->
<h3 id="sec266" class="subsection">22.12.2  Exercices</h3><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
Écrire un programme calculant l’inverse d’une matrice
en utilisant sa décomposition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>. Tester avec une matrice
à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> puis dans un corps fini non premier.
Que se passe-t-il sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Q}</annotation></semantics></math> ?
</li><li class="li-enumerate">En utilisant un logiciel de calcul formel,
comparez le temps de calcul d’un déterminant de matrice
aléatoire de tailles 50, 100 et 200 à coefficients dans
un corps fini, puis dans les entiers. <br>
Même
question pour une matrice de taille 20, 40 et 80
dans des polynômes de degré 2
à 1 variables sur un corps fini premier.<br>
Même question pour 
une matrice de taille 6 et 12 avec comme coefficients symboliques
ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> colonne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>j</mi><mo>+</mo><mi>k</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>x_{j+k}</annotation></semantics></math> lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>j+k</annotation></semantics></math> est pair
et 0 sinon. Peut-on en déduire une indication sur l’algorithme
utilisé ?
</li><li class="li-enumerate">Écrire un programme calculant la borne de Hadamard d’un
déterminant à coefficients réels (rappel : c’est la borne obtenue en faisant
le produit des normes euclidiennes des vecteurs colonnes).<br>
Créez une matrice 4x4 aléatoire avec des coefficients entiers
compris entre -100 et 100, calculer la borne de Hadamard de son déterminant
avec le programme précédent, calculer ce déterminant modulo
quelques nombres premiers choisis en fonction de la borne de Hadamard
et vérifiez le résultat de la reconstruction modulaire du déterminant.
</li><li class="li-enumerate">Créez une matrice 100x100 aléatoire à coefficients entiers
et calculez son déterminant
modulo quelques nombres premiers. Dans quels cas peut-on
conclure que la matrice est inversible dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math>? dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>?
</li><li class="li-enumerate">Écrire un programme calculant par interpolation de Lagrange 
(<code>interp</code>)
le polynôme caractéristique d’une matrice (en donnant à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi></mrow><annotation encoding='application/x-tex'>\lambda</annotation></semantics></math>
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>det</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mi>I</mi><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\det(\lambda I &#x2d;A)</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> valeurs distinctes).
</li><li class="li-enumerate">Recherche du polynôme minimal (Krylov). On prend un vecteur aléatoire
à coefficients entiers et on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>v</mi></mrow><annotation encoding='application/x-tex'>Av</annotation></semantics></math>, ..., <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mi>n</mi></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>A^nv</annotation></semantics></math> puis
on cherche une relation linéaire minimale entre ces vecteurs, en
calculant le noyau de la matrice ayant ces vecteurs colonnes. Si le
noyau est de dimension 1, alors le polynôme minimal est égal au
polynome caractéristique et correspond à un vecteur de la base du noyau.
Sinon, il faut choisir un vecteur du noyau correspondant au degré
le plus petit possible puis faire le PPCM avec les polynomes obtenus
avec d’autres vecteurs pour obtenir le polynôme minimal avec une grande
probabilité.
Essayez avec la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> de taille 3 ayant des 0 sur la diagonale et 
des 1 ailleurs.
Écrire un programme mettant en oeuvre cette recherche, testez-le avec
une matrice aléatoire de taille 30.
</li><li class="li-enumerate">(Long) Écrire un programme qui calcule un déterminant de matrice
en calculant les mineurs 2x2 puis 3x3 etc. (méthode de Laplace)
</li><li class="li-enumerate">Testez l’algorithme méthode de Fadeev pour la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> ci-dessus.
Même question pour 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>3</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>2</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>,</mo><mspace width="1em"/><mi>A</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center"><mtr><mtd><mn>3</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> A=\left(\begin{array}{ccc}
 3 &amp; &#x2d;1 &amp; 1 \\
2 &amp;0 &amp;1 \\
1 &amp; &#x2d;1 &amp; 2 
\end{array}\right), \quad 
A=\left(\begin{array}{ccc}
 3 &amp; 2 &amp; &#x2d;2 \\
&#x2d;1 &amp;0 &amp;1 \\
1 &amp; 1 &amp; 0 
\end{array}\right) 
  </annotation></semantics></math>
</li><li class="li-enumerate">Écrire un programme calculant par une méthode itérative
la valeur propre de module maximal d’une matrice à coefficients
complexes. Dans le cas réel, modifier le programme pour pouvoir
traiter le cas d’un couple de complexes conjugués de module maximal.
Dans le cas hermitien ou réel symétrique, éliminer le couple valeur
propre/vecteur propre et continuer la diagonalisation numérique.
</li><li class="li-enumerate">Soient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>a</mi><mo stretchy="false">&vert;</mo><mo>,</mo><mo stretchy="false">&vert;</mo><mi>b</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><msqrt><mrow><mi>n</mi><mo stretchy="false">/</mo><mn>2</mn></mrow></msqrt></mrow><annotation encoding='application/x-tex'>|a|,|b|&amp;lt;\sqrt{n/2}</annotation></semantics></math>
Écrire une fonction ayant comme arguments <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">/</mo><mi>b</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a/b \pmod n</annotation></semantics></math> 
qui calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>.<br>
Utiliser ce programme pour résoudre un système 4,4 à coefficients entiers
par une méthode <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-adique.
</li></ol>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note37" href="#text37">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">On le montre en observant que les valeurs propres de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msup><mi>A</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>AA^*</annotation></semantics></math> sont identiques à celles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A^*A</annotation></semantics></math>, car si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> est
vecteur propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mo>*</mo></msup><mi>A</mi></mrow><annotation encoding='application/x-tex'>A^*A</annotation></semantics></math> alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>v</mi></mrow><annotation encoding='application/x-tex'>Av</annotation></semantics></math> est vecteur
propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><msup><mi>A</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>AA^*</annotation></semantics></math></div></dd><dt class="dt-thefootnotes"><a id="note38" href="#text38">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est la matrice companion
d’un polynôme, une autre approche 
consiste à rechercher un rectangle du plan complexe stable par itérée
de la méthode de Newton ou à calculer les disques
de centre les coefficients diagonaux et de rayon le
degré du polynôme divisé par un minorant de la
dérivée du polynôme par la valeur du polynôme</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec267" Approximation polynomiale-->
</html>
