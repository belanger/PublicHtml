<!DOCTYPE html>
<html >
<head>
<h1 id="sec290" class="chapter">Chapitre 25  La transformée de Fourier discrète.</h1><!--SEC END --><p>
<a id="sec:dft"></a>
<a id="hevea_default347"></a><a id="hevea_default348"></a><a id="hevea_default349"></a>
</p>
<!--TOC section id="sec291" Définition et propriétés-->
<h2 id="sec291" class="section">25.1  Définition et propriétés</h2><!--SEC END --><p>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> un entier fixé. Une suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> périodique de période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> est
déterminée par le vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>x</mi> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>x=[x_0,x_1,...x_{N&#x2d;1}]</annotation></semantics></math>.
La transformée de Fourier discréte (DFT) notée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>F</mi> <mi>N</mi></msub></mrow><annotation encoding='application/x-tex'>F_N</annotation></semantics></math> fait correspondre 
à une suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> périodique de période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> une autre suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>
périodique de période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>, définie pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k=0..N&#x2d;1</annotation></semantics></math> par :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mrow><mo stretchy="false">(</mo><msub><mi>F</mi> <mi>N</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow> <mi>k</mi></msub><mo>=</mo><msub><mi>y</mi> <mi>k</mi></msub><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>j</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mo>&sdot;</mo><mi>j</mi></mrow></msubsup><mo>,</mo></mrow><annotation encoding='application/x-tex'> 
{(F_N(x))}_k=y_k=\sum_{j=0}^{N&#x2d;1} x_j \omega_N^{&#x2d;k\cdot j},
 </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&omega;</mi> <mi>N</mi></msub></mrow><annotation encoding='application/x-tex'>\omega_N</annotation></semantics></math> est une racine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>-ième primitive de l’unité,
on prend <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&omega;</mi><mo>=</mo><msup><mi>e</mi> <mfrac><mrow><mn>2</mn><mi>i</mi><mi>&pi;</mi></mrow><mi>N</mi></mfrac></msup></mrow><annotation encoding='application/x-tex'>\omega=e^{\frac{2i\pi}{N}}</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est à coefficients réels
ou complexes.</p><p>On observe que si la suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est la suite des valeurs d’une fonction
périodique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> sur une discrétisation de la période, alors
la transformée de Fourier discrète est la suite des valeurs approchées
des coefficients de Fourier obtenus en appliquant la méthode des
trapèzes sur cette discrétisation.</p><p>Cette transformation est linéaire, la transformée de la somme de 2
suites est la somme des transformées, et la transformée du produit
par une constante d’une suite 
est le produit par cette constante de la transformée
de la suite.</p><p>La transformée de Fourier discréte <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>F</mi> <mi>N</mi></msub></mrow><annotation encoding='application/x-tex'>F_N</annotation></semantics></math> est une transformation 
bijective dont la réciproque est donnée par :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mi>F</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mover><mrow><msub><mi>F</mi> <mi>N</mi></msub></mrow><mo>&#x000AF;</mo></mover><mo>,</mo><mspace width="1em"/><msub><mrow><mo stretchy="false">(</mo><msubsup><mi>F</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow> <mi>k</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>y</mi> <mi>j</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mi>k</mi><mo>&sdot;</mo><mi>j</mi></mrow></msubsup></mrow><annotation encoding='application/x-tex'> F_N^{&#x2d;1}=\frac{1}{N} \overline{F_N}, \quad
{(F_N^{&#x2d;1}(y))}_k=\frac{1}{N}\sum_{j=0}^{N&#x2d;1}y_j\omega_N^{k\cdot j}
 </annotation></semantics></math>
On le prouve en remplaçant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> par sa valeur :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mrow><mo stretchy="false">(</mo><msubsup><mi>F</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow> <mi>k</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>l</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>j</mi><mo>&sdot;</mo><mi>l</mi></mrow></msubsup><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mi>k</mi><mo>&sdot;</mo><mi>j</mi></mrow></msubsup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>l</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mi>j</mi><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>l</mi></msub><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mo stretchy="false">)</mo> <mi>j</mi></msup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>l</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>l</mi></msub><mrow><mo>{</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left center left"><mtr><mtd><mfrac><mrow><mn>1</mn><mo>&minus;</mo><mo stretchy="false">(</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><msup><mo stretchy="false">)</mo> <mi>N</mi></msup></mrow><mrow><mn>1</mn><mo>&minus;</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></mfrac></mtd> <mtd><mtext>si</mtext></mtd> <mtd><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>&ne;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mi>N</mi></mtd> <mtd><mtext>si</mtext></mtd> <mtd><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mn>1</mn></mtd></mtr></mtable></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
{(F_N^{&#x2d;1}(y))}_k &amp;=&amp;
\frac{1}{N}\sum_{j=0}^{N&#x2d;1} \sum_{l=0}^{N&#x2d;1} x_l \omega_N^{&#x2d;j\cdot l}
\omega_N^{k\cdot j} \\
&amp;=&amp;
\frac{1}{N}\sum_{j=0}^{N&#x2d;1} \sum_{l=0}^{N&#x2d;1} x_l \omega_N^{j (k&#x2d;l)} \\
&amp;=&amp; 
\frac{1}{N} \sum_{l=0}^{N&#x2d;1} x_l \sum_{j=0}^{N&#x2d;1} (\omega_N^{(k&#x2d;l)})^j \\
&amp;=&amp;
\frac{1}{N} \sum_{l=0}^{N&#x2d;1} x_l 
\left\{ \begin{array}{lcl}
\frac{1&#x2d;(\omega_N^{(k&#x2d;l)})^N}{1&#x2d;\omega_N^{(k&#x2d;l)}} &amp; \mbox{si} &amp;
\omega_N^{(k&#x2d;l)}\neq 1 \\
N &amp; \mbox{si} &amp; \omega_N^{(k&#x2d;l)} = 1 
\end{array} \right.
 \end{matrix} </annotation></semantics></math>
Or si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mi>k</mi><mo>&minus;</mo><mi>l</mi></mrow></msubsup><mo>=</mo><msup><mi>e</mi> <mrow><mn>2</mn><mi>i</mi><mi>&pi;</mi><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>l</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>N</mi></mrow></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\omega_N^{k&#x2d;l}=e^{2i\pi(k&#x2d;l)/N}=1</annotation></semantics></math> si et seulement si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'>k=l</annotation></semantics></math>
d’où le résultat.</p><p><span style="font-weight:bold">Remarque</span> : dans le cas complexe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&omega;</mi><mo>=</mo><msup><mi>e</mi> <mrow><mn>2</mn><mi>i</mi><mi>&pi;</mi><mo stretchy="false">/</mo><mi>N</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>\omega=e^{2i\pi/N}</annotation></semantics></math>, 
on peut interpréter la DFT
en termes du produit scalaire hermitien
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mi>x</mi><mo stretchy="false">&vert;</mo><mi>y</mi><mi>&gt;</mi><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mover><mi>x</mi><mo>&#x000AF;</mo></mover> <mi>j</mi></msub><msub><mi>y</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>&amp;lt;x|y&amp;gt;=\sum_{j=0}^{N&#x2d;1} \overline{x}_j y_j </annotation></semantics></math>
sur l’espace <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Copf;</mi> <mi>N</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{C}^N</annotation></semantics></math>, on a une base orthogonale donnée par 
les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">{</mo><msub><mi>W</mi> <mi>k</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msup><mi>&omega;</mi> <mrow><mi>j</mi><mi>k</mi></mrow></msup><msub><mo stretchy="false">)</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>k</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>\{ W_k=(\omega^{jk})_{j=0..N&#x2d;1}, k=0..N&#x2d;1\}</annotation></semantics></math>, la DFT d’une suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est le calcul
des produits scalaires <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><msub><mi>W</mi> <mi>k</mi></msub><mo stretchy="false">&vert;</mo><mi>x</mi><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;W_k|x&amp;gt;</annotation></semantics></math>, et la récriproque est l’écriture
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> dans cette base orthogonale.</p><p><span style="font-weight:bold">Propriété</span><br>
La transformée de Fourier discrète d’une suite réelle vérifie
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mrow><mi>N</mi><mo>&minus;</mo><mi>k</mi></mrow></msub><mo>=</mo><mover><mrow><msub><mi>y</mi> <mi>k</mi></msub></mrow><mo>&#x000AF;</mo></mover></mrow><annotation encoding='application/x-tex'>y_{N&#x2d;k}=\overline{y_k}</annotation></semantics></math>.<br>
La preuve est immédiate en appliquant la définition.</p><p>Un des intérêts de la DFT est de mettre en évidence rapidement
d’éventuelles périodicités de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> divisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>. Plus précisément
soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> est un entier divisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>. Considérons une suite réelle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> dont
la DFT <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> est nulle sauf <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>l</mi></msub></mrow><annotation encoding='application/x-tex'>y_l</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mrow><mi>N</mi><mo>&minus;</mo><mi>l</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>y_{N&#x2d;l}</annotation></semantics></math>. Par linéarité, on
peut se ramener à 2 cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>l</mi></msub><mo>=</mo><msub><mi>y</mi> <mrow><mi>N</mi><mo>&minus;</mo><mi>l</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>y_l=y_{N&#x2d;l}=1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>l</mi></msub><mo>=</mo><mi>i</mi><mo>,</mo><msub><mi>y</mi> <mrow><mi>N</mi><mo>&minus;</mo><mi>l</mi></mrow></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>i</mi></mrow><annotation encoding='application/x-tex'>y_l=i, y_{N&#x2d;l}=&#x2d;i</annotation></semantics></math>. Dans
le premier cas, on obtient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub><mo>=</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mi>l</mi><mi>k</mi></mrow></msubsup><mo>+</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>l</mi><mi>k</mi></mrow></msubsup><mo>=</mo><mn>2</mn><mi>cos</mi><mo stretchy="false">(</mo><mn>2</mn><mi>&pi;</mi><mi>k</mi><mi>l</mi><mo stretchy="false">/</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x_k=\omega_N^{lk}+\omega_N^{&#x2d;lk}=2\cos(2\pi kl/N)</annotation></semantics></math>,
dans le deuxième cas, on obtient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mi>sin</mi><mo stretchy="false">(</mo><mn>2</mn><mi>&pi;</mi><mi>k</mi><mi>l</mi><mo stretchy="false">/</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x_k=&#x2d;2\sin(2\pi kl/N)</annotation></semantics></math>, qui sont périodiques
de période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo stretchy="false">/</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'>N/l</annotation></semantics></math>.</p><p>Réciproquement, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> a comme période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo>=</mo><mi>N</mi><mo stretchy="false">/</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'>T=N/l</annotation></semantics></math>, alors en posant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>=</mo><mi>T</mi><mi>m</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding='application/x-tex'>j=T m + r</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>l</mi><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>m\in[0,l[</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>T</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>r\in[0,T&#x2d;1]</annotation></semantics></math>, on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>x</mi> <mi>r</mi></msub></mrow><annotation encoding='application/x-tex'>x_j=x_r</annotation></semantics></math> donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>y</mi> <mi>k</mi></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>j</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mo>&sdot;</mo><mi>j</mi></mrow></msubsup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>r</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>T</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>r</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mo stretchy="false">(</mo><mi>T</mi><mi>m</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></msubsup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>r</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>T</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>r</mi></msub><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mo stretchy="false">(</mo><mi>T</mi><mi>m</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></msubsup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>r</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>T</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>r</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>r</mi></mrow></msubsup><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>l</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>T</mi></mrow></msubsup><msup><mo stretchy="false">)</mo> <mi>m</mi></msup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>r</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>T</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>r</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>r</mi></mrow></msubsup><mfrac><mrow><mn>1</mn><mo>&minus;</mo><mo stretchy="false">(</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>T</mi></mrow></msubsup><msup><mo stretchy="false">)</mo> <mi>l</mi></msup></mrow><mrow><mn>1</mn><mo>&minus;</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>T</mi></mrow></msubsup></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 y_k &amp;=&amp;\sum_{j=0}^{N&#x2d;1} x_j \omega_N^{&#x2d;k\cdot j} \\
&amp;=&amp;\sum_{m=0}^{l&#x2d;1} \sum_{r=0}^{T&#x2d;1} x_r \omega_N^{&#x2d;k (T m+r)} \\
&amp;=&amp;\sum_{r=0}^{T&#x2d;1} x_r \sum_{m=0}^{l&#x2d;1} \omega_N^{&#x2d;k (T m+r)} \\
&amp;=&amp; \sum_{r=0}^{T&#x2d;1} x_r \omega_N^{&#x2d;kr} \sum_{m=0}^{l&#x2d;1}
(\omega_N^{&#x2d;kT})^m \\
&amp;=&amp; \sum_{r=0}^{T&#x2d;1} x_r \omega_N^{&#x2d;kr} 
\frac{1&#x2d;(\omega_N^{&#x2d;kT})^l}{1&#x2d;\omega_N^{&#x2d;kT}}
 \end{matrix} </annotation></semantics></math>
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>T</mi></mrow></msubsup><mo>&ne;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\omega_N^{&#x2d;kT} \neq 1</annotation></semantics></math>. Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>T</mi></mrow></msubsup><msup><mo stretchy="false">)</mo> <mi>l</mi></msup><mo>=</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>l</mi><mi>T</mi></mrow></msubsup><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>(\omega_N^{&#x2d;kT})^l=\omega_N^{&#x2d;klT}=1</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>k</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y_k=0</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>T</mi><mo>=</mo><mi>k</mi><mi>N</mi><mo stretchy="false">/</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'>kT=kN/l</annotation></semantics></math> n’est pas un multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>. 
Finalement si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> n’est pas un multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>k</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y_k=0</annotation></semantics></math>.</p><p>Voyons maintenant le cas de “pseudo-périodes”, supposons donc
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est périodique de période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> mais que de plus pour un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>T&amp;gt;0</annotation></semantics></math> 
quelconque (ne divisant pas forcément <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>), on ait
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>x</mi> <mrow><mi>j</mi><mo>+</mo><mi>T</mi></mrow></msub><mo>=</mo><msub><mi>x</mi> <mi>j</mi></msub><mo>,</mo><mspace width="1em"/><mo>&forall;</mo><mi>j</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>N</mi><mo>&minus;</mo><mi>T</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'> x_{j+T}=x_j, \quad \forall j \in[0,N&#x2d;T]  </annotation></semantics></math>
On peut refaire le raisonnement ci-dessus, modulo des erreurs.
plus précisément :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>y</mi> <mi>k</mi></msub><mo>&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mi>N</mi></mrow> <mrow><mtext>ceil</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">/</mo><mi>T</mi><mo stretchy="false">)</mo><mi>T</mi></mrow></munderover><msub><mi>x</mi> <mi>j</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mo>&sdot;</mo><mi>j</mi></mrow></msubsup><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mtext>ceil</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">/</mo><mi>T</mi><mo stretchy="false">)</mo></mrow></munderover><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>r</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>T</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>r</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mo stretchy="false">(</mo><mi>T</mi><mi>m</mi><mo>+</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding='application/x-tex'> y_k &#x2d; \sum_{j=N}^{\mbox{ceil}(N/T)T}x_j \omega_N^{&#x2d;k\cdot j} 
= \sum_{m=0}^{\mbox{ceil}(N/T)} \sum_{r=0}^{T&#x2d;1} x_r \omega_N^{&#x2d;k (T m+r)}  </annotation></semantics></math>
On calcule donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>y_k</annotation></semantics></math> à une erreur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>ceil</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">/</mo><mi>T</mi><mo stretchy="false">)</mo><mi>T</mi><mo>&minus;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>\mbox{ceil}(N/T)T&#x2d;N</annotation></semantics></math> termes majorés
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x_j|</annotation></semantics></math> près.
Et le membre de droite vaudra :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>r</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>T</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>r</mi></msub><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>r</mi></mrow></msubsup><mfrac><mrow><mn>1</mn><mo>&minus;</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mtext>ceil</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">/</mo><mi>T</mi><mo stretchy="false">)</mo><mi>T</mi></mrow></msubsup></mrow><mrow><mn>1</mn><mo>&minus;</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>k</mi><mi>T</mi></mrow></msubsup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \sum_{r=0}^{T&#x2d;1} x_r \omega_N^{&#x2d;kr} 
\frac{1&#x2d;\omega_N^{&#x2d;k\mbox{ceil}(N/T) T}}{1&#x2d;\omega_N^{&#x2d;kT}}
 </annotation></semantics></math>
Le module de la fraction est égal à
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mfrac><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mi>k</mi><mtext>ceil</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">/</mo><mi>T</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">/</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mi>k</mi><mi>T</mi><mo stretchy="false">/</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><mfrac><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mi>k</mi><mo stretchy="false">(</mo><mtext>ceil</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">/</mo><mi>T</mi><mo stretchy="false">)</mo><mi>T</mi><mo stretchy="false">/</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>&pi;</mi><mi>k</mi><mi>T</mi><mo stretchy="false">/</mo><mi>N</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |\frac{\sin(\pi k \mbox{ceil}(N/T) T/N)}{\sin(\pi k T/N)} |
= |\frac{\sin(\pi k (\mbox{ceil}(N/T) T/N&#x2d;1))}{\sin(\pi k T/N)} |
 </annotation></semantics></math>
il est petit si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> n’est pas proche d’un multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>ceil</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">/</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mbox{ceil}(N/T)</annotation></semantics></math>.
Par exemple, prenons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn> <mn>16</mn></msup><mo>=</mo><mn>65536</mn></mrow><annotation encoding='application/x-tex'>N=2^16=65536</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo>&approx;</mo><mi>N</mi><mo stretchy="false">/</mo><mn>10</mn><mo>=</mo><mn>6554</mn></mrow><annotation encoding='application/x-tex'>T \approx N/10 =6554</annotation></semantics></math>. Dans
ce cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mtext>ceil</mtext><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">/</mo><mi>T</mi><mo stretchy="false">)</mo><mi>T</mi><mo>=</mo><mn>10</mn><mo>&times;</mo><mn>6554</mn><mo>=</mo><mn>65540</mn></mrow><annotation encoding='application/x-tex'>\mbox{ceil}(N/T)T=10 \times 6554=65540</annotation></semantics></math>, il y a donc une erreur
de 4 termes sur le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>y_k</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> n’est pas proche d’un multiple
de 10, on doit trouver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>y_k</annotation></semantics></math> proche de 0 relativement à la valeur des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x_j|</annotation></semantics></math>.</p><p>Les périodes et pseudo-périodes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> correspondent donc aux
valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>y_k</annotation></semantics></math> grandes par la règle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> * période =<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>.</p>
<!--TOC section id="sec292" La transformée de Fourier rapide-->
<h2 id="sec292" class="section">25.2  La transformée de Fourier rapide</h2><!--SEC END --><p><a id="hevea_default350"></a>
<a id="hevea_default351"></a><a id="hevea_default352"></a>
Le calcul de la DFT est relativement lent, il nécessite de l’ordre
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>N</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>N^2</annotation></semantics></math> opérations, car il revient à calculer la valeur du polynôme
de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>N&#x2d;1</annotation></semantics></math>:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>x</mi> <mi>j</mi></msub><msup><mi>X</mi> <mi>j</mi></msup></mrow><annotation encoding='application/x-tex'> P(X)=\sum_{j=0}^{N&#x2d;1} x_j X^j  </annotation></semantics></math>
aux <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn></mrow><annotation encoding='application/x-tex'>1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&omega;</mi> <mi>N</mi></msub></mrow><annotation encoding='application/x-tex'>\omega_N</annotation></semantics></math>, ..., <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>&omega;</mi> <mi>N</mi> <mrow><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding='application/x-tex'>\omega_N^{N&#x2d;1}</annotation></semantics></math> 
(on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>k</mi></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msubsup><mi>&omega;</mi> <mi>N</mi> <mi>k</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y_k=P(\omega_N^k)</annotation></semantics></math>).
Mais si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> est une puissance de 2, on peut calculer de manière plus
astucieuse et réduire le nombre d’opérations à un ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T(N)=O(N \ln(N))</annotation></semantics></math>.
En effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>=</mo><mn>2</mn><mi>M</mi></mrow><annotation encoding='application/x-tex'>N=2M</annotation></semantics></math>,
on prend les
puissances paires et impaires de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Q</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><mo>+</mo><mi>x</mi><mi>R</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(x)=Q(x^2)+xR(x^2) </annotation></semantics></math>
On a alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msup><mi>&omega;</mi> <mi>k</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>Q</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>&omega;</mi> <mn>2</mn></msup><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mo stretchy="false">)</mo><mo>+</mo><msup><mi>&omega;</mi> <mi>k</mi></msup><mi>R</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>&omega;</mi> <mn>2</mn></msup><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(\omega^k)=Q( (\omega^2)^k)+\omega^k R((\omega^2)^k) </annotation></semantics></math>
On calcule les DFT de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math>, puis pour chaque valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> on a
1 multiplication et 1 addition donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>4</mn><mi>M</mi></mrow><annotation encoding='application/x-tex'>4M</annotation></semantics></math> opérations plus le calcul
de deux DFT d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> (on peut économiser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> multiplications
en utilisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&omega;</mi> <mrow><mi>k</mi><mo>+</mo><mi>M</mi></mrow></msup><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>&omega;</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>\omega^{k+M} =&#x2d;\omega^k</annotation></semantics></math>). On a donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mn>2</mn><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mi>M</mi><mo>+</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T(2M)=cM+2T(M)</annotation></semantics></math>
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>c=4</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>c=3</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>N=2^n</annotation></semantics></math> on a 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msup><mn>2</mn> <mi>n</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><msup><mn>2</mn> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><msup><mn>2</mn> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><msup><mn>2</mn> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mi>c</mi><msup><mn>2</mn> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>2</mn><mi>T</mi><mo stretchy="false">(</mo><msup><mn>2</mn> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>=</mo><mi>n</mi><mi>c</mi><msup><mn>2</mn> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><msup><mn>2</mn> <mi>n</mi></msup><mi>T</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T(2^n)=c2^{n&#x2d;1}+2T(2^{n&#x2d;1})
= c2^{n&#x2d;1}+2(c2^{n&#x2d;2}+2T(2^{n&#x2d;2})
=...=nc2^{n&#x2d;1}+2^nT(0) </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msup><mn>2</mn> <mi>n</mi></msup><mo stretchy="false">)</mo><mo>&approx;</mo><mi>c</mi><mi>n</mi><msup><mn>2</mn> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>T(2^n) \approx cn2^{n&#x2d;1}</annotation></semantics></math> opérations, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(N\ln(N))</annotation></semantics></math>
opérations.</p><p>Une méthode alternative consiste à 
découper <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> en 2 parties de même longueur :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mi>M</mi></msup><mi>Q</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>R</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> P(x)=x^M Q(X) + R(X)  </annotation></semantics></math>
on a alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>P</mi><mo stretchy="false">(</mo><msup><mi>&omega;</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo><mo stretchy="false">(</mo><mi>Q</mi><mo>+</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>&omega;</mi> <mn>2</mn></msup><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mo stretchy="false">)</mo><mo>,</mo></mtd></mtr> <mtr><mtd><mi>P</mi><mo stretchy="false">(</mo><msup><mi>&omega;</mi> <mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>Q</mi><mo>+</mo><mi>R</mi><msub><mo stretchy="false">)</mo> <mi>&omega;</mi></msub><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>&omega;</mi> <mn>2</mn></msup><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mo stretchy="false">)</mo><mspace width="1em"/></mtd> <mtd><mtext> o\`u </mtext><msub><mi>S</mi> <mi>&omega;</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo><msub><mi>s</mi> <mi>k</mi></msub><msup><mi>&omega;</mi> <mi>k</mi></msup><msup><mi>x</mi> <mi>k</mi></msup></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
P(\omega^{2k}) &amp;= (Q+R) ((\omega^2)^{k}), \\
P(\omega^{2k+1}) &amp;= (&#x2d;Q +R)_\omega ((\omega^2)^k) \quad
&amp;\mbox{ o\`u }  S_\omega(x)=\sum s_k \omega^k x^k
 \end{matrix} </annotation></semantics></math>
On est donc ramené à deux additions de 2 polynômes de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>,
une multiplication coefficient par puissances sur un polynôme de
degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> (soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>3</mn><mi>M</mi></mrow><annotation encoding='application/x-tex'>3M</annotation></semantics></math> opérations),
et au calcul des deux DFT de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>+</mo><mi>R</mi></mrow><annotation encoding='application/x-tex'>Q+R</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo>&minus;</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>R&#x2d;Q</annotation></semantics></math>. 
Lorsqu’on implémente cette méthode de manière efficace, 
on calcule le résultat de la DFT en place (en écrasant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par sa DFT)
il faut utiliser un espace mémoire
de travail de même longueur que le polynme de départ, on en
utilise la première partie pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>+</mo><mi>R</mi></mrow><annotation encoding='application/x-tex'>Q+R</annotation></semantics></math> et la seconde partie
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo>&minus;</mo><mi>Q</mi><msub><mo stretchy="false">)</mo> <mi>&omega;</mi></msub></mrow><annotation encoding='application/x-tex'>(R&#x2d;Q)_\omega</annotation></semantics></math>. On calcule les deux DFT en utilisant comme
espaces mémoire de travail la zone qui contient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> (qui sera donc
perdu), puis on effectue les permutations donnant la DFT de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
à partir de celles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> en écrasant la zone qui contenait <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.</p><p>On appelle alors FFT cette méthode de calcul (DFT=FFT si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>N=2^n</annotation></semantics></math>).</p><p>Cette méthode se généralise à des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> qui ne sont pas des puissances
de 2.</p>
<!--TOC section id="sec293" Applications.-->
<h2 id="sec293" class="section">25.3  Applications.</h2><!--SEC END --><p>
La DFT peut servir à trouver des périodes dans des données
expérimentales datées. On peut par exemple le voir sur
des enregistrements de son (par exemple avec le logiciel
libre <code>audacity</code>), mais dans bien d’autres
domaines, par exemple si on l’applique aux données
issues des paléoclimats, on voit apparaitre les périodicités
des paramètres orbitaux de la Terre, en phase avec la théorie
de Milankovitch.</p><p>En calcul exact, la FFT permet d’obtenir une complexité optimale
pour calculer des produits de grands entiers ou de polynômes
en une variable. La session <code>multfft</code>du menu 
<code>Aide, Exemples, arit</code> de Xcas implémente le principe
du calcul du produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> à coefficients entiers
en utilisant un seul nombre premier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> tel que 
</p><ul class="itemize"><li class="li-itemize">
1 admette
une racine primitive <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>2^n</annotation></semantics></math>-ième de l’unité modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> 
pour un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> assez grand (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>2^n</annotation></semantics></math> strictement plus grand que le degré
du produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>) 
</li><li class="li-itemize">tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mi>&gt;</mi><mn>2</mn><mo stretchy="false">&vert;</mo><mi>P</mi><msub><mo stretchy="false">&vert;</mo> <mn>&infin;</mn></msub></mrow><annotation encoding='application/x-tex'>p&amp;gt;2|P|_\infty</annotation></semantics></math> pour déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à partir de son
écriture en représentation symétrique.
</li></ul><p>
On écrit les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> dans un vecteur de longueur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>2^n</annotation></semantics></math> en complétant par des 0, on calcule la DFT de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>,
puis on fait le produit élément par élément puis on calcule la
DFT inverse.</p><p>Exemple : on cherche des nombres premiers de la forme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>=</mo><mi>k</mi><msup><mn>2</mn> <mi>n</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p=k2^n+1</annotation></semantics></math>
par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>=</mo><mn>7</mn><mo>&times;</mo><msup><mn>2</mn> <mn>20</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p=7\times 2^{20}+1</annotation></semantics></math> est premier, 

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">isprime(p:=7*2^20+1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

on cherche un générateur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>

</p><pre class="verbatim">for(g:=2;g&lt;p;g++){ 
  if (powmod(g,(p-1)/2,p)!=1 and powmod(g,(p-1)/7,p)!=1) break;
}:; g;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


on en déduit une racine primitive <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>20</mn></msup></mrow><annotation encoding='application/x-tex'>2^{20}</annotation></semantics></math>-ième de l’unité

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">g;r:=powmod(g,7,p);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

puis en prenant la puissance <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{n&#x2d;k}</annotation></semantics></math>-ième de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> on obtient une
racine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>2^k</annotation></semantics></math>-ième de 1 qui permettra de multiplier deux
polynômes dont la somme des degrés est strictement 
inférieure à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>2^k</annotation></semantics></math>, par exemple pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> de
degrés 5 et 7, on prendra <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>k=4</annotation></semantics></math>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a:=randpoly(5,[]); b:=randpoly(7,[]);w:=powmod(r,2^16,p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

on allonge <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> avec des 0 pour les amener à la taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>16</mn><mo>=</mo><msup><mn>2</mn> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>16=2^k</annotation></semantics></math>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">ar:=[op(a),op(seq(0,(16-size(a))))];br:=[op(b),op(seq(0,(16-size(b))))] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

on calcule les transformées de Fourier rapide de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">A:=fft(ar,w,p); B:=fft(br,w,p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

puis on fait le produit terme à terme et on applique la transformée
de Fourier inverse
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">C:=irem(A.*B,p); c:=ifft(C,w,p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

On peut comparer avec le produit calculé par Xcas
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a*b; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">smod(c,p); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

Bien entendu les tailles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> prises ici
en exemple sont trop petites
pour que l’algorithme soit efficace.</p><p>Pour une implémentation efficace, on utilise plusieurs nombres
premiers et les restes chinois (en fait à deux reprises). 
On calcule le produit des polynômes
modulo plusieurs nombres premiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>p_i</annotation></semantics></math>, dont le produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>\prod
p_i</annotation></semantics></math> est supérieur à deux fois la norme infinie de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> pour
pouvoir en déduire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.
Pour calculer un des produits <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>B</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msub><mi>p</mi> <mi>i</mi></msub></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>AB \pmod {p_i}</annotation></semantics></math>, on réduit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>p_i</annotation></semantics></math>,
on multiplie les polynômes réduits <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>A</mi><mo>&#x000AF;</mo></mover><mover><mi>B</mi><mo>&#x000AF;</mo></mover></mrow><annotation encoding='application/x-tex'>\overline{A} \overline{B}</annotation></semantics></math> 
comme s’ils étaient à coefficients
entiers et on r’eduit le résultat modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>p_i</annotation></semantics></math>. 
Le calcul de chaque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>A</mi><mo>&#x000AF;</mo></mover><mover><mi>B</mi><mo>&#x000AF;</mo></mover></mrow><annotation encoding='application/x-tex'>\overline{A}\overline{B}</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>p_i</annotation></semantics></math> fixé) se fait en utilisant 2 ou 3
premiers choisis une fois pour toutes qui sont proches de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>31</mn></msup></mrow><annotation encoding='application/x-tex'>2^{31}</annotation></semantics></math>
et ont des racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>2^n</annotation></semantics></math>-ième de l’unité pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> assez proche de 31.
Ainsi, Law et Monagan, proposent 
dans“A parallel implementation for polynomial multiplication
modulo a prime”, PASCO 2015,
</p><ul class="itemize"><li class="li-itemize">
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>1</mn></msub><mo>=</mo><mn>2013265921</mn><mo>=</mo><mn>15</mn><mo>&times;</mo><msup><mn>2</mn> <mn>27</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n_1 = 2013265921 =15 \times 2^{27}+1</annotation></semantics></math> 
(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mn>1227303670</mn></mrow><annotation encoding='application/x-tex'>r=1227303670</annotation></semantics></math> est racine d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>27</mn></msup></mrow><annotation encoding='application/x-tex'>2^{27}</annotation></semantics></math>, il suffit de prendre 
un générateur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><msub><mi>n</mi> <mn>1</mn></msub><mi>&Zopf;</mi><msup><mo stretchy="false">)</mo> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>(\mathbb{Z}/n_1\mathbb{Z})^*</annotation></semantics></math> à la puissance 15, ce qui
se fait en testant 2, 3,...).
</li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>2</mn></msub><mo>=</mo><mn>1811939329</mn><mo>=</mo><mn>27</mn><mo>&times;</mo><msup><mn>2</mn> <mn>26</mn></msup></mrow><annotation encoding='application/x-tex'>n_2 = 1811939329 =27 \times 2^{26}</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mn>814458146</mn></mrow><annotation encoding='application/x-tex'>r=814458146</annotation></semantics></math> est racine d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>26</mn></msup></mrow><annotation encoding='application/x-tex'>2^{26}</annotation></semantics></math>) 
</li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>3</mn></msub><mo>=</mo><mn>469762049</mn></mrow><annotation encoding='application/x-tex'>n_3 = 469762049 </annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mn>2187</mn></mrow><annotation encoding='application/x-tex'>r=2187</annotation></semantics></math> est racine d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>26</mn></msup></mrow><annotation encoding='application/x-tex'>2^{26}</annotation></semantics></math>)
</li></ul><p>
On peut retrouver ces nombres premiers avec une boucle comme suit

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">p:=2^25; for k from 64 downto 1 do if isprime(k*p+1) then print(k,k*p+1); fi od
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

et la valeur d’une racine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>2^n</annotation></semantics></math>-ième comme suit

</p><pre class="verbatim">n:=2013265921;
pour k de 2 jusque 100 faire
 a:=powmod(k,(n-1)/3,n); b:=powmod(k,(n-1)/5,n); c:=powmod(k,(n-1)/2,n);
 print(k,a,b,c);
 si a!=1 et b!=1 et c!=1 alors break; fsi;
fpour;
r:=powmod(k,15,n);
powmod(r,2^26,n); powmod(r,2^27,n);
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


Ce choix de valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>n</mi> <mn>2</mn></msub><mo>,</mo><msub><mi>n</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>n_1, n_2, n_3</annotation></semantics></math> 
permet de multiplier des polynômes dont le degré du produit
est strictement inférieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>26</mn></msup></mrow><annotation encoding='application/x-tex'>2^{26}</annotation></semantics></math> (environ 67 millions). 
Si on utilise deux de ces 3
premiers, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>n_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>n_2</annotation></semantics></math>, on peut prendre des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>p_i</annotation></semantics></math> dont la taille en bits est
plus petite que (60 bits moins le nombre de bits du degré minimal de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>) divisé par 2. Avec les trois <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>n_1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>n_2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>3</mn></msub></mrow><annotation encoding='application/x-tex'>n_3</annotation></semantics></math> on peut prendre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>p_i</annotation></semantics></math> ayant 31 bits, mais il faut travailler si on veut éviter
de faire des restes chinois avec des
entiers de plus de 64 bits (ce qui est possible avec des entiers 128
bits mais au prix de réductions modulo couteuses).</p>
<!--TOC chapter id="sec294" Le rayonnement solaire.-->
</html>
