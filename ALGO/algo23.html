<!DOCTYPE html>
<html >
<head>
<h1 id="sec267" class="chapter">Chapitre 23  Approximation polynomiale</h1><!--SEC END --><p> <a id="sec:interp"></a>
On présente dans cette section quelques méthodes d’approximation
de fonctions par des polynômes sur un intervalle, la section suivante 
présente des méthodes d’approximation près d’un point ou de l’infini.</p>
<!--TOC section id="sec268" Polynôme de Lagrange-->
<h2 id="sec268" class="section">23.1  Polynôme de Lagrange</h2><!--SEC END --><p><a id="hevea_default305"></a> <a id="hevea_default306"></a>
Étant donné la facilité de manipulation qu’apportent les
polynomes, on peut chercher à approcher une fonction par un
polynôme. La méthode la plus naturelle consiste à chercher
un polynôme de degré le plus petit possible
égal à la fonction en certains points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math>
et à trouver une majoration de la différence entre la fonction
et le polynôme.
Le polynome interpolateur de Lagrange répond à cette question.</p>
<!--TOC subsection id="sec269" Existence et unicité-->
<h3 id="sec269" class="subsection">23.1.1  Existence et unicité</h3><!--SEC END --><p>
Soit donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math> des réels distincts et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>y</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>y_0,...,y_n</annotation></semantics></math>
les valeurs de la fonction à approcher en ces points (on posera
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>j</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y_j=f(x_j)</annotation></semantics></math> pour approcher la fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>). On cherche
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>P(x_j)=y_i</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>j \in [0,n]</annotation></semantics></math>.</p><p>Commencons par voir s’il y a beaucoup de solutions. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>
deux solutions distinctes du problème, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&minus;</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>P&#x2d;Q</annotation></semantics></math> est non nul
et va s’annuler en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0, ...,x_n</annotation></semantics></math> donc possède <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> racines donc
est de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> au moins. Réciproquement, si on ajoute
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> un multiple du polynome <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>A=\prod_{j=0}^n (X&#x2d;x_j)</annotation></semantics></math>, on obtient
une autre solution. Toutes les solutions se déduisent donc
d’une solution particulière en y ajoutant un polynome de degré
au moins <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, et on prenant le
reste euclidien de la division par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> on en déduira une solution de
degré au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>.</p><p>Nous allons maintenant construire
cette solution particulière de degré au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>n=0</annotation></semantics></math>, on prend <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P=x_0</annotation></semantics></math> constant. On procède ensuite par
récurrence. Pour construire le polynôme correspondant
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_{n+1}</annotation></semantics></math> on part du polynoôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> correspondant à
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_{n}</annotation></semantics></math> et on lui ajoute un multiple réel de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>P</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>&alpha;</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> P_{n+1}=P_n+ \alpha_{n+1} \prod_{j=0}^n (X&#x2d;x_j)  </annotation></semantics></math>
Ainsi on a toujours <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_{n+1}(x_j)=y_j</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo>.</mo><mo>.</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>j=0,..n</annotation></semantics></math>, on calcule
maintenant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'> \alpha_{n+1}</annotation></semantics></math> pour que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P_{n+1}(x_{n+1})=y_{n+1}</annotation></semantics></math>.
En remplacant avec l’expression de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P_{n+1}</annotation></semantics></math> ci-dessus, on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>&alpha;</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'> P_n(x_{n+1})+  \alpha_{n+1} \prod_{j=0}^n (x_{n+1}&#x2d;x_j) = y_{n+1}  </annotation></semantics></math>
Comme tous les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> sont distincts, il existe une solution unique :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&alpha;</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mfrac><mrow><msub><mi>y</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>  \alpha_{n+1}=\frac{y_{n+1}&#x2d;P_n(x_{n+1})}{\prod_{j=0}^n (x_{n+1}&#x2d;x_j)} </annotation></semantics></math></p><p>On a donc prouvé le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 57</span>  <em> </em><a id="hevea_default307"></a><em> </em><a id="hevea_default308"></a><em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math><em> réels distincts </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math><em>
réels quelconques </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>y</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>y_0,...,y_n</annotation></semantics></math><em>.
Il existe un unique polynôme </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> de degré inférieur ou égal à
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><em>, appelé polynome de Lagrange, tel que :
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>y</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'> P(x_i)=y_i </annotation></semantics></math><em>
</em></div><p>Exemple : déterminons le polynome de degré inférieur ou égal
à 2 tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P(0)=1, P(1)=2, P(2)=1</annotation></semantics></math>. On commence par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P_0=1</annotation></semantics></math>.
Puis on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>P</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mi>X</mi><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mi>X</mi></mrow><annotation encoding='application/x-tex'>P_1=P_0+ \alpha_{1}X=1+ \alpha_{1}X</annotation></semantics></math>. 
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>=</mo><mn>1</mn><mo>+</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>P(1)=2=1+ \alpha_{1}</annotation></semantics></math> on en tire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'> \alpha_{1}=1</annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>+</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>P_1=1+X</annotation></semantics></math>. Puis on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>P</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>&alpha;</mi> <mn>2</mn></msub><mi>X</mi><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_2=P_1+ \alpha_{2}X(X&#x2d;1)</annotation></semantics></math>, on a 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mo>+</mo><mn>2</mn><msub><mi>&alpha;</mi> <mn>2</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P_2(2)=3+2 \alpha_{2}=1</annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mn>2</mn></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'> \alpha_{2}=&#x2d;1</annotation></semantics></math>, finalement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>2</mn></msub><mo>=</mo><mn>1</mn><mo>+</mo><mi>X</mi><mo>&minus;</mo><mi>X</mi><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_2=1+X&#x2d;X(X&#x2d;1)</annotation></semantics></math>.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">P:=interp([0,1,2],[1,2,1]); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p>
<!--TOC subsection id="sec270" Majoration de l’erreur d’interpolation.-->
<h3 id="sec270" class="subsection">23.1.2  Majoration de l’erreur d’interpolation.</h3><!--SEC END --><p>
Reste à estimer l’écart entre une fonction et son polynome
interpolateur, on a le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 58</span>  <em> </em><a id="hevea_default309"></a><em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> une fonction </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math><em> fois dérivable sur un intervalle </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>=</mo><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>I=[a,b]</annotation></semantics></math><em>
de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math><em>, </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math><em> des réels distincts de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em>. 
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> le polynome de Lagrange donné par les </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>j</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y_j=f(x_j)</annotation></semantics></math><em>.
Pour tout réel </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>x \in I</annotation></semantics></math><em>,
il existe un réel </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&xi;</mi> <mi>x</mi></msub><mo>&Element;</mo><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\xi_x \in [a,b]</annotation></semantics></math><em> (qui dépend de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math><em>) tel
que :
</em><a id="eqref_49"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&xi;</mi> <mi>x</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>49</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 f(x)&#x2d;P(x) = \frac{f^{[n+1]}(\xi_x)}{(n+1)!} \prod_{j=0}^n(x&#x2d;x_j) 
\qquad (49) </annotation></semantics></math><em>
</em></div><p>
Ainsi l’erreur commise dépend d’une majoration de la taille
de la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>-ième sur l’intervalle, mais aussi
de la disposition des points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>. Par exemple
si les points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> sont équidistribués, le terme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|\prod_{j=0}^n(x&#x2d;x_j)|</annotation></semantics></math> sera plus grand près du bord de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math> qu’au
centre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math>.</p><p>Preuve du théorème : Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est l’un des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> l’égalité est vraie. Soit 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>C</mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">/</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> C=(f(x)&#x2d;P(x))/\prod_{j=0}^n(x&#x2d;x_j)  </annotation></semantics></math>
on considère maintenant la fonction :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>P</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>C</mi><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> g(t)=f(t)&#x2d;P(t) &#x2d; C \prod_{j=0}^n(t&#x2d;x_j)  </annotation></semantics></math>
elle s’annule en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> variant de 0 à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> ainsi qu’en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>
suite au choix de la constante <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> s’annule au moins <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n+2</annotation></semantics></math> fois
sur l’intervalle contenant les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>g&apos;</annotation></semantics></math> s’annule au moins
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> fois sur ce même intervalle, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>&prime;</mo><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>g&apos;{&apos;}</annotation></semantics></math> s’annule au moins
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> fois, etc. et finalement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>g</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>g^{[n+1]}</annotation></semantics></math> s’annule une fois
au moins sur cet intervalle. Or 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>g</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo>=</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo>&minus;</mo><mi>C</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'> g^{[n+1]} = f^{[n+1]} &#x2d; C (n+1)! </annotation></semantics></math>
car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est de degré inférieur ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> 
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><msup><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> \prod_{j=0}^n(x&#x2d;x_j) &#x2d; x^{n+1}</annotation></semantics></math> est de degré
inférieur ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. Donc il existe bien un réel <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&xi;</mi> <mi>x</mi></msub></mrow><annotation encoding='application/x-tex'>\xi_x</annotation></semantics></math> dans
l’intervalle contenant les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>C</mi><mo>=</mo><mfrac><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&xi;</mi> <mi>x</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> C=\frac{f^{[n+1]}(\xi_x)}{(n+1)!}  </annotation></semantics></math>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">f(x):=ln(x^2+1); n:=10; X:=evalf(seq(j/n,j,0,n)); Y:=map(X,f); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">P:=interp(X,Y); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">plot([f(x),P],x=-1..2,color=[red,blue])
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">plot(1e7*abs(f(x)-P),x=0..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Attention, l’erreur d’interpolation peut devenir très grande
lorsqu’on utilise beaucoup de points d’interpolation.</p>
<!--TOC subsection id="sec271" Calcul efficace du polynôme de
Lagrange.-->
<h3 id="sec271" class="subsection">23.1.3  Calcul efficace du polynôme de
Lagrange.</h3><!--SEC END --><p><a id="hevea_default310"></a><a id="hevea_default311"></a>
Avec la méthode de calcul précédent, on remarque que le
polynôme de Lagrange peut s’écrire à la Horner sous la forme :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>&alpha;</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>&alpha;</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>&alpha;</mi> <mn>0</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mn>2</mn></msub><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>&alpha;</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><msub><mi>&alpha;</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 P(x) &amp;=&amp; \alpha_0 + \alpha_1 (x&#x2d;x_0) + ... + \alpha_n
 (x&#x2d;x_0)...(x&#x2d;x_{n&#x2d;1}) \\
&amp;=&amp; \alpha_0 + (x&#x2d;x_0)( \alpha_1 + (x&#x2d;x_1)(\alpha_2 +  ... +
(x&#x2d;x_{n&#x2d;2})(\alpha_{n&#x2d;1}+(x&#x2d;x_{n&#x2d;1}) \alpha_n)...))
 \end{matrix} </annotation></semantics></math>
ce qui permet de le calculer rapidement une fois les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>\alpha_i</annotation></semantics></math>
connus.
On observe que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&alpha;</mi> <mn>0</mn></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><msub><mi>&alpha;</mi> <mn>1</mn></msub><mo>=</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>x</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \alpha_0=f(x_0), \quad \alpha_1=\frac{f(x_1)&#x2d;f(x_0)}{x_1&#x2d;x_0}  </annotation></semantics></math>
On va voir que les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\alpha_k</annotation></semantics></math> peuvent aussi se mettre sous forme
d’une différence.
On définit les différences divisées d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> par récurrence
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mi>i</mi></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo><mo>=</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mi>i</mi></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mi>i</mi></mrow></msub><mo stretchy="false">]</mo></mrow><mrow><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'> f[x_i]=f(x_i), \quad f[x_i,...,x_{k+i+1}]=
\frac{f[x_{i+1},...,x_{k+i+1}]&#x2d;f[x_i,...,x_{k+i}]}{x_{k+i+1}&#x2d;x_i}  </annotation></semantics></math>
On va montrer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\alpha_k=f[x_0,...,x_k]</annotation></semantics></math>.
C’est vrai au rang 0, il suffit donc de le montrer au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math> en
l’admettant au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>. Pour cela on observe qu’on peut construire 
le polynôme d’interpolation en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_{k+1}</annotation></semantics></math> à partir des polynômes 
d’interpolation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_k</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>Q_k</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_1,...,x_{k+1}</annotation></semantics></math> 
par la formule :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mi>P</mi> <mi>k</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><msub><mi>Q</mi> <mi>k</mi></msub></mrow><mrow><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'> P_{k+1}(x)= \frac{(x_{k+1}&#x2d;x)P_k + (x&#x2d;x_0)Q_k}{x_{k+1}&#x2d;x_0} </annotation></semantics></math>
en effet on vérifie que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_{k+1}(x_i)=f(x_i)</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>i\in [1,k]</annotation></semantics></math> car
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Q</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_k(x_i)=f(x_i)=Q_k(x_i)</annotation></semantics></math>,
et pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>i=0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>i=k+1</annotation></semantics></math>, on a aussi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_{k+1}(x_0)=f(x_0)</annotation></semantics></math> et 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_{k+1}(x_{k+1})=f(x_{k+1})</annotation></semantics></math>.
Or <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>\alpha_{k+1}</annotation></semantics></math> est le coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P_{k+1}</annotation></semantics></math> donc
c’est la différence du coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>Q_k</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math>
divisée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_{k+1}&#x2d;x_0</annotation></semantics></math>, c’est-à-dire la définition de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>f[x_0,...,x_{k+1}]</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>f[x_1,...,x_{k+1}]</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>f[x_0,...,x_{k}]</annotation></semantics></math>.</p><p>Exemple : on reprend <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo>,</mo><mi>P</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P(0)=1, P(1)=2, P(2)=1</annotation></semantics></math>. On a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center"><mtr><mtd><msub><mi>x</mi> <mi>i</mi></msub></mtd> <mtd><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">]</mo></mtd> <mtd><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mi>i</mi></msub><mo>,</mo><msub><mi>x</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo></mtd> <mtd><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>2</mn></msub><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mo lspace="0em" rspace="thinmathspace">framebox</mo><mn>1</mn></mtd> <mtd/> <mtd/></mtr> <mtr><mtd/> <mtd/> <mtd><mo stretchy="false">(</mo><mn>2</mn><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="0em" rspace="thinmathspace">framebox</mo><mn>1</mn></mtd> <mtd/></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd/> <mtd><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mo>&minus;</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="0em" rspace="thinmathspace">framebox</mo><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></mtd></mtr> <mtr><mtd/> <mtd/> <mtd><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd/></mtr> <mtr><mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd/> <mtd/></mtr> <mtr><mtd/></mtr></mtable></mrow><annotation encoding='application/x-tex'>
\begin{array}{cccc}
x_i &amp; f[x_i] &amp; f[x_i,x_{i+1}] &amp; f[x_0,x_1,x_2] \\
0 &amp; \framebox{1} &amp; &amp; \\
  &amp;   &amp; (2&#x2d;1)/(1&#x2d;0)=\framebox{1} &amp; \\
1 &amp; 2 &amp; &amp;  (&#x2d;1&#x2d;1)/(2&#x2d;0)=\framebox{&#x2d;1}   \\
  &amp;   &amp; (1&#x2d;2)/(2&#x2d;1)=&#x2d;1 &amp; \\
2 &amp; 1 &amp; &amp; \\
\end{array}
 </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo lspace="0em" rspace="thinmathspace">framebox</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="0em" rspace="thinmathspace">framebox</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="0em" rspace="thinmathspace">framebox</mo><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="false">(</mo><mn>2</mn><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(x)=\framebox{1}+(x&#x2d;0)(\framebox{1}+(x&#x2d;1)(\framebox{&#x2d;1}))=1+x(2&#x2d;x)</annotation></semantics></math>.</p><p>On peut naturellement utiliser l’ordre que l’on souhaite pour les
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math>, en observant que le coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> ne dépend pas de
cet ordre, on en déduit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>f[x_0,...,x_k]</annotation></semantics></math> est indépendant de
l’ordre des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math>, on peut donc à partir du tableau ci-dessus
écrire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par exemple avec l’ordre 2,1,0, sous la forme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> P(x)=1+(x&#x2d;2)(&#x2d;1+(x&#x2d;1)(&#x2d;1))=1+(x&#x2d;2)(&#x2d;x) </annotation></semantics></math></p><p>Le nombre d’opérations nécessaires pour faire ce calcul est
proportionnel à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>n^2</annotation></semantics></math>.</p><p>La commande Xcas <code>interp</code> ou son synonyme <code>lagrange</code>
effectue ce calcul. Pour avoir les différences divisées, 
on peut appeler <code>interp</code> en ajoutant en dernier
paramètre <code>lagrange</code> <br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">X:=[0,1,2]; A:=lagrange(X,[1,2,1],lagrange);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
ou créer le programme suivant :

</p><pre class="verbatim">dd(X,Y):={ // Algorithme des différences divisées
  local k,l,n,A,old,cur;
  si size(X)!=size(Y) alors return "erreur" fsi;
  n:=size(X)-1;
  A:=[Y[0]];
  old:=Y;
  pour k de 1 jusque n faire
    // calcul de cur en fonction de old
    cur:=[];
    pour l de 0 jusque n-k faire
      cur[l]:=(old[l+1]-old[l])/(X[l+k]-X[l])
    fpour;
    A[k]:=cur[0];
    old:=cur;
  fpour;
  retourne A;
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>



<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">X:=[0,1,2];A:=dd(X,[1,2,1])
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

(N.B. pour rendre ce programme optimal, il faudrait utiliser
l’affectation en place <code>=&lt;</code> au lieu de <code>:=</code>).</p><p>L’évaluation d’un polynôme d’interpolation à partir des différences
divisées se fait en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n)</annotation></semantics></math> opérations
par un algorithme à la Horner qui consiste à évaluer
de l’intérieur vers l’extérieur la forme semi-factorisée
du polynôme en fonction des différences divisées et
des points d’interpolation. Cet algorithme est implémenté
par la commande <code>horner</code><a id="hevea_default312"></a> 
de Xcas, on lui passe les deux listes 
qui représentent le polynôme :<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">horner(A,X,1.5)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Remarque : on peut exprimer l’erreur d’interpolation
avec les différences divisées. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> est le polynôme
d’interpolation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math> alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">]</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>P_n(t)=f[x_0]+ (t&#x2d;x_0)f[x_0,x_1]+...+(t&#x2d;x_0)..(t&#x2d;x_{n&#x2d;1})f[x_0,..,x_n] </annotation></semantics></math>
en ajoutant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> comme point d’interpolation on obtient un polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_{n+1}(t)</annotation></semantics></math> qui coincide avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>t=x</annotation></semantics></math> donc
<a id="eqref_50"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">]</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>50</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 f(x)=f[x_0]+ (x&#x2d;x_0)f[x_0,x_1]+...+(x&#x2d;x_0)..(x&#x2d;x_{n})f[x_0,..,x_n,x]
\qquad (50) </annotation></semantics></math>
et en faisant la différence
<a id="eqref_51"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>51</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
P_n(x)&#x2d;f(x)=(x&#x2d;x_0)..(x&#x2d;x_{n})f[x_0,..,x_n,x]
\qquad (51) </annotation></semantics></math>
On en déduit aussi que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&xi;</mi> <mi>x</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>f[x_0,...,x_n,x]=f^{[n+1]}(\xi_x)/(n+1)!</annotation></semantics></math>.</p>
<!--TOC subsection id="sec272" Sensibilité aux erreurs sur les données.-->
<h3 id="sec272" class="subsection">23.1.4  Sensibilité aux erreurs sur les données.</h3><!--SEC END --><p>
Si les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>y_j</annotation></semantics></math> sont connus avec une certaine erreur, alors le polynôme 
d’interpolation est connu de manière approchée. Plus
précisément, si on note
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&pi;</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></munder><mfrac><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>k</mi></msub></mrow><mrow><msub><mi>x</mi> <mi>j</mi></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>k</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\pi_j(x)=\prod_{k \neq j} \frac{x&#x2d;x_k}{x_j&#x2d;x_k} </annotation></semantics></math>
le <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>-ième polynome de Lagrange valant 1 en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> et 0 ailleurs,
l’erreur vaut :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>j</mi></munder><mo stretchy="false">(</mo><msub><mover><mi>y</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi></msub><mo>&minus;</mo><msub><mi>y</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><msub><mi>&pi;</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sum_j (\tilde{y}_j&#x2d;y_j) \pi_j(x)  </annotation></semantics></math>
Si l’erreur relative sur les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>y_j</annotation></semantics></math> est majorée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>\epsilon</annotation></semantics></math>,
l’erreur sur le polynôme d’interpolation est majorée par :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&epsi;</mi><mspace width="thinmathspace"/><msub><mtext>max</mtext> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>y</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>j</mi></munder><mo stretchy="false">&vert;</mo><msub><mi>&pi;</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\epsilon \, \mbox{max}_j|y_j| \sum_j |\pi_j(x)|  </annotation></semantics></math>
il y a amplification de l’erreur par un facteur majoré par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mtext>max</mtext> <mrow><mi>x</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow></msub><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">&vert;</mo><msub><mi>&pi;</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\mbox{max}_{x \in [a,b]} \sum_{j=0}^n |\pi_j(x)|  </annotation></semantics></math>
Ce facteur s’appelle <span style="font-weight:bold">constante de Lebesgue</span><a id="hevea_default313"></a><a id="hevea_default314"></a> relative à la
subdivision <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math>. On peut le calculer
numériquement pour une subdivision équidistribuée,
et montrer qu’il croit comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mrow><msup><mn>2</mn> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mi>e</mi><mi>n</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{2^{n+1}}{e n \ln(n)}</annotation></semantics></math>,
par exemple pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>40</mn></mrow><annotation encoding='application/x-tex'>n=40</annotation></semantics></math>, il vaut environ <span style="font-family:monospace">5e9</span>.
Illustration avec Xcas :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">restart;l(k,n):=product((x-j)/(k-j),j,0,k-1)*product((x-j)/(k-j),j,k+1,n); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">n:=10; f:=add(abs(l(k,n)),k,0,n); plot(f,x=0..n)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>puis essayer avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>20</mn></mrow><annotation encoding='application/x-tex'>n=20</annotation></semantics></math>. Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>40</mn></mrow><annotation encoding='application/x-tex'>n=40</annotation></semantics></math>, en observant que le max
est atteint dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,1]</annotation></semantics></math>, on peut remplacer les valeurs absolues
par la bonne puissance de -1<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">n:=40; g:=l(0,n)+add((-1)^(k+n-1)*l(k,n),k,1,n) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>on a alors un polynôme, dont on calcule l’abscisse du maximum par<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">g1:=normal(g'); l:=realroot(g1,1e-12,evalf) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>puis 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">subst(g,x=l[0])
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
 qui donne environ <span style="font-family:monospace">4.7e9</span>.</p>
<!--TOC section id="sec273" Interpolation aux points de Tchebyshev-->
<h2 id="sec273" class="section">23.2  Interpolation aux points de Tchebyshev</h2><!--SEC END --><p><a id="hevea_default315"></a>
L’idée la plus naturelle pour interpoler un polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>
points d’un intervalle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math> consiste à couper en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> morceaux
de même longueur. Mais ce n’est pas le plus efficace car le
terme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|\prod_{j=0}^n(x&#x2d;x_j)|</annotation></semantics></math> est plus grand près des bords. Il est
donc plus judicieux d’avoir plus de points près des bords et moins
à l’intérieur. C’est là qu’interviennent les polynômes de
Tchebyshev, ils sont définis par développement de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>cos</mi><mo stretchy="false">(</mo><mi>n</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\cos(nx)</annotation></semantics></math>
en puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>cos</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\cos(x)</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>n</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_n(\cos(x))=\cos(nx)  </annotation></semantics></math>
Sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math>, le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>T_n</annotation></semantics></math> vaut en valeur absolue au plus 1, et
atteint cette valeur exactement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> fois lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>k</mi><mi>&pi;</mi><mo stretchy="false">/</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>x=k\pi/n</annotation></semantics></math> donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>=</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>k</mi><mi>&pi;</mi><mo stretchy="false">/</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>X=\cos(x)=\cos(k\pi/n)</annotation></semantics></math>.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">n:=7; plot(tchebyshev1(n),x=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>De plus cette majoration est optimale. En effet
soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> un polynôme de degré au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> 
qui vérifie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>U</mi><msub><mo stretchy="false">&vert;</mo> <mn>&infin;</mn></msub><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>|U|_\infty&amp;lt;1</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math>
et tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> ait le même coefficient dominant que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>T_n</annotation></semantics></math>. Alors la différence <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>U</mi></mrow><annotation encoding='application/x-tex'>T_n&#x2d;U</annotation></semantics></math> est du signe de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>T_n</annotation></semantics></math> en
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>=</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>k</mi><mi>&pi;</mi><mo stretchy="false">/</mo><mi>n</mi><mo stretchy="false">)</mo><mo>,</mo><mi>k</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>X=\cos(k\pi/n), k \in [0,n]</annotation></semantics></math> puisqu’en ces points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>T_n</annotation></semantics></math> est
extrêmal de valeur absolue 1. Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>U</mi></mrow><annotation encoding='application/x-tex'>T_n&#x2d;U</annotation></semantics></math> s’annule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> fois sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math>, mais son degré est au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo>=</mo><mi>U</mi></mrow><annotation encoding='application/x-tex'>T_n=U</annotation></semantics></math> absurde.</p><p>On a donc intérêt à prendre les abscisses des points
d’interpolation en les racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>t</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>t_n</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>T_n</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><mn>2</mn></mfrac><mo>+</mo><mfrac><mrow><mi>a</mi><mo>&minus;</mo><mi>b</mi></mrow><mn>2</mn></mfrac><msub><mi>t</mi> <mi>n</mi></msub><mo>,</mo><mspace width="1em"/><msub><mi>t</mi> <mi>n</mi></msub><mo>=</mo><mi>cos</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mfrac><mi>&pi;</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><mi>k</mi><mo>=</mo><mn>0</mn><mo>.</mo><mo>.</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\frac{a+b}{2} + \frac{a&#x2d;b}{2} t_n, \quad t_n=\cos((k+\frac{1}{2})\frac\pi n), 
\quad k=0..n&#x2d;1 </annotation></semantics></math>
On pourra observer que le phénomène de 
Runge<a id="hevea_default316"></a> qui apparait par
exemple pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>25</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)=1/(25x^2+1)</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math> avec des points d’interpolation
équidistants n’apparait plus si on prend des points de Tchebyshev.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">f(x):=1/(1+25x^2); n:=20; X:=seq(2*j/n-1.0,j,0,n);  
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">l:=lagrange(X,map(X,f)):; plot(l-f(x),x=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p><div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">T:=seq(cos((j+0.5)*pi/(n+1)),j,0,n); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-style:large">l:=lagrange(T,map(T,f)):; plot(100*(l-f(x)),x=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Ceci est relié à la constante de Lebesgue 
qui pour des points de Tchebyshev vaut un peu moins de 4 pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&lt;</mi><mn>100</mn></mrow><annotation encoding='application/x-tex'>n&amp;lt;100</annotation></semantics></math>
(se comporte comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mn>2</mn><mi>&pi;</mi></mfrac><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\frac2\pi \ln(n)</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> grand), on peut montrer
que les polynômes de Lagrange aux points de Tchebyshev convergent
uniformément vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>25</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>1/(25x^2+1)</annotation></semantics></math> (c’est plus généralement
vrai pour toute fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mn>1</mn></msup></mrow><annotation encoding='application/x-tex'>C^1</annotation></semantics></math> sur l’intervalle).</p><p>Remarque : ce n’est pas le polynôme de meilleure approximation,
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> (celui qui minimise la norme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>&infin;</mn></msup></mrow><annotation encoding='application/x-tex'>L^\infty</annotation></semantics></math> de la différence)
car la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>-ième varie en général sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math>. Mais
il est trop difficile de le calculer en général.</p><p>Exemple de calcul explicite de constante de Lebesgue pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>40</mn></mrow><annotation encoding='application/x-tex'>n=40</annotation></semantics></math> avec
Xcas

</p><pre class="verbatim">purge(x);
t(k,n):={ 
 local T; 
 T:=seq(cos(pi*(k+.5)/(n+1)),k,0,n);
 return product((x-T[j])/(T[k]-T[j]),j,0,k-1)*
  product((x-T[j])/(T[k]-T[j]),j,k+1,n);
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>



<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-style:large">n:=40; f:=add(abs(t(k,n)),k,0,n):;plot(f,x=-1..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC section id="sec274" Interpolation de Hermite-->
<h2 id="sec274" class="section">23.3  Interpolation de Hermite</h2><!--SEC END --><p><a id="hevea_default317"></a>
Si on fait tendre un des points d’interpolation vers un autre, la
donnée de la valeur en ces 2 points serait redondante, elle 
est remplacée par la valeur de la dérivée. Dans le calcul
des différences divisées ci-dessus on fera comme si les
2 points étaient distincts et successifs, disons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_{i+1}</annotation></semantics></math>,
on remplace le rapport indéterminé 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>x</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mn>0</mn><mn>0</mn></mfrac></mrow><annotation encoding='application/x-tex'> \frac{f(x_{i+1})&#x2d;f(x_i)}{x_{i+1}&#x2d;x_i} = \frac{0}{0}  </annotation></semantics></math>
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f&apos;(x_i)</annotation></semantics></math>.
On montre qu’une fois ce changement réalisé
tout le reste est identique (y compris la majoration d’erreur).
On peut bien sur généraliser au cas de plusieurs paires de points 
identiques ou des multiplicités plus grandes faisant intervenir
des dérivées d’ordre supérieures, dans ce cas la différence
divisée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mi>i</mi></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>i</mi><mo>+</mo><mi>m</mi></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>f[x_i,...,x_{i+m}]</annotation></semantics></math> sera remplacée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>m</mi><mo>!</mo></mrow><annotation encoding='application/x-tex'>f^{[m]}(x_i)/m!</annotation></semantics></math>.</p>
<!--TOC section id="sec275" Polynômes de Bernstein et courbes de
Bézier-->
<h2 id="sec275" class="section">23.4  Polynômes de Bernstein et courbes de
Bézier</h2><!--SEC END --><p><a id="hevea_default318"></a> <a id="hevea_default319"></a>
Les polynômes de Bernstein de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> sont les
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mi>B</mi> <mi>k</mi> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>n</mi></mtd></mtr> <mtr><mtd><mi>k</mi></mtd></mtr></mtable><mo>)</mo></mrow><msup><mi>x</mi> <mi>k</mi></msup><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>B^n_k (x) = 
\left( \begin{array}{c} n \\ k \end{array} \right) x^k (1&#x2d;x)^{n&#x2d;k} </annotation></semantics></math>
On reconnait la probabilité d’avoir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> succès si on effectue <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
tirages indépendants (avec remise) 
avec probabilité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>x \in [0,1]</annotation></semantics></math> de succès par tirage. Ceci donne
une relation de récurrence
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mi>B</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo><msubsup><mi>B</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><mo>+</mo><mi>x</mi><msubsup><mi>B</mi> <mi>k</mi> <mi>n</mi></msubsup></mrow><annotation encoding='application/x-tex'>B^{n+1}_{k+1}=(1&#x2d;x)B^n_{k+1}+x B^n_k  </annotation></semantics></math>
qui peut servir à calculer les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>B</mi> <mi>i</mi> <mi>m</mi></msubsup></mrow><annotation encoding='application/x-tex'>B^m_i</annotation></semantics></math>. On en déduit aussi que l’espérance
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> selon cette loi vaut <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>nx</annotation></semantics></math> (somme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> variables d’espérance
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>) et l’espérance de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>n</mi><mi>x</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>(k&#x2d;nx)^2</annotation></semantics></math> vaut
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>x</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>nx(1&#x2d;x)</annotation></semantics></math> (variance de la somme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> variables indépendantes
de variance <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>).
On en déduit qu’on peut approcher uniformément une
fonction continue sur un intervalle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math> par des polynômes, en
se ramenant à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a=0, b=1</annotation></semantics></math>, on pose :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mi>f</mi><mo stretchy="false">(</mo><mfrac><mi>k</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo><msubsup><mi>B</mi> <mi>k</mi> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_n(x) = \sum_{k=0}^n f(\frac{k}{n}) B^n_k(x)  </annotation></semantics></math>
En effet, par continuité uniforme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,1]</annotation></semantics></math>, pour
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\epsilon&amp;gt;0</annotation></semantics></math>,
il existe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\delta&amp;gt;0</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo>&minus;</mo><mi>y</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>&delta;</mi><mo>&Rightarrow;</mo><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>&epsi;</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>|x&#x2d;y|&amp;lt;\delta \Rightarrow
|f(x)&#x2d;f(y)|&amp;lt;\epsilon/2</annotation></semantics></math>,
dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mfrac><mi>k</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msubsup><mi>B</mi> <mi>k</mi> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_n(x)&#x2d;f(x)=\sum_{k=0}^n (f(\frac{k}{n})&#x2d;f(x)) B^n_k(x) </annotation></semantics></math>
on décompose la somme sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> en deux parties, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>k</mi><mo stretchy="false">/</mo><mi>n</mi><mo>&minus;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>|k/n&#x2d;x|&amp;lt;\delta</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>k</mi><mo stretchy="false">/</mo><mi>n</mi><mo>&minus;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&geq;</mo><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>|k/n&#x2d;x| \geq \delta</annotation></semantics></math>, pour la première somme, on majore
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">(</mo><mfrac><mi>k</mi><mi>n</mi></mfrac><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|f(\frac{k}{n})&#x2d;f(x)|</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\epsilon/2</annotation></semantics></math> puis par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></msubsup></mrow><annotation encoding='application/x-tex'>\sum_{k=0}^n</annotation></semantics></math>,
pour la deuxième somme, on majore par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo stretchy="false">&vert;</mo><mi>f</mi><msub><mo stretchy="false">&vert;</mo> <mn>&infin;</mn></msub></mrow><annotation encoding='application/x-tex'>2|f|_\infty</annotation></semantics></math> et on utilise
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mi>&lt;</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">/</mo><mi>n</mi><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">/</mo><msup><mi>&delta;</mi> <mn>2</mn></msup><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><msup><mi>&delta;</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>n</mi><mi>x</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>1&amp;lt;(k/n&#x2d;x)^2/\delta^2=1/n^2/\delta^2 (k&#x2d;nx)^2</annotation></semantics></math> pour se ramener au calcul
de la variance de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, au final
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mi>&epsi;</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mn>1</mn><mrow><msup><mi>n</mi> <mn>2</mn></msup><msup><mi>&delta;</mi> <mn>2</mn></msup></mrow></mfrac><mi>n</mi><mi>x</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mi>f</mi><msub><mo stretchy="false">&vert;</mo> <mn>&infin;</mn></msub></mrow><annotation encoding='application/x-tex'>|P_n(x)&#x2d;f(x)| \leq \frac \epsilon 2 + \frac{1}{n^2 \delta^2} nx(1&#x2d;x)|f|_\infty </annotation></semantics></math>
il suffit de choisir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> assez grand pour rendre le membre de droite
plus petit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>\epsilon</annotation></semantics></math>.</p><p>Les polynômes de Bernstein ne sont pas des polynômes
interpolateurs aux points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo stretchy="false">/</mo><mi>n</mi><mo>,</mo><mspace width="thinmathspace"/><mn>0</mn><mi>&lt;</mi><mi>k</mi><mi>&lt;</mi><mi>n</mi></mrow><annotation encoding='application/x-tex'>k/n, \, 0&amp;lt;k&amp;lt;n</annotation></semantics></math>, et la convergence
n’est pas forcément très rapide.
On les utilise pour approcher rapidement des morceaux de
courbes, si on se donne des “points de controle” <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>A</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>A</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>A_0, ..., A_n</annotation></semantics></math>
on construit la courbe paramétrée
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><msub><mi>A</mi> <mi>k</mi></msub><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mi>n</mi></mtd></mtr> <mtr><mtd><mi>i</mi></mtd></mtr></mtable><mo>)</mo></mrow><msup><mi>x</mi> <mi>i</mi></msup><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>&minus;</mo><mi>i</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>A(t) = \sum_{k=0}^n A_k \left( \begin{array}{c} n\\ i \end{array} \right) x^i
(1&#x2d;x)^{n&#x2d;i}  </annotation></semantics></math>
appelée courbe de Bézier. En pratique on les utilise pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>n=3</annotation></semantics></math>.</p>
<!--TOC section id="sec276" Polynômes orthogonaux.-->
<h2 id="sec276" class="section">23.5  Polynômes orthogonaux.</h2><!--SEC END --><p><a id="hevea_default320"></a>
<a id="hevea_default321"></a>
Il s’agit d’une autre méthode d’approximation, 
particulièrement important pour l’intégration : les polynômes
de meilleur approximation au sens de normes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>L^2</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>L</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>L^2</annotation></semantics></math>
à poids <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>w(x)&amp;gt;0</annotation></semantics></math> sur l’intervalle de bornes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\beta</annotation></semantics></math>
(finis ou infinis). 
On considère le produit scalaire
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mi>f</mi><mo stretchy="false">&vert;</mo><mi>g</mi><mi>&gt;</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;f|g&amp;gt;=\int_\alpha^\beta w(x) f(x)g(x) \ dx </annotation></semantics></math>
et on projette alors la fonction à approcher 
sur une base de polynômes orthogonaux
de degrés croissants construit par la procédure
de Gram-Schmidt à partir de la base canonique
pour le produit scalaire ci-dessus.</p><div class="theorem"><span style="font-weight:bold">Proposition 59</span>  <em>
Le polynôme </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math><em> de degré </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><em>
obtenu par orthogonalisation de Gram-Schmidt
pour le produit scalaire </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>\int_\alpha^\beta w(x) f(x)g(x) \ dx</annotation></semantics></math><em>
possède </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><em> racines réelles.
</em></div><p>
En effet, soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> le nombre de racines réelles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math>, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>=</mo><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>f=P_n</annotation></semantics></math> et 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>r</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>g=\prod_{i=1}^r (x&#x2d;x_i)</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mi>f</mi><mi>g</mi></mrow><annotation encoding='application/x-tex'>wfg</annotation></semantics></math> est de signe constant
et non identiquement nul donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><mi>f</mi><mo stretchy="false">&vert;</mo><mi>g</mi><mi>&gt;</mi><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>&amp;lt;f|g&amp;gt; \neq 0</annotation></semantics></math> donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>r=n</annotation></semantics></math> sinon <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> serait de degré strictement plus petit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
donc orthogonal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math>.</p><p>On peut aussi construire ces polynômes en cherchant les valeurs
propres de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>w</mi></mfrac><mo stretchy="false">(</mo><mi>a</mi><mi>w</mi><mi>f</mi><mo>&prime;</mo><mo stretchy="false">)</mo><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>T(f)=\frac{1}{w} (awf&apos;)&apos; </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>a&amp;gt;0</annotation></semantics></math> est un polynôme de degré au plus 2
sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]\alpha,\beta[</annotation></semantics></math>, tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>w</mi></mrow><annotation encoding='application/x-tex'>aw</annotation></semantics></math> s’annule (ou dont le produit
par un polynôme tend vers 0) 
aux bornes de l’intervalle d’intégration : si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\beta</annotation></semantics></math> sont finis
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>a(x)=(x&#x2d;\alpha)(\beta&#x2d;x)</annotation></semantics></math>.
On a alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mi>T</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mi>g</mi><mi>&gt;</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">(</mo><mi>a</mi><mi>w</mi><mi>f</mi><mo>&prime;</mo><mo stretchy="false">)</mo><mo>&prime;</mo><mi>g</mi><mo>=</mo><mo stretchy="false">[</mo><mi>a</mi><mi>w</mi><mi>f</mi><mo>&prime;</mo><mi>g</mi><msubsup><mo stretchy="false">]</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>a</mi><mi>w</mi><mi>g</mi><mo>&prime;</mo><mi>f</mi><mo>&prime;</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>a</mi><mi>w</mi><mi>g</mi><mo>&prime;</mo><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>&amp;lt;T(f)|g&amp;gt;=\int_\alpha^\beta (awf&apos;)&apos;g =
[awf&apos;g]_\alpha^\beta&#x2d;\int_\alpha^\beta awg&apos;f&apos;
=&#x2d;\int_\alpha^\beta awg&apos;f&apos; </annotation></semantics></math>
car le terme tout intégré s’annule 
(puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>w</mi></mrow><annotation encoding='application/x-tex'>aw</annotation></semantics></math> s’annule en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\beta</annotation></semantics></math>). Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><mi>T</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mi>g</mi><mi>&gt;</mi><mo>=</mo><mi>&lt;</mi><mi>f</mi><mo stretchy="false">&vert;</mo><mi>T</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;T(f)|g&amp;gt;=&amp;lt;f|T(g)&amp;gt;</annotation></semantics></math>
est symétrique, les vecteurs propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> correspondant à des
valeurs propres distinctes sont donc orthogonaux entre eux.
Pour trouver ces valeurs propres/polynômes vecteurs propres, on
écrit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>&lambda;</mi> <mi>n</mi></msub><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>T(P_n)=\lambda_n P_n</annotation></semantics></math> pour un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> de degré
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>w</mi><mo>&prime;</mo><mo stretchy="false">/</mo><mi>w</mi></mrow><annotation encoding='application/x-tex'>aw&apos;/w</annotation></semantics></math> est un polynôme de degré au plus 1, 
le terme de degré dominant de cette équation
donne la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>\lambda_n</annotation></semantics></math> et les termes de degré plus petits
permettent en général de déterminer de manière unique les
coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> en fonction du coefficient dominant.</p><p>Pour certains poids <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>w(x)</annotation></semantics></math> standards,
les polynômes obtenus ont un nom :
</p><ul class="itemize"><li class="li-itemize">
Legendre<a id="hevea_default322"></a> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>w(x)=1</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>a(x)=1&#x2d;x^2</annotation></semantics></math>
</li><li class="li-itemize">Hermite pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>w(x)=e^{&#x2d;x^2}</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a(x)=1</annotation></semantics></math>
</li><li class="li-itemize">Laguerre pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mi>a</mi></msup><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>x</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>w(x)=x^a e^{&#x2d;x}</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mo>+</mo></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^+</annotation></semantics></math>, 
</li><li class="li-itemize">Tchebyshev de première espèce pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><msqrt><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding='application/x-tex'>w(x)=1/\sqrt{1&#x2d;x^2}</annotation></semantics></math> sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>a(x)=1&#x2d;x^2</annotation></semantics></math>
</li><li class="li-itemize">Tchebyshev de deuxième espèce pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msqrt><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding='application/x-tex'>w(x)=\sqrt{1&#x2d;x^2}</annotation></semantics></math> sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>a(x)=1&#x2d;x^2</annotation></semantics></math>
</li></ul><p>Ainsi, les polynômes de Legendre vérifient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><msub><mi>P</mi> <mi>n</mi></msub><mo>&prime;</mo><mo stretchy="false">)</mo><mo>&prime;</mo><mo>=</mo><msub><mi>&lambda;</mi> <mi>n</mi></msub><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>((1&#x2d;x^2)P_n&apos;)&apos;=\lambda_n P_n </annotation></semantics></math>
Le terme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> de cette équation donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&lambda;</mi> <mi>n</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\lambda_n=&#x2d;n(n+1)</annotation></semantics></math>,
le terme sous-dominant est nul. Plus générallement, 
le terme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> vérifie
<a id="eqref_52"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>p</mi> <mi>k</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>p</mi> <mi>k</mi></msub><mo>&Rightarrow;</mo><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><mfrac><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><msub><mi>p</mi> <mi>k</mi></msub><mspace width="2em"/><mo stretchy="false">(</mo><mn>52</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 (k+2)(k+1)p_{k+2}&#x2d;k(k+1)p_k=&#x2d;n(n+1)p_k \Rightarrow
p_{k+2}=\frac{k(k+1)&#x2d;n(n+1)}{(k+2)(k+1)} p_k
\qquad (52) </annotation></semantics></math>
Ceci permet de calculer le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math>, on normalise
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P_n(1)=1</annotation></semantics></math>.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">n:=10; p:=makelist(n+1); p[0]:=1;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">for k from 0 to size(p)-3 step 2 do p[k+2]:=(k*(k+1)-n*(n+1))/(k+2)/(k+1)*p[k]; od;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">q:=p*1/sum(p); normal(poly2symb(revlist(q))); legendre(n) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>Le calcul de ces polynômes peut aussi se faire par une récurrence à 2
crans du type :
<a id="eqref_53"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi> <mi>n</mi></msub><mi>x</mi><mo>&minus;</mo><msub><mi>b</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><msub><mi>P</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>c</mi> <mi>n</mi></msub><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mspace width="2em"/><mo stretchy="false">(</mo><mn>53</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
P_{n+1}=(a_nx&#x2d;b_n)P_n&#x2d;c_nP_{n&#x2d;1}
\qquad (53) </annotation></semantics></math>
La valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>a_n</annotation></semantics></math> est définie par la normalisation de la famille de
polynômes, ensuite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>b_n</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>c_n</annotation></semantics></math> sont déterminés respectivement
par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>n</mi></msub><mi>&gt;</mi><mo>=</mo><mn>0</mn><mo>&Rightarrow;</mo><msub><mi>b</mi> <mi>n</mi></msub><mi>&lt;</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>n</mi></msub><mi>&gt;</mi><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><mi>&lt;</mi><mi>x</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>n</mi></msub><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;P_{n+1}|P_n&amp;gt;=0 \Rightarrow b_n&amp;lt;P_n|P_n&amp;gt;=a_n&amp;lt;xP_n|P_n&amp;gt; </annotation></semantics></math> 
et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>&gt;</mi><mo>=</mo><mn>0</mn><mo>&Rightarrow;</mo><msub><mi>c</mi> <mi>n</mi></msub><mi>&lt;</mi><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>&gt;</mi><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><mi>&lt;</mi><mi>x</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>&gt;</mi><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><mi>&lt;</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mi>x</mi><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;P_{n+1}|P_{n&#x2d;1}&amp;gt;=0 \Rightarrow
c_n&amp;lt;P_{n&#x2d;1}|P_{n&#x2d;1}&amp;gt;=a_n&amp;lt;xP_n|P_{n&#x2d;1}&amp;gt;=a_n&amp;lt;P_n|xP_{n&#x2d;1}&amp;gt; </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>c</mi> <mi>n</mi></msub><mi>&lt;</mi><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>&gt;</mi><mo>=</mo><mfrac><mrow><msub><mi>a</mi> <mi>n</mi></msub></mrow><mrow><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac><mi>&lt;</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>c</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mi>&gt;</mi><mo>=</mo><mfrac><mrow><msub><mi>a</mi> <mi>n</mi></msub></mrow><mrow><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac><mi>&lt;</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>n</mi></msub><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>c_n&amp;lt;P_{n&#x2d;1}|P_{n&#x2d;1}&amp;gt;=\frac{a_n}{a_{n&#x2d;1}}&amp;lt;P_n|P_n+b_{n&#x2d;1}P_{n&#x2d;1}+c_{n&#x2d;1}P_{n&#x2d;2}&amp;gt;
=\frac{a_n}{a_{n&#x2d;1}}&amp;lt;P_n|P_n&amp;gt; </annotation></semantics></math>
Les autres relations
d’orthogonalité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>j</mi></msub><mi>&gt;</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>j</mi><mi>&lt;</mi><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>&amp;lt;P_{n+1}|P_j&amp;gt;=0, j&amp;lt;n&#x2d;1</annotation></semantics></math> sont automatiquement
vérifiées puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><mi>x</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>j</mi></msub><mi>&gt;</mi><mo>=</mo><mi>&lt;</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mi>x</mi><msub><mi>P</mi> <mi>j</mi></msub><mi>&gt;</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>&amp;lt;xP_n|P_j&amp;gt;=&amp;lt;P_n|xP_j&amp;gt;=0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> est orthogonal
aux polynômes de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\leq n&#x2d;1</annotation></semantics></math>.</p><p>Dans l’exemple des polynômes de Legendre, les polynômes obtenus
sont pairs si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est pair et impairs sinon, la relation de 
récurrence a donc un coefficient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>b_n</annotation></semantics></math> nul. La convention
de normalisation usuelle est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P_n(1)=1</annotation></semantics></math>, on peut montrer qu’on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>a_n=(2n+1)/(n+1)</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>P</mi> <mi>n</mi></msub><mi>&gt;</mi><mo>=</mo><mn>2</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&amp;lt;P_n|P_n&amp;gt;=2/(2n+1)</annotation></semantics></math> 
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>n</mi></msub><mo>=</mo><mi>n</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c_n=n/(n+1)</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>x</mi><msub><mi>P</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>n</mi><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>(n+1)P_{n+1}=(2n+1)xP_n&#x2d;nP_{n&#x2d;1}  </annotation></semantics></math>
En effet la normalisation en 1 donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>c</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>1=a_n&#x2d;c_n</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>c_n=a_n&#x2d;1</annotation></semantics></math>,
les termes de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><mi>x</mi><msub><mi>P</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>c</mi> <mi>n</mi></msub><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P_{n+1}=a_nxP_n&#x2d;c_nP_{n&#x2d;1}</annotation></semantics></math> donnent
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>p</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><msub><mi>p</mi> <mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>p</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><msub><mi>p</mi> <mrow><mi>n</mi><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>a</mi> <mi>n</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>p_{n+1,n+1}=a_np_{n,n}, \quad p_{n+1,n&#x2d;1}=a_n
p_{n,n&#x2d;2}&#x2d;(a_n&#x2d;1)p_{n&#x2d;1,n&#x2d;1} </annotation></semantics></math>
On applique alors (<a href="#eqref_52">52</a>) et on déduit de la
deuxième équation ci-dessus :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><msub><mi>p</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><msub><mi>a</mi> <mi>n</mi></msub><msub><mi>p</mi> <mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow></msub><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>a</mi> <mi>n</mi></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>p</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>&#x2d;\frac{n(n+1)}{2(2n+1)} p_{n+1,n+1}= &#x2d;\frac{n(n&#x2d;1)}{2(2n+1)} a_n
p_{n,n}&#x2d;(a_n&#x2d;1)p_{n&#x2d;1,n&#x2d;1} </annotation></semantics></math>
puis on applique la première :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><mo>&minus;</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mi>a</mi> <mi>n</mi></msub><mo>&minus;</mo><mn>1</mn></mrow><mrow><msub><mi>a</mi> <mi>n</mi></msub><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{n(n+1)}{2(2n+1)} &#x2d;
\frac{n(n&#x2d;1)}{2(2n+1)}=\frac{a_n&#x2d;1}{a_na_{n&#x2d;1}} </annotation></semantics></math>
d’où 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>&minus;</mo><mfrac><mrow><msup><mi>n</mi> <mn>2</mn></msup></mrow><mrow><mn>4</mn><msup><mi>n</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn></mrow></mfrac><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>a_n=\frac{1}{1&#x2d;\frac{n^2}{4n^2&#x2d;1} a_{n&#x2d;1}} </annotation></semantics></math></p><p><div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">S(f,g):=int(f*g,x,-1,1); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p><div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">gramschmidt([1,x,x^2,x^3,x^4],S); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">f:=ln(x+2);C:=seq(S(f,legendre(k))/S(legendre(k),legendre(k)),k,0,4); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">g:=sum(C[j]*legendre(j),j,0,4); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">plot([f,g],x,-1.4,1.4,color=[red,blue]);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p><span style="font-weight:bold">Remarques</span>
</p><ul class="itemize"><li class="li-itemize">
On peut utiliser la récurrence à deux crans pour évaluer
le polynôme en un réel, il n’est alors pas nécessaire
de calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> dans la base canonique.
</li><li class="li-itemize">La récurrence à deux crans se généralise pour les degrés
plus petits que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> au produit scalaire
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mi>P</mi><mo stretchy="false">&vert;</mo><mi>Q</mi><mi>&gt;</mi><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>d</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mi>Q</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&amp;lt;P|Q&amp;gt;=\sum_{j=0}^d P(x_j) Q(x_j)  </annotation></semantics></math>
où les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> sont des abscisses distinctes 2 à 2. Le calcul
d’une base orthogonale permet de
faire des calculs de régressions polynomiales mieux conditionnés
qu’en utilisant la base canonique (et la matrice de Vandermonde).
</li><li class="li-itemize">On peut voir l’interpolation trigonométrique (séries de Fourier,
transformée de Fourier discrète) comme une
généralisation en remplaçant une base orthonormalisée
de polynômes par une base orthogonale de sinus, cosinus
ou exponentielles.
</li></ul>
<!--TOC section id="sec277" Les splines-->
<h2 id="sec277" class="section">23.6  Les splines</h2><!--SEC END --><p><a id="hevea_default323"></a>
Il s’agit de fonctions définies par des polynomes de degré borné
sur des intervalles, dont on fixe la valeur
aux extrémités des intervalles (comme pour le polynome de Lagrange)
ce qui rend la fonction continue, de plus on exige un
degré de régularité plus grand, par exemple etre de classe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>C^2</annotation></semantics></math>.
Enfin, on fixe des conditions aux bornes de la réunion des 
intervalles, par exemple avoir certaines dérivées nulles. </p><p>Par exemple supposons qu’on se donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> intervalles, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>
points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math>, on se fixe une régularité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>C^{d&#x2d;1}</annotation></semantics></math>. Ceci
entraine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>(n&#x2d;1)d</annotation></semantics></math> conditions de recollement, on y ajoute <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>
conditions de valeur en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math>, on a donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>nd+1</annotation></semantics></math> conditions,
la borne sur le degré des polynomes doit donc etre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> (ou plus,
mais <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> suffit) ce qui donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>n(d+1)</annotation></semantics></math> degrés de liberté, on
peut donc ajouter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>d&#x2d;1</annotation></semantics></math> conditions, par exemple pour les splines
naturelles, on impose que les dérivées d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>d/2</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>d&#x2d;1</annotation></semantics></math>
soient nulles en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math> (si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> est pair, on commence à
la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo stretchy="false">/</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>d/2+1</annotation></semantics></math>-ième nulle en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math>).</p><p>Pour trouver les polynomes, on doit donc résoudre un grand système
linéaire. Une méthode permettant de diminuer la taille du système
linéaire à résoudre dans le cas des splines naturelles
consiste à se fixer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> inconnues <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>z</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>z_0,..,z_{n&#x2d;1}</annotation></semantics></math>
représentant les dérivées <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math>-ième de la spline <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[x_0,x_1]</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_{n&#x2d;1}</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[x_{n&#x2d;1},x_n]</annotation></semantics></math>, 
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>(d&#x2d;1)/2</annotation></semantics></math> inconnues <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>f</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>f_j</annotation></semantics></math>, représentant
la valeur de la dérivée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> variant
de 1 à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>(d&#x2d;1)/2</annotation></semantics></math>. On peut alors écrire le polynome sur l’intervalle
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[x_0,x_1]</annotation></semantics></math> car on connait son développement de Taylor en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math>.
On effectue un changement d’origine (par application répétée
de Horner) en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>x_1</annotation></semantics></math>. On obtient alors le polynome sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>2</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[x_1,x_2]</annotation></semantics></math>
en remplaçant uniquement la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math>-ième par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>z_1</annotation></semantics></math>.
On continue ainsi jusqu’en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_{n&#x2d;1}</annotation></semantics></math>. Le système s’obtient en
calculant la valeur du polynome en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math> et la nullité
des dérivées d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>(d&#x2d;1)/2</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>d/2</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math>. On résoud
le système et on remplace pour avoir les valeurs numériques
des coefficients du polynome.</p>
<!--TOC chapter id="sec278" Développement de Taylor, asymptotiques, 
séries entières, fonctions usuelles-->
</html>
