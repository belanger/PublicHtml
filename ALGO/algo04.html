<!DOCTYPE html>
<html >
<head>
<h1 id="sec39" class="chapter">Chapitre 4  Les générateurs de nombres pseudo-aléatoires.</h1><!--SEC END --><p>
<a id="sec:random"></a>
<a id="hevea_default45"></a>
</p>
<!--TOC section id="sec40" Selon la loi uniforme-->
<h2 id="sec40" class="section">4.1  Selon la loi uniforme</h2><!--SEC END --><p>
Les générateurs d’entiers dans une plage donnée selon la loi
uniforme servent en général de base pour générer des 
nombres aléatoires entiers ou non selon des lois classiques.
Ils doivent à la fois être rapides, avoir une période égale à
la plage donnée et avoir de bonnes propriétés statistiques.</p><p>Xcas utilise un “tiny” Mersenne Twister (de période environ <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>127</mn></msup></mrow><annotation encoding='application/x-tex'>2^{127}</annotation></semantics></math>),
certaines implantations de Giac utilisent un générateur congruentiel.</p>
<!--TOC subsection id="sec41" Les générateurs congruentiels à 1 cran.-->
<h3 id="sec41" class="subsection">4.1.1  Les générateurs congruentiels à 1 cran.</h3><!--SEC END --><p><a id="hevea_default46"></a>
<a id="hevea_default47"></a> 
Etant donnés trois entiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>,</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>a, c</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> on considère la suite
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>a</mi><msub><mi>u</mi> <mi>n</mi></msub><mo>+</mo><mi>c</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>u_{n+1}=au_n+c \pmod m  </annotation></semantics></math>
où on choisit (par exemple) comme représentant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math>
le reste de la division euclidienne par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math>. La valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>u_0</annotation></semantics></math>
est appelée seed en anglais, elle est initialisée usuellement
soit à 0 (ce qui permet de reproduire des bugs dans un programme
dépendant du hasard), soit avec l’horloge système ou tout autre
entrée de l’ordinateur (par exemple périphériques).</p><p>On supposera que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&ne;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a\neq 1</annotation></semantics></math>, le cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a=1</annotation></semantics></math> n’est pas très
intéressant. On a alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub><mo>=</mo><msup><mi>a</mi> <mi>n</mi></msup><msub><mi>u</mi> <mn>0</mn></msub><mo>+</mo><mfrac><mrow><msup><mi>a</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mi>c</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>u_n=a^n u_0 + \frac{a^n&#x2d;1}{a&#x2d;1} c \pmod m </annotation></semantics></math>
On cherche à réaliser une période la plus grande possible
idéalement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math>, mais <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m&#x2d;1</annotation></semantics></math> peut fort bien convenir, et c’est
possible si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> est premier en choisissant 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> générateur du groupe cyclique, car on a alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&ne;</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a\neq 1 \pmod m</annotation></semantics></math> et :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub><mo>=</mo><msup><mi>a</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>+</mo><mfrac><mi>c</mi><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">)</mo><mo>&minus;</mo><mfrac><mi>c</mi><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>u_n=a^n (u_0 + \frac{c}{a&#x2d;1}) &#x2d; \frac{c}{a&#x2d;1}  \pmod m </annotation></semantics></math>
donc la suite est stationnaire ou prend toutes les valeurs sauf <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mi>c</mi><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding='application/x-tex'>&#x2d; \frac{c}{a&#x2d;1} </annotation></semantics></math>.</p><p>Exemple : choisir pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> une puissance de 2 permet d’effectuer
la division euclidienne très rapidement, mais cela a un
inconvénient assez important : les bits de poids faible
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> ont une périodicité très (trop) petite.
Il est alors intéressant de prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><msup><mn>2</mn> <mi>k</mi></msup><mo>&pm;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m=2^k \pm 1</annotation></semantics></math>, parce
que la division euclidienne par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> peut se coder efficacement en base
2, on divise par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>2^k</annotation></semantics></math> (décalage de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> bits) et on ajuste
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mn>2</mn> <mi>k</mi></msup><mo>&pm;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>q</mi><mo>+</mo><mi>r</mi><mo>=</mo><msup><mn>2</mn> <mi>k</mi></msup><mi>q</mi><mo>+</mo><mo stretchy="false">(</mo><mi>r</mi><mo>&pm;</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x=(2^k \pm 1)q+r=2^k q + (r \pm q)</annotation></semantics></math>.
Ainsi pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>k=4</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><msup><mn>2</mn> <mn>4</mn></msup><mo>+</mo><mn>1</mn><mo>=</mo><mn>17</mn></mrow><annotation encoding='application/x-tex'>m=2^4+1=17</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> est premier.
On peut construire une suite de période 16 en choisissant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> générateur
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>17</mn><mi>&Zopf;</mi><msup><mo stretchy="false">)</mo> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>(\mathbb{Z}/17\mathbb{Z})^*</annotation></semantics></math>, par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>a=3</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>c=2</annotation></semantics></math> donne la suite
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>8</mn><mo>,</mo><mn>9</mn><mo>,</mo><mn>12</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>14</mn><mo>,</mo><mn>10</mn><mo>,</mo><mn>15</mn><mo>,</mo><mn>13</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>11</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>0,2,8,9,12,4,14,10,15,13,7,6,3,11,1,5</annotation></semantics></math>.</p><p>On a le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 4</span>  <em>
La suite </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(u_n)</annotation></semantics></math><em> définie ci-dessus est de périodicité maximale </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math><em> si
et seulement si :
</em><ol class="enumerate" type=1><li class="li-enumerate"><em>
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math><em> sont premiers entre eux
</em></li><li class="li-enumerate"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a&#x2d;1</annotation></semantics></math><em> est divisible par tous les facteurs premiers de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math><em>
</em></li><li class="li-enumerate"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a&#x2d;1</annotation></semantics></math><em> est multiple de 4 si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math><em> l’est.
</em></li></ol><em>
</em></div><p>
On observe d’abord que vouloir la périodicité maximale revient
à pouvoir supposer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>u_0=0</annotation></semantics></math>. 
Il est donc nécessaire d’avoir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> premiers entre eux, sinon tous les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> sont multiples du
pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math>. Ensuite, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo><msubsup><mi>p</mi> <mi>i</mi> <mrow><msub><mi>r</mi> <mi>i</mi></msub></mrow></msubsup></mrow><annotation encoding='application/x-tex'>m=\prod p_i^{r_i}</annotation></semantics></math> la
décomposition en facteurs premiers de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> et on raisonne modulo
chaque premier (par le lemme chinois, la périodicité
est le PPCM des périodicités modulo chaque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>p</mi> <mi>i</mi> <mrow><msub><mi>r</mi> <mi>i</mi></msub></mrow></msubsup></mrow><annotation encoding='application/x-tex'>p_i^{r_i}</annotation></semantics></math>). 
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&ne;</mo><mn>1</mn><msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>a\neq 1 \pmod p_i</annotation></semantics></math>
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a&#x2d;1</annotation></semantics></math> est inversible modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>p_i</annotation></semantics></math> donc modulo 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>p</mi> <mi>i</mi> <mrow><msub><mi>r</mi> <mi>i</mi></msub></mrow></msubsup></mrow><annotation encoding='application/x-tex'>p_i^{r_i}</annotation></semantics></math> on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub><mo>=</mo><msup><mi>a</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>+</mo><mfrac><mi>c</mi><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mo stretchy="false">)</mo><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>c</mi></mrow><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding='application/x-tex'>u_n=a^n (u_0 + \frac{c}{a&#x2d;1}) + \frac{&#x2d;c}{a&#x2d;1}   </annotation></semantics></math>
et la valeur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>c</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;c/(a&#x2d;1)</annotation></semantics></math> ne peut pas être atteinte
(ou alors la suite est stationnaire).
Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a&#x2d;1</annotation></semantics></math> doit être divisible par tous les facteurs premiers de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math>
pour avoir la périodicité maximale.
Réciproquement, il faut trouver le premier ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>a</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>r</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>(a^n&#x2d;1)/(a&#x2d;1)=0 \pmod{p^r}</annotation></semantics></math>. On pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a=b+1</annotation></semantics></math>, on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><msup><mi>a</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mi>b</mi></mfrac><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mrow><mo>(</mo><msup><mo/><mi>n</mi></msup><msub><mo/><mi>k</mi></msub><mo>)</mo></mrow><msup><mi>b</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mi>n</mi><mo>+</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mi>b</mi><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>\frac{a^n&#x2d;1}{a&#x2d;1}=\frac{(b+1)^n&#x2d;1}{b} = \sum_{k=1}^n
\left(^n_k\right) b^{k&#x2d;1} = n +\frac{n(n&#x2d;1)}{2}b +...  </annotation></semantics></math>
On sait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>b=a&#x2d;1</annotation></semantics></math> est un multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>, disons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mi>q</mi><mi>p</mi></mrow><annotation encoding='application/x-tex'>b=qp</annotation></semantics></math>, on en déduit que
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><msup><mi>p</mi> <mi>r</mi></msup></mrow><annotation encoding='application/x-tex'>n=p^r</annotation></semantics></math>, on a bien <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>a</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>r</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>(a^n&#x2d;1)/(a&#x2d;1)=0 \pmod{p^r}</annotation></semantics></math>, alors que
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><msup><mi>p</mi> <mrow><mi>r</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>n=p^{r&#x2d;1}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>&ne;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>p\neq 2</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>a</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>a</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>r</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>(a^n&#x2d;1)/(a&#x2d;1)=n \pmod{p^r} \neq 0</annotation></semantics></math>.
Le même calcul pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>p=2</annotation></semantics></math> (prise en compte de la division par 2 de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>n(n&#x2d;1)</annotation></semantics></math>) donne la condition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mi>a</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>b=a&#x2d;1</annotation></semantics></math> est multiple de 4 si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> l’est.</p><p>On trouvera dans Knuth une discussion détaillée du choix de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>m</mi></mrow><annotation encoding='application/x-tex'>a, b, m</annotation></semantics></math>.</p><p>Exemple : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><msup><mn>2</mn> <mn>31</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m=2^{31}&#x2d;1</annotation></semantics></math> est premier, on peut donc construire un
générateur congruentiel de période <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m&#x2d;1</annotation></semantics></math> en choisissant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math>
générateur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>m</mi><msup><mi>&Zopf;</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/m\mathbb{Z}^*</annotation></semantics></math>. Pour en trouver un, on peut tester
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> pris au hasard et voir si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mfrac><mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow><mi>j</mi></mfrac></msup><mo>&ne;</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a^{\frac{m&#x2d;1}{j}} \neq 1 \pmod m</annotation></semantics></math>
pour tous les diviseurs premiers de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m&#x2d;1</annotation></semantics></math>. Par exemple<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">m:=2^31-1;F:=ifactors(b:=m-1); G:=seq(F[2*j],j,0,iquo(size(F)-1,2)) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a:=456783546; for k in G do print(powmod(a,b/k,m)); od 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">r():=return (etat:=irem(a*etat,m)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">etat:=1;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
 initialise l’état du générateur.
Un appel à <code>r()</code> renvoie un entier entre 1 et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m&#x2d;1</annotation></semantics></math>, pour avoir
un g’enérateur pseudo-aléatoire selon la loi uniforme sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]0,1[</annotation></semantics></math>, on tape

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">evalf(r()/m)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
.</p><p>Ainsi <br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">L:=seq(evalf(r()/m),j,1,1000):;histogram(L,0,.05)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

permet de vérifier visuellement si les réels générés sont
bien répartis, ou bien<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">seq(point(evalf(r()/m,r()/m),display=point_point),j,1,1000)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

qui détecte des biais invisibles avec le test précédent, par
exemple pour 

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">a:=7;seq(point(evalf(r()/m,r()/m),display=point_point),j,1,1000)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
.</p>
<!--TOC subsection id="sec42" Récurrence à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> éléments-->
<h3 id="sec42" class="subsection">4.1.2  Récurrence à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> éléments</h3><!--SEC END --><p>
Au lieu d’une récurrence <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>a</mi><msub><mi>u</mi> <mi>k</mi></msub><mo>+</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>u_{k+1}=au_k+c</annotation></semantics></math> on conserve en mémoire
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k+1</annotation></semantics></math> valeurs successives de la suite et on calcule
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>a</mi> <mn>0</mn></msub><msub><mi>u</mi> <mi>n</mi></msub><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mi>k</mi></msub><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>u_{n+k+1} = a_0 u_n+...+a_{k}u_{n+k} \pmod p </annotation></semantics></math>
Si on note <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>U</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>U_n</annotation></semantics></math> le vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(u_n,...,u_{n+k})</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>
la matrice companion du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>a</mi> <mn>1</mn></msub><mi>x</mi><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mi>k</mi></msub><msup><mi>x</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>a_0+a_1x+...+a_kx^k</annotation></semantics></math>,
on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>U</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi>U</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>U_{n+1}=AU_n</annotation></semantics></math>. Rechercher un générateur de période
maximale revient à chercher <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> d’ordre le plus grand possible, donc
les valeurs propres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, i.e. les racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, doivent être
racines de l’unité d’ordre le plus grand possible donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>k</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^k&#x2d;1</annotation></semantics></math>. 
Ce que l’on peut faire en construire un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> irréductible
primitif (cf. la section <a href="#sec%3Agf">16</a> sur la construction de représentation
des corps finis).</p>
<!--TOC subsection id="sec43" Mersenne twister.-->
<h3 id="sec43" class="subsection">4.1.3  Mersenne twister.</h3><!--SEC END --><p>
Ce sont des générateurs plus performants, avec un état interne
en général plus grand, dont l’état initial est généré par
un générateur congruentiel. Ils utilisent une relation
de récurrence qui ressemble aux générateurs
congruentiels, mais au lieu de travailler sur de grands
entiers, on découpe l’entier en mots de taille gérée
par le CPU, et on fait des opérations de type matriciels
avec des opérations bit à bit (ou exclusif par exemple)
au lieu d’opérations arithmétiques.</p>
<!--TOC section id="sec44" Selon plusieurs lois classiques-->
<h2 id="sec44" class="section">4.2  Selon plusieurs lois classiques</h2><!--SEC END --><p>
La méthode générale consiste à calculer la distribution
cumulée de la loi et à prendre la fonction réciproque
d’un réel généré aléatoirement entre 0 et 1 selon
la loi uniforme. Lorsqu’on a un nombre discret de valeurs possibles
pas trop grand et que l’on veut générer plusieurs
nombres selon la même loi, on peut précalculer la distribution cumulée
en chaque valeur, et faire une dichotomie pour trouver
la valeur de la fonction réciproque du nombre aléatoire
généré. Les calculs peuvent être rendus difficiles
par des dépassement de capacité des flottants si on utilise
des méthodes naives pour estimer les fonction de répartition.
On trouvera dans Abramowitz-Stegun diverses formules 
pour initialiser les méthodes de Newton pour inverser les
fonction de répartition courante.</p><p>Il existe aussi quelques cas particuliers où
on peut obtenir plus facilement un réel selon la loi
donnée :
</p><ul class="itemize"><li class="li-itemize">
Pour la loi normale<a id="hevea_default48"></a>, on génère 2 réels <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>,</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>u,d</annotation></semantics></math>
entre 0 et 1, on calcule <br>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mi>log</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></msqrt><mi>cos</mi><mo stretchy="false">(</mo><mn>2</mn><mi>&pi;</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sqrt{&#x2d;2 \log(u)} \cos(2\pi d)</annotation></semantics></math><br>
En effet si on considère un couple de variables qui
suivent une loi normale centrée réduite, la densité de probabilité
au point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x,y)</annotation></semantics></math> (coordonnées cartésiennes) ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>,</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(r,\theta)</annotation></semantics></math> est :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mrow><msup><msqrt><mrow><mn>2</mn><mi>&pi;</mi></mrow></msqrt> <mn>2</mn></msup></mrow></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><msup><mi>y</mi> <mn>2</mn></msup></mrow><mn>2</mn></mfrac></mrow></msup><mspace width="thinmathspace"/><mi>d</mi><mi>x</mi><mspace width="thinmathspace"/><mi>d</mi><mi>y</mi><mo>=</mo><mrow><mo>(</mo><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><msup><mi>r</mi> <mn>2</mn></msup></mrow><mn>2</mn></mfrac></mrow></msup><mi>r</mi><mspace width="thinmathspace"/><mi>d</mi><mi>r</mi><mo>)</mo></mrow><mrow><mo>(</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>&pi;</mi></mrow></mfrac><mspace width="thinmathspace"/><mi>d</mi><mi>&theta;</mi><mo>)</mo></mrow><mo>=</mo><mrow><mo>(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>e</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mi>s</mi><mn>2</mn></mfrac></mrow></msup><mspace width="thinmathspace"/><mi>d</mi><mi>s</mi><mo>)</mo></mrow><mrow><mo>(</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>&pi;</mi></mrow></mfrac><mspace width="thinmathspace"/><mi>d</mi><mi>&theta;</mi><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\frac{1}{\sqrt{2\pi}^2} e^{&#x2d;\frac{x^2+y^2}{2}} \, dx \, dy
=  \left( e^{&#x2d;\frac{r^2}{2}} r  \, dr \right)
\left( \frac{1}{2\pi} \, d\theta \right)
= \left( \frac{1}{2} e^{&#x2d;\frac s2} \, ds \right)
\left( \frac{1}{2\pi} \, d\theta \right) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>r</mi> <mn>2</mn></msup><mo>=</mo><mi>s</mi></mrow><annotation encoding='application/x-tex'>r^2=s</annotation></semantics></math>. Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi></mrow><annotation encoding='application/x-tex'>s</annotation></semantics></math> suit une loi exponentielle (générée
par la réciproque de la distribution cumulée) et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&theta;</mi></mrow><annotation encoding='application/x-tex'>\theta</annotation></semantics></math>
uniforme, les deux sont indépendantes. On écrit 
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>r</mi><mi>cos</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x=r\cos(\theta)</annotation></semantics></math>. On peut pour le même prix
générer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mi>r</mi><mi>sin</mi><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>y=r\sin(\theta)</annotation></semantics></math>. <br>
Pour éviter de calculer
des lignes trigonométriques, on peut aussi tirer
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> uniformément dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math>, accepter le tirage
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><msup><mi>y</mi> <mn>2</mn></msup><mo>&Element;</mo><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>s=x^2+y^2 \in ]0,1]</annotation></semantics></math> et renvoyer deux valeurs
aléatoires selon la loi normale
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><msqrt><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mi>ln</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><mi>s</mi></mfrac></msqrt><mo>,</mo><mspace width="1em"/><mi>y</mi><msqrt><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mi>ln</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><mi>s</mi></mfrac></msqrt></mrow><annotation encoding='application/x-tex'>x \sqrt{\frac{&#x2d;2\ln(s)}{s}}, \quad y \sqrt{\frac{&#x2d;2\ln(s)}{s}}  </annotation></semantics></math>
</li><li class="li-itemize">Pour la loi du <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&chi;</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\chi^2</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> degrés de liberté, 
on fait la somme
des carrés de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> réels aléatoires selon la loi normale
</li><li class="li-itemize">Pour la loi de Student, on fait le quotient d’un réel
selon la loi normale par la racine carrée
d’un réel selon la loi du <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&chi;</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\chi^2</annotation></semantics></math> divisé par le nombre
de degré de liberté
</li><li class="li-itemize">Pour la loi de Fisher, on fait le quotient d’un réel
selon la loi du <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&chi;</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\chi^2</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>k</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>k_1</annotation></semantics></math> degrés de liberté divisé par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>k</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>k_1</annotation></semantics></math> et d’un réel
selon la loi du <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&chi;</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\chi^2</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>k</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>k_2</annotation></semantics></math> degrés de liberté divisé par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>k</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>k_2</annotation></semantics></math>
</li></ul>
<!--TOC chapter id="sec45" Le PGCD de polynômes.-->
</html>
