<!DOCTYPE html>
<html >
<head>
<h1 id="sec208" class="chapter">Chapitre 21  Suites récurrentes et applications</h1><!--SEC END --><p> <a id="sec:rec"></a>
<a id="hevea_default236"></a><a id="hevea_default237"></a>
Cette section comporte une première petite partie sur le calcul
de l’expression exacte de suites récurrences (linéaires), puis
une deuxième partie sur l’intérêt du calcul approché de limites
de suites récurrentes (dont on ne sait en général pas déterminer l’expression
générale).</p>
<!--TOC section id="sec209" Calcul de l’expression des suites récurrentes.-->
<h2 id="sec209" class="section">21.1  Calcul de l’expression des suites récurrentes.</h2><!--SEC END --><p>
Le problème général est l’analogue discret de la recherche de solutions
d’équations différentielles. On ne sait en général pas le résoudre, sauf
pour certaines classes de suites, en particulier celles qui suivent
une récurrence affine.</p>
<!--TOC subsection id="sec210" Récurrence affine-->
<h3 id="sec210" class="subsection">21.1.1  Récurrence affine</h3><!--SEC END --><p><a id="hevea_default238"></a>
<a id="hevea_default239"></a>
On peut toujours se ramener au cas d’une suite vectorielle dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>d</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^d</annotation></semantics></math>
vérifiant un récurrence à un cran :
<a id="eqref_35"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi>v</mi> <mi>n</mi></msub><mo>+</mo><mi>B</mi><mspace width="2em"/><mo stretchy="false">(</mo><mn>35</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> v_{n+1} = A v_n + B 
\qquad (35) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est une matrice indépendante de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> un vecteur qui peut
dépendre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>.
Par exemple pour une suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> récurrente à deux crans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><mi>a</mi><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>b</mi><msub><mi>u</mi> <mi>n</mi></msub><mo>+</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'> u_{n+2}=au_{n+1}+bu_n+c </annotation></semantics></math>
on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>,</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v_n=(u_n,u_{n+1})</annotation></semantics></math> qui vérifie alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mi>b</mi></mtd> <mtd><mi>a</mi></mtd></mtr></mtable><mo>)</mo></mrow><msub><mi>v</mi> <mi>n</mi></msub><mo>+</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center"><mtr><mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mi>c</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> v_{n+1}= \left( \begin{array}{cc} 0 &amp; 1 \\ b &amp; a \end{array}\right) v_n + 
\left( \begin{array}{c}0 \\ c\end{array}\right) </annotation></semantics></math> 
La solution générale de (<a href="#eqref_35">35</a>) est la somme de la solution
de l’équation homogène <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>A</mi><msub><mi>v</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>v_{n+1}=Av_n</annotation></semantics></math> et d’une solution particulière,
solution que l’on sait calculer lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> est combinaison linéaire
d’un produit d’exponentielle par un polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>.
L’équation homogène a pour solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub><mo>=</mo><msup><mi>A</mi> <mi>n</mi></msup><msub><mi>v</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>v_n=A^n v_0</annotation></semantics></math>, où l’expression de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>A^n</annotation></semantics></math>
se calcule sur un corps algébriquement clos par réduction de Jordan
(fonction <code>matpow</code> dans Xcas). On peut aussi utiliser un algorithme
de puissance rapide pour calculer le reste de la division euclidienne
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>A</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>A^n</annotation></semantics></math> par un polynôme annulateur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> (minimal ou caractéristique)
ce qui permet de rester dans le corps des coefficients.</p><p>Le calcul d’une solution particulière dans le cas où 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>=</mo><msup><mi>c</mi> <mi>n</mi></msup><mi>P</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B=c^n P(n)</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> un vecteur à coefficients polynomiaux
de degré au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> se fait en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub><mo>=</mo><msup><mi>c</mi> <mi>n</mi></msup><mi>Q</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v_n=c^n Q(n)</annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est un vecteur de polynôme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> plus la multiplicité
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> comme valeur propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>. En effet, on doit alors résoudre :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>A</mi><msub><mi>v</mi> <mi>n</mi></msub><mo>=</mo><msup><mi>c</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>c</mi><mi>Q</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mi>A</mi><mi>Q</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>c</mi> <mi>n</mi></msup><mi>P</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v_{n+1}&#x2d;Av_n = c^n (c Q(n+1)&#x2d; AQ(n)) = c^n P(n)   </annotation></semantics></math>
soit
<a id="eqref_36"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>c</mi><mi>Q</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mi>A</mi><mi>Q</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>36</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
c Q(n+1)&#x2d; AQ(n) = P(n)
\qquad (36) </annotation></semantics></math>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>q</mi></msubsup><msub><mi>Q</mi> <mi>j</mi></msub><msup><mi>n</mi> <mi>j</mi></msup></mrow><annotation encoding='application/x-tex'>Q(n)=\sum_{j=0}^q Q_j n^j</annotation></semantics></math>, alors le coefficient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mi>q</mi></msup></mrow><annotation encoding='application/x-tex'>n^q</annotation></semantics></math> de cette équation
est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><msub><mi>I</mi> <mi>d</mi></msub><mo>&minus;</mo><mi>A</mi><mo stretchy="false">)</mo><msub><mi>Q</mi> <mi>q</mi></msub><mo>=</mo><msub><mi>P</mi> <mi>q</mi></msub></mrow><annotation encoding='application/x-tex'>(c I_d &#x2d;A)Q_q=P_q</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> n’est pas valeur propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, alors
on peut calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>q</mi></msub></mrow><annotation encoding='application/x-tex'>Q_q</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>q</mi></msub></mrow><annotation encoding='application/x-tex'>P_q</annotation></semantics></math> et en descendant de degré en degré
on peut trouver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> solution de même degré que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> est valeur
propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, la résolution de cette façon
est plus compliquée, il faut séparer les
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q_j</annotation></semantics></math> en deux composantes, l’une sur l’espace caractéristique associé
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> et l’autre sur la somme des autres sous-espaces caractéristiques,
ce qui peut se faire avec l’identité de Bézout, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> un polynôme annulateur
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>c</mi><msup><mo stretchy="false">)</mo> <mi>m</mi></msup><mi>N</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>M(x)=(x&#x2d;c)^m N(x)</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> est la multiplicité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>,
alors il existe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math> tels que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>c</mi><msup><mo stretchy="false">)</mo> <mi>m</mi></msup><mi>U</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>N</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>(x&#x2d;c)^mU(x)+N(x)V(x)=1</annotation></semantics></math>, donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><mi>c</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mi>m</mi></msup><mi>U</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mi>y</mi><mo>+</mo><mi>N</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mi>V</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mi>y</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'> (A&#x2d;cI)^m U(A)y+N(A)V(A)y= y </annotation></semantics></math>
on a écrit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> comme somme de deux vecteurs, le premier dans le noyau de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>N(A)</annotation></semantics></math> et le second dans le noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>&minus;</mo><mi>c</mi><mi>I</mi><msup><mo stretchy="false">)</mo> <mi>m</mi></msup></mrow><annotation encoding='application/x-tex'>(A&#x2d;cI)^m</annotation></semantics></math>. Pour la première
composante on est ramené au cas où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> n’est pas valeur propre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>,
pour la seconde composante, on jordanise puis on travaille composante
par composante, pour chaque composante on aura une équation du type
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo></mrow><annotation encoding='application/x-tex'>c(Q(n+1)&#x2d;Q(n))=</annotation></semantics></math>polynôme connu, équation 
que l’on peut résoudre efficacement avec
la base de Newton (voir section ci-dessous).</p>
<!--TOC subsection id="sec211" Utilisation de la base de Newton si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><msub><mi>I</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>A=I_d</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>c=1</annotation></semantics></math>-->
<h3 id="sec211" class="subsection">21.1.2  Utilisation de la base de Newton si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><msub><mi>I</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>A=I_d</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>c=1</annotation></semantics></math></h3><!--SEC END --><p>
<a id="hevea_default240"></a>
Plutôt que d’exprimer les polynômes dans la base canonique, il est
intéressant d’utiliser la base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo>,</mo><mi>n</mi><mo>,</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>,</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>1,n,n(n&#x2d;1),n(n&#x2d;1)(n&#x2d;2),...,n(n&#x2d;1)...(n&#x2d;p+1)</annotation></semantics></math>.
En effet (<a href="#eqref_36">36</a>) appliqué à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q_{k+1} n(n&#x2d;1)..(n&#x2d;k)</annotation></semantics></math> s’écrit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>Q</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q_{k+1}((n+1)&#x2d;(n&#x2d;k))n(n&#x2d;1)...(n&#x2d;k+1)=Q_{k+1}(k+1)n(n&#x2d;1)...(n&#x2d;k+1)</annotation></semantics></math>, on obtient
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q_{k+1}=P_{k}/(k+1)</annotation></semantics></math>. Le calcul des coefficients <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> s’effectue
efficacement par l’algorithme des différences divisées à partir
du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et de sa valeur en 0,1,2,...,degré<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(P)</annotation></semantics></math>.</p>
<!--TOC section id="sec212" Le point fixe dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math>-->
<h2 id="sec212" class="section">21.2  Le point fixe dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math></h2><!--SEC END --><p><a id="hevea_default241"></a> 
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> une fonction continue sur un intervalle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>=</mo><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>I=[a,b]</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math>, et 
à valeurs dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math> (attention à bien choisir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math> pour que l’image
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> reste dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math>).
On s’intéresse à la suite 
<a id="eqref_37"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><msub><mi>u</mi> <mn>0</mn></msub><mo>&Element;</mo><mi>I</mi><mspace width="2em"/><mo stretchy="false">(</mo><mn>37</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 u_{n+1}=f(u_n), \quad u_0 \in I 
\qquad (37) </annotation></semantics></math>
Supposons que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> converge vers une limite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo>&Element;</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>l \in I</annotation></semantics></math> lorsque
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>n \rightarrow +\infty</annotation></semantics></math>, alors la limite doit vérifier
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'> f(l)=l  </annotation></semantics></math>
puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est continue. On dit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> est un point fixe de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>.
Ceci amène à l’idée d’utiliser ces suites pour résoudre numériquement
l’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>f(x)=x</annotation></semantics></math>. Nous allons donner un théorème permettant
d’assurer que la suite (<a href="#eqref_37">37</a>) converge, et que la limite
est l’unique solution de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'>f(l)=l</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math>.</p><div class="theorem"><span style="font-weight:bold">Définition 41</span>  <em>
On dit que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> est </em><em><span style="font-weight:bold">contractante</span></em><a id="hevea_default242"></a><em> de rapport </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>k&amp;lt;1</annotation></semantics></math><em> sur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em> si
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo>&forall;</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>&Element;</mo><mi>I</mi><mo>,</mo><mspace width="1em"/><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>k</mi><mo stretchy="false">&vert;</mo><mi>y</mi><mo>&minus;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> \forall x,y \in I, \quad |f(y)&#x2d;f(x)| \leq k |y&#x2d;x|  </annotation></semantics></math><em>
</em></div><p>En pratique, les fonctions <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> que l’on considèrera seront continument
dérivables, donc d’après le théorème des accroissements finis
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><mi>&theta;</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'> f(y)&#x2d;f(x)=f&apos;(\theta) (y&#x2d;x), \quad \theta \in [x,y]  </annotation></semantics></math>
ainsi pour vérifier que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est contractante, on étudie la valeur absolue
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>f&apos;</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math>, il suffit de montrer que cette valeur absolue
est strictement inférieure à un réel <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>k&amp;lt;1</annotation></semantics></math> pour conclure (il faut
donc chercher le maximum de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|f&apos;|</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math>. Attention, il s’agit du
maximum de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|f&apos;|</annotation></semantics></math> et pas du maximum de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>f&apos;</annotation></semantics></math>, ce qui revient à chercher
le maximum de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>f&apos;</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>&#x2d;f&apos;</annotation></semantics></math>).</p><p>On a alors le 
</p><div class="theorem"><span style="font-weight:bold">Théorème 42</span>  <em> (du </em><em><span style="font-weight:bold">point fixe</span></em><em>)</em><a id="hevea_default243"></a><em><br>
si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> est contractante de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>=</mo><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>I=[a,b]</annotation></semantics></math><em>
dans </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em> de rapport </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math><em> 
alors la suite (</em><a href="#eqref_37">37</a><em>) converge vers l’unique
solution de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'>f(l)=l</annotation></semantics></math><em> dans </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em>. On a de plus les encadrements :
</em><a id="eqref_38"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mi>k</mi> <mi>n</mi></msup><mo stretchy="false">&vert;</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">&vert;</mo><mo>,</mo><mspace width="1em"/><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo></mrow><mrow><mn>1</mn><mo>&minus;</mo><mi>k</mi></mrow></mfrac><mspace width="2em"/><mo stretchy="false">(</mo><mn>38</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>  
|u_n&#x2d;l| \leq k^n |b&#x2d;a|, \quad
|u_n &#x2d;l | \leq \frac{|u_{n+1}&#x2d;u_n|}{1&#x2d;k} 
\qquad (38) </annotation></semantics></math><em>
</em></div><p>Démonstration : Tout d’abord si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est contractante, on montre à partir
de la définition de la continuité que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est continue. 
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>g(x)=f(x)&#x2d;x</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> est continue, positive en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et négative
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>, il existe donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>l\in[a,b]</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>g(l)=0</annotation></semantics></math> (théorème des
valeurs intermédiaires). 
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> une suite définie par
(<a href="#eqref_37">37</a>). On a alors pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>k</mi><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |u_{n+1}&#x2d;l|=|f(u_n)&#x2d;f(l)| \leq k |u_n&#x2d;l|  </annotation></semantics></math>
Donc par une récurrence évidente :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mi>k</mi> <mi>n</mi></msup><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |u_n&#x2d;l| \leq k^n |u_0&#x2d;l|  </annotation></semantics></math>
ce qui entraine d’ailleurs que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mi>k</mi> <mi>n</mi></msup><mo stretchy="false">&vert;</mo><mi>a</mi><mo>&minus;</mo><mi>b</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|u_n&#x2d;l| \leq k^n |a&#x2d;b|</annotation></semantics></math>.
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>k \in [0,1[ </annotation></semantics></math>, la suite géométrique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>k</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>k^n</annotation></semantics></math> converge vers 0
lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tend vers l’infini, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> tend vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math>.
Notons que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> est unique car si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>l&apos;</annotation></semantics></math> est une autre solution
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>l</mi><mo>&minus;</mo><mi>l</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo>&prime;</mo><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>k</mi><mo stretchy="false">&vert;</mo><mi>l</mi><mo>&minus;</mo><mi>l</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|l&#x2d;l&apos;|=|f(l)&#x2d;f(l&apos;)| \leq k|l&#x2d;l&apos;|</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>k</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mi>l</mi><mo>&minus;</mo><mi>l</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>(1&#x2d;k)|l&#x2d;l&apos;| \leq 0</annotation></semantics></math>,
or <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo>&minus;</mo><mi>k</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>1&#x2d;k&amp;gt;0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>l</mi><mo>&minus;</mo><mi>l</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>|l&#x2d;l&apos;| \geq 0</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>l</mi><mo>&minus;</mo><mi>l</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|l&#x2d;l&apos;|</annotation></semantics></math> doit être nul.
Passons à la preuve de la majoration (<a href="#eqref_38">38</a>) qui est importante
en pratique car elle donne un test d’arrêt de calcul des
termes de la suite récurrente, on écrit pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>m&amp;gt;0</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow></msub><mo>+</mo><msub><mi>u</mi> <mi>m</mi></msub><mo>&minus;</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'> u_n&#x2d;l= u_n &#x2d; u_{n+1} + u_{n+1} &#x2d; u_{n+2} + ... + u_{n+m&#x2d;1}&#x2d; u_{n+m}
+ u_m&#x2d;l  </annotation></semantics></math>
puis on majore avec l’inégalité triangulaire
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mi>j</mi></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>m</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |u_n&#x2d;l| \leq \sum_{j=0}^{m&#x2d;1} |u_{n+j}&#x2d;u_{n+j+1}| + |u_m&#x2d;l|  </annotation></semantics></math>
puis on applique le fait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est contractante de rapport <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msup><mi>k</mi> <mi>j</mi></msup><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>m</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |u_n&#x2d;l| \leq \sum_{j=0}^{m&#x2d;1} k^j |u_{n}&#x2d;u_{n+1}| + |u_m&#x2d;l|  </annotation></semantics></math>
soit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><mn>1</mn><mo>&minus;</mo><msup><mi>k</mi> <mi>m</mi></msup></mrow><mrow><mn>1</mn><mo>&minus;</mo><mi>k</mi></mrow></mfrac><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>m</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |u_n&#x2d;l| \leq \frac{1&#x2d;k^m}{1&#x2d;k} |u_{n}&#x2d;u_{n+1}| + |u_m&#x2d;l|  </annotation></semantics></math>
On fait alors tendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> vers l’infini d’où le résultat.</p><p>Remarque : on peut aussi (voir plus bas le point fixe en dimension
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>) montrer l’existence de la limite en montrant que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(u_n)</annotation></semantics></math> est
une suite de Cauchy. On peut alors faire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>a=&#x2d;\infty</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>b=+\infty</annotation></semantics></math>
dans l’énoncé du théorème. On remarque aussi 
que l’existence d’un point fixe
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> finis ne nécessite pas la contractance
de rapport <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>k&amp;lt;1</annotation></semantics></math>, il suffit de préserver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math>.</p><p>Exemples : 
Cherchons une valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math> par cette méthode.
Il faut d’abord trouver une fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> dont <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math> est un point
fixe, par exemple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>x</mi><mo>+</mo><mn>2</mn></mrow><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding='application/x-tex'> f(x)=\frac{x+2}{x+1} </annotation></semantics></math>
On vérifie que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msqrt><mn>2</mn></msqrt><mo stretchy="false">)</mo><mo>=</mo><msqrt><mn>2</mn></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(\sqrt{2})=\sqrt{2})</annotation></semantics></math>, puis que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>f&apos;=&#x2d;1/(x+1)^2</annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> décroit. On va voir si les hypothèses du théorème du point
fixe s’appliquent sur par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[1,2]</annotation></semantics></math>. Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est décroissante
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">/</mo><mn>3</mn><mo>,</mo><mn>3</mn><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>f([1,2])=[f(2),f(1)]=[4/3,3/2]</annotation></semantics></math> qui est bien inclus dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[1,2] </annotation></semantics></math>.
De plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>f&apos;</annotation></semantics></math> est comprise entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>&#x2d;1/(1+1)^2=&#x2d;1/4</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>9</mn></mrow><annotation encoding='application/x-tex'>&#x2d;1/(2+1)^2=&#x2d;1/9</annotation></semantics></math> donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mn>1</mn><mo stretchy="false">/</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>|f&apos;|&amp;lt;1/4</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est contractante de rapport <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>1/4</annotation></semantics></math>. On peut donc
itérer la suite à partir par exemple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>u_0=1</annotation></semantics></math> et on va converger
vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math> (en s’en rapprochant à chaque cran d’un rapport
inférieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>1/4</annotation></semantics></math>).</p><p>Considérons l’équation en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>&minus;</mo><mi>e</mi><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mo>,</mo><mspace width="1em"/><mi>e</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'> x&#x2d; e \sin(x) =t, \quad e \in [0,1[  </annotation></semantics></math>
c’est l’équation du temps utilisée en astronomie pour trouver la
position d’une planète sur son orbite elliptique (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi></mrow><annotation encoding='application/x-tex'>e</annotation></semantics></math> étant l’excentricité
de l’ellipse).
Il n’y a pas de formule exacte permettant de calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>.
Si on a une valeur numérique pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>, on peut trouver une valeur
numérique approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> par la méthode du point fixe, en réécrivant
l’équation sous la forme 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mo>+</mo><mi>e</mi><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'> f(x)=t+e\sin(x) = x  </annotation></semantics></math>
On observe que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> envoie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>t</mi><mo>&minus;</mo><mi>e</mi><mo>,</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[t&#x2d;e,t+e]</annotation></semantics></math> donc on peut prendre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>=</mo><mo stretchy="false">[</mo><mi>t</mi><mo>&minus;</mo><mi>e</mi><mo>,</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>I=[t&#x2d;e,t+e]</annotation></semantics></math>, de plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>e</mi><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>|f&apos;|\leq e &amp;lt;1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est contractante
de rapport <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>e \in [0,1[</annotation></semantics></math>, le théorème s’applique, il suffit de
prendre une valeur initiale dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>t</mi><mo>&minus;</mo><mi>e</mi><mo>,</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[t&#x2d;e,t+e]</annotation></semantics></math> et d’itérer la suite
jusqu’à obtenir la précision désirée. Par exemple si on veut une
valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>10</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>6</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>10^{&#x2d;6}</annotation></semantics></math> près, il suffira que la différence
entre deux termes successifs de la suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> vérifie
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mn>10</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>6</mn></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> |u_{n+1}&#x2d;u_n| \leq  10^{&#x2d;6} (1&#x2d;e)  </annotation></semantics></math>
on aura alors bien :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo></mrow><mrow><mn>1</mn><mo>&minus;</mo><mi>e</mi></mrow></mfrac><mo>&leq;</mo><msup><mn>10</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>6</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> |u_n&#x2d;x| \leq \frac{|u_{n+1}&#x2d;u_n|}{1&#x2d;e} \leq 10^{&#x2d;6}  </annotation></semantics></math></p><p>Cette méthode n’est pas toujours optimale, car la vitesse de convergence
vers la limite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> est dite “linéaire”, c’est-à-dire 
que le temps de calcul pour
avoir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> décimales est proportionnel à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> (ou
encore il faut effectuer un nombre d’itérations
proportionnel à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, chaque itération faisant
gagner en précision de l’ordre du rapport <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> de contractance). 
En effet, supposons que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>f&apos;</annotation></semantics></math> est continue en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> et que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn><mi>&lt;</mi><mi>L</mi><mo>=</mo><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>0&amp;lt;L=|f&apos;(l)|&amp;lt;1 </annotation></semantics></math>.
Il existe alors un intervalle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>=</mo><mo stretchy="false">[</mo><mi>l</mi><mo>&minus;</mo><mi>&eta;</mi><mo>,</mo><mi>l</mi><mo>+</mo><mi>&eta;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>I=[l&#x2d;\eta,l+\eta]</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mi>I</mi><mo>&Rightarrow;</mo><mfrac><mi>L</mi><mn>2</mn></mfrac><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mi>L</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'>  x \in I \Rightarrow \frac{L}{2} \leq |f&apos;(x)| \leq \frac{1+L}{2}  </annotation></semantics></math>
Le théorème des accroissements finis donne alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>,</mo><mspace width="1em"/><mi>&theta;</mi><mo>&Element;</mo><mo stretchy="false">[</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>,</mo><mi>l</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'> |u_{n+1} &#x2d; l | = |f(u_n)&#x2d;f(l)| = |f&apos;(\theta)| |u_n&#x2d;l|,
\quad \theta \in [u_n,l]  </annotation></semantics></math>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub><mo>&Element;</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>u_0 \in I</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&theta;</mi><mo>&Element;</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>\theta \in I</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>1</mn></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|u_1&#x2d;l| \leq |u_0&#x2d;l|</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>1</mn></msub><mo>&Element;</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>u_1 \in I</annotation></semantics></math>, par récurrence on a pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub><mo>&Element;</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>u_n \in I</annotation></semantics></math> 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mi>L</mi><mn>2</mn></mfrac><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mi>L</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> \frac{L}{2} |u_n&#x2d;l| \leq |u_{n+1} &#x2d; l| \leq \frac{1+L}{2} |u_n&#x2d;l|  </annotation></semantics></math>
on a donc par récurrence 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mrow><mo>(</mo><mfrac><mi>L</mi><mn>2</mn></mfrac><mo>)</mo></mrow> <mi>n</mi></msup><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mrow><mo>(</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mi>L</mi></mrow><mn>2</mn></mfrac><mo>)</mo></mrow> <mi>n</mi></msup><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> \left(\frac{L}{2}\right)^n|u_0&#x2d;l| \leq |u_n&#x2d;l| \leq  
\left( \frac{1+L}{2} \right)^n|u_0&#x2d;l|
 </annotation></semantics></math>
Donc pour avoir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>|u_n&#x2d;l| \leq \epsilon</annotation></semantics></math> il suffit que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mrow><mo>(</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mi>L</mi></mrow><mn>2</mn></mfrac><mo>)</mo></mrow> <mi>n</mi></msup><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&epsi;</mi><mo>&Rightarrow;</mo><mi>n</mi><mo>&geq;</mo><mfrac><mrow><mi>ln</mi><mo stretchy="false">(</mo><mfrac><mi>&epsi;</mi><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow></mfrac><mo stretchy="false">)</mo></mrow><mrow><mi>ln</mi><mo stretchy="false">(</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mi>L</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \left( \frac{1+L}{2} \right)^n|u_0&#x2d;l| \leq \epsilon \Rightarrow
n \geq \frac{\ln(\frac{\epsilon}{|u_0&#x2d;l|})}{\ln( \frac{1+L}{2}) }  </annotation></semantics></math>
et il faut que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mrow><mo>(</mo><mfrac><mi>L</mi><mn>2</mn></mfrac><mo>)</mo></mrow> <mi>n</mi></msup><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&epsi;</mi><mo>&Rightarrow;</mo><mi>n</mi><mo>&geq;</mo><mfrac><mrow><mi>ln</mi><mo stretchy="false">(</mo><mfrac><mi>&epsi;</mi><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>l</mi><mo stretchy="false">&vert;</mo></mrow></mfrac><mo stretchy="false">)</mo></mrow><mrow><mi>ln</mi><mo stretchy="false">(</mo><mfrac><mi>L</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \left(\frac{L}{2}\right)^n |u_0&#x2d;l| \leq \epsilon
\Rightarrow
n \geq \frac{\ln(\frac{\epsilon}{|u_0&#x2d;l|})}{\ln( \frac{L}{2}) }
  </annotation></semantics></math></p><p>On peut accélerer la convergence par la méthode dite de
relaxation<a id="hevea_default244"></a>, au lieu de résoudre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>f(x)=x</annotation></semantics></math>, on résoud
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>&alpha;</mi><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>f(x)+\alpha x=(1+\alpha)x</annotation></semantics></math> soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>&alpha;</mi><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x=(f(x)+\alpha x)/(1+\alpha)</annotation></semantics></math>,
on choisira alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;f&apos;(l)</annotation></semantics></math>.</p><p>Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est suffisamment régulière,
il existe une méthode plus rapide lorsqu’on est proche de la racine ou lorsque
la fonction a des propriétés de convexité, c’est la méthode de Newton
(voir aussi la méthode de la sécante).
Et même si Newton n’est pas applicable, une simple dichotomie
peut être plus efficace si la constante de contractance est 
supérieure à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>1/2</annotation></semantics></math> (y compris prés de la solution de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>f(x)=x</annotation></semantics></math>).
Toutefois la méthode du point fixe reste intéressante si la
constante de contractance est suffisamment petite (par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>0.1</mn></mrow><annotation encoding='application/x-tex'>k=0.1</annotation></semantics></math>
garantit 15 décimales en 15 itérations) et présente l’avantage
de se généraliser en dimension plus grande, cf. la section suivante.</p>
<!--TOC section id="sec213" Le point fixe dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math>-->
<h2 id="sec213" class="section">21.3  Le point fixe dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math></h2><!--SEC END --><p>
Le théorème précédent se généralise. 
</p><div class="theorem"><span style="font-weight:bold">Théorème 43</span>  <em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em> un ensemble
fermé de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math><em> (ou d’un espace métrique complet) tel que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> 
envoie </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em> dans </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em> et tel que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> soit contractante sur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em>
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo>&Exists;</mo><mi>k</mi><mi>&lt;</mi><mn>1</mn><mo>,</mo><mo>&forall;</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>&Element;</mo><mi>I</mi><mo>,</mo><mspace width="1em"/><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>k</mi><mo stretchy="false">&vert;</mo><mi>x</mi><mo>&minus;</mo><mi>y</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\exists k&amp;lt;1, \forall x,y \in I, \quad |f(x)&#x2d;f(y)| \leq k |x&#x2d;y| </annotation></semantics></math><em>
Alors pour tout </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub><mo>&Element;</mo><mi>I</mi></mrow><annotation encoding='application/x-tex'>u_0 \in I</annotation></semantics></math><em>, la suite </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(u_n)</annotation></semantics></math><em> définie par
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>u_{n+1}=f(u_n)</annotation></semantics></math><em> converge vers l’unique solution dans </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em> de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'>f(l)=l</annotation></semantics></math><em>.
</em></div><p>
La démonstration de la convergence est un peu différente de celle 
donnée en
dimension 1, on montre que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(u_n)</annotation></semantics></math> est une suite de Cauchy, car pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&gt;</mi><mi>m</mi></mrow><annotation encoding='application/x-tex'>n&amp;gt;m</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><msub><mi>u</mi> <mi>m</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mi>m</mi></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>u</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msup><mi>k</mi> <mi>m</mi></msup><mfrac><mn>1</mn><mrow><mn>1</mn><mo>&minus;</mo><mi>k</mi></mrow></mfrac><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|u_n&#x2d;u_m| \leq \sum_{j=m}^{n&#x2d;1}|u_{j+1}&#x2d;u_j | 
\leq k^m \frac{1}{1&#x2d;k} |u_1&#x2d;u_0|  </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(u_n)</annotation></semantics></math> est convergente puisque nous sommes dans un fermé 
d’un espace complet. (Cela permet d’ailleurs de généraliser 
l’énoncé donné en dimension 1 au cas où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> est infini).</p><p>La vitesse de convergence est linéaire, la démonstration est
identique à celle de la dimension 1.</p><p>Remarque : 
</p><ul class="itemize"><li class="li-itemize">
L’existence d’un point fixe sans hypothèse de contractance
se généralise si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math> est un convexe compact préservé
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> (théorème
de Brouwer ou de Schauder).
</li><li class="li-itemize">Pour vérifier les hypothèses du théorème dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math>, il suffit de montrer que dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math> la norme triple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>f&apos;</annotation></semantics></math>
subordonnée à la norme choisie dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math> est inférieure
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>k&amp;lt;1</annotation></semantics></math>. Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> linéaire,
cela revient à calculer une norme subordonnée de matrice
et donne lieu à des méthodes itératives alternatives à
l’inversion de matrice, cf. la section <a href="#sec%3Ajacobi">22.9.2</a>.
</li><li class="li-itemize">l’algorithme de recherche
PageRank de google utilise le point fixe, en très grande dimension :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est le nombre de pages Web, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math> est l’ensemble des vecteurs
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math> dont toutes les coordonnées sont positives ou nulles et
dont la somme des coordonnées vaut 1, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est la somme d’un vecteur
constant et du produit du vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> par une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> transposée
d’une matrice stochastique.
</li></ul>
<!--TOC section id="sec214" La méthode de Newton dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math>.-->
<h2 id="sec214" class="section">21.4  La méthode de Newton dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math>.</h2><!--SEC END --><p>
La méthode de Newton est une méthode de résolution de l’équation
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(x)=0</annotation></semantics></math>, attention à la différence avec le théorème du point fixe
qui permet de résoudre numériquement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>f(x)=x</annotation></semantics></math>.
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math> est proche de la racine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>
on peut faire un développement de Taylor à l’ordre 1 de la
fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> f(x)=f(x_0)+(x&#x2d;x_0)f&apos;(x_0)+O((x&#x2d;x_0)^2)  </annotation></semantics></math>
Pour trouver une valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>, on ne garde que la partie
linéaire du développement, on résout :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>&approx;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>r</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> f(r)=0 \approx f(x_0) + (r&#x2d;x_0) f&apos;(x_0)  </annotation></semantics></math>
donc (si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;(x_0)\neq 0</annotation></semantics></math>) :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>r</mi><mo>&approx;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>&minus;</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> r \approx x_0 &#x2d;\frac{f(x_0)}{f&apos;(x_0)} </annotation></semantics></math>
Graphiquement, cela revient à tracer la tangente à la courbe représentative
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> et à chercher où elle coupe l’axe des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>.
On considère donc la suite récurrente définie par une valeur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>u_0</annotation></semantics></math>
proche de la racine et par la relation :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> u_{n+1} = u_n &#x2d;\frac{f(u_n)}{f&apos;(u_n)} </annotation></semantics></math></p><p>Il y a deux théorèmes importants, l’un d’eux prouve que
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>u_0</annotation></semantics></math> est “assez proche” de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> alors la suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> converge vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>,
malheureusement il est difficile de savoir en pratique si on est 
“assez proche” de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>u_0</annotation></semantics></math> pour que ce théorème s’applique. Le second
théorème donne un critère pratique facile à vérifier qui assure
la convergence, il utilise les propriétés de convexité de la fonction.</p><div class="theorem"><span style="font-weight:bold">Théorème 44</span>  <em> </em><a id="hevea_default245"></a><em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> une fonction de classe </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>C^2</annotation></semantics></math><em> (2 fois continument dérivable)
sur un intervalle fermé </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em>. Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math><em> une racine simple de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em>
située à l’intérieur de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em>
(telle que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(r)=0</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;(r)\neq 0</annotation></semantics></math><em>). Alors il existe </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\varepsilon&amp;gt;0</annotation></semantics></math><em>
tel que la suite définie par
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>,</mo><mspace width="1em"/><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'> u_{n+1} = u_n &#x2d;\frac{f(u_n)}{f&apos;(u_n)}, \quad |u_0&#x2d;r| \leq \varepsilon  </annotation></semantics></math><em>
converge vers </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math><em>.</em><p><em>Si on a </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>M</mi></mrow><annotation encoding='application/x-tex'>|f&apos;{&apos;}| \leq M</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mn>1</mn><mo stretchy="false">/</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>m</mi></mrow><annotation encoding='application/x-tex'>|1/f&apos;| \leq m</annotation></semantics></math><em> sur un intervalle 
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>&minus;</mo><mi>&eta;</mi><mo>,</mo><mi>r</mi><mo>+</mo><mi>&eta;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[r&#x2d;\eta,r+\eta]</annotation></semantics></math><em> contenu dans </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em>, alors on peut prendre tout réel
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\varepsilon&amp;gt;0</annotation></semantics></math><em> tel que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mi>&lt;</mi><mn>2</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>m</mi><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\varepsilon &amp;lt; 2/(mM)</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mo>&leq;</mo><mi>&eta;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon \leq \eta</annotation></semantics></math><em>.
</em></p></div><p><span style="font-weight:bold">Démonstration</span> : on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>r</mi><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo>&minus;</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> u_{n+1}&#x2d;r = u_n &#x2d; r &#x2d; \frac{f(u_n)}{f&apos;(u_n)} = 
\frac{(u_n&#x2d;r)f&apos;(u_n)&#x2d;f(u_n)}{f&apos;(u_n)}  </annotation></semantics></math>
En appliquant un développement de Taylor de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> à l’ordre 2,
on obtient pour un réel <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&theta;</mi></mrow><annotation encoding='application/x-tex'>\theta</annotation></semantics></math>
situé entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>0</mn><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>r</mi><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>r</mi><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mfrac><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> 0 = f(r)=f(u_n)+(r&#x2d;u_n) f&apos;(u_n) + (r&#x2d;u_n)^2 \frac{f&apos;{&apos;}(\theta)}{2}  </annotation></semantics></math>
donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mfrac><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> (u_n&#x2d;r)f&apos;(u_n)&#x2d;f(u_n)= (u_n&#x2d;r)^2 \frac{f&apos;{&apos;}(\theta)}{2}  </annotation></semantics></math>
d’où :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mfrac><mn>1</mn><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow></mfrac><mfrac><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> |u_{n+1}&#x2d;r| \leq |u_n&#x2d;r|^2 \frac{1}{|f&apos;(u_n)|} 
\frac{|f&apos;{&apos;}(\theta)|}{2}  </annotation></semantics></math>
On commence par choisir un intervalle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>&minus;</mo><mi>&#x03B5;</mi><mo>,</mo><mi>r</mi><mo>+</mo><mi>&#x03B5;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[r&#x2d;\varepsilon,r+\varepsilon]</annotation></semantics></math>
contenant strictement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> et tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>M</mi></mrow><annotation encoding='application/x-tex'>|f&apos;{&apos;}|&amp;lt;M</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mn>1</mn><mo stretchy="false">/</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mi>&lt;</mi><mi>m</mi></mrow><annotation encoding='application/x-tex'>|1/f&apos;|&amp;lt;m</annotation></semantics></math>
sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>&minus;</mo><mi>&#x03B5;</mi><mo>,</mo><mi>r</mi><mo>+</mo><mi>&#x03B5;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[r&#x2d;\varepsilon,r+\varepsilon]</annotation></semantics></math> (c’est toujours possible car
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>f&apos;{&apos;}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>1/f&apos;</annotation></semantics></math> sont continues au voisinage de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;(r)\neq 0</annotation></semantics></math>).
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> est dans cet intervalle, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&theta;</mi></mrow><annotation encoding='application/x-tex'>\theta</annotation></semantics></math> aussi donc
<a id="eqref_39"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup><mfrac><mrow><mi>M</mi><mi>m</mi></mrow><mn>2</mn></mfrac><mo>&leq;</mo><mfrac><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mi>M</mi><mi>m</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>,</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>39</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>
 |u_{n+1}&#x2d;r| \leq |u_n&#x2d;r|^2 \frac{Mm}{2} \leq  \frac{|u_n&#x2d;r|Mm}{2}
|u_n&#x2d;r|,  
\qquad (39) </annotation></semantics></math>
On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>|u_n&#x2d;r| \leq \varepsilon</annotation></semantics></math>, on diminue si nécessaire
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math> pour avoir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mi>&lt;</mi><mn>2</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>M</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\varepsilon &amp;lt; 2/(Mm)</annotation></semantics></math>, on a alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>k</mi><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>,</mo><mspace width="1em"/><mi>k</mi><mo>=</mo><mfrac><mrow><mi>&#x03B5;</mi><mi>M</mi><mi>m</mi></mrow><mn>2</mn></mfrac><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'> |u_{n+1}&#x2d;r| \leq k |u_n&#x2d;r|, \quad k=\frac{\varepsilon Mm}{2}&amp;lt;1   </annotation></semantics></math>
donc d’une part <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>u_{n+1}</annotation></semantics></math> est encore dans l’intervalle 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>&minus;</mo><mi>&#x03B5;</mi><mo>,</mo><mi>r</mi><mo>+</mo><mi>&#x03B5;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[r&#x2d;\varepsilon,r+\varepsilon]</annotation></semantics></math> 
ce qui permettra de refaire le même raisonnement au rang
suivant, et d’autre part
on a une convergence au moins géométrique vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>.
En fait la convergence est bien meilleure
lorsqu’on est proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> grace au carré dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><msup><mo stretchy="false">&vert;</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>|u_n&#x2d;r|^2</annotation></semantics></math>,
plus précisément, on montre par récurrence que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>r</mi><msup><mo stretchy="false">&vert;</mo> <mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow></msup><msup><mrow><mo>(</mo><mfrac><mrow><mi>M</mi><mi>m</mi></mrow><mn>2</mn></mfrac><mo>)</mo></mrow> <mrow><msup><mn>2</mn> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> |u_n&#x2d;r| \leq |u_0 &#x2d; r|^{2^n} \left( \frac{Mm}{2} \right)^{2^n&#x2d;1}
 </annotation></semantics></math>
il faut donc un nombre d’itérations proportionnel à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\ln(n)</annotation></semantics></math>
pour atteindre une précision donnée.</p><p><span style="font-weight:bold">Remarque :</span> ce théorème se généralise sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{C}</annotation></semantics></math> et même sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math>
(cf. la section suivante).</p><p><span style="font-weight:bold">Exemple :</span> pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math>, on écrit l’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>x^2&#x2d;2=0</annotation></semantics></math>
qui a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math> comme racine simple sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo>=</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>I=[1/2,2]</annotation></semantics></math>, 
on obtient la suite récurrente
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mfrac><mrow><msubsup><mi>u</mi> <mi>n</mi> <mn>2</mn></msubsup><mo>&minus;</mo><mn>2</mn></mrow><mrow><mn>2</mn><msub><mi>u</mi> <mi>n</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'> u_{n+1} = u_n &#x2d; \frac{u_n^2&#x2d;2}{2u_n}  </annotation></semantics></math>
Si on prend <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&eta;</mi><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\eta=1/2</annotation></semantics></math>, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo>=</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding='application/x-tex'>f&apos;=2x</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>f&apos;{&apos;}=2</annotation></semantics></math>
donc on peut prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>M=2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>m=1</annotation></semantics></math> car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mn>1</mn><mo stretchy="false">/</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>|1/f&apos;|\leq 1</annotation></semantics></math> sur 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msqrt><mn>2</mn></msqrt><mo>&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><msqrt><mn>2</mn></msqrt><mo>+</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\sqrt{2}&#x2d;1/2,\sqrt{2}+1/2]</annotation></semantics></math>. On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>m</mi><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2/(mM)=1</annotation></semantics></math>, on peut donc 
prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\varepsilon=1/2</annotation></semantics></math>, la suite convergera pour tout 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub><mo>&Element;</mo><mo stretchy="false">[</mo><msqrt><mn>2</mn></msqrt><mo>&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><msqrt><mn>2</mn></msqrt><mo>+</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'> u_0 \in [\sqrt{2}&#x2d;1/2,\sqrt{2}+1/2]</annotation></semantics></math>.</p><p>Plus généralement, on peut calculer une racine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième d’un réel <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math>
en résolvant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mi>k</mi></msup><mo>&minus;</mo><mi>a</mi></mrow><annotation encoding='application/x-tex'>f(x)=x^k&#x2d;a</annotation></semantics></math> par la méthode de Newton.</p><p>L’inconvénient de ce théorème
est qu’il est difficile de savoir si la valeur de départ qu’on
a choisie se trouve suffisamment près d’une racine pour que
la suite converge. Pour illustrer le phénomène, 
on peut par exemple colorer les points du plan
complexe en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> couleurs selon que la suite définie par la méthode
de Newton converge vers l’une des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> racines d’un polynôme de degré
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> fixé au bout de par exemple 50 itérations (la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>-ième couleur
servant aux origines de suite qui ne semblent pas converger).</p><p>Passons maintenant à un critère très utile en pratique :
</p><div class="theorem"><span style="font-weight:bold">Définition 45</span>  <em> (</em><em><span style="font-weight:bold">convexité</span></em><em>)</em><a id="hevea_default246"></a><em><br>
Une fonction </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> continument dérivable sur un intervalle </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em> de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math><em>
est dite convexe si son graphe est au-dessus de la tangente en tout point
de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em>.
</em></div><p>
Il existe un critère simple permettant de savoir si
une fonction de classe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>C^2</annotation></semantics></math> est convexe :
</p><div class="theorem"><span style="font-weight:bold">Théorème 46</span>  <em>
Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> est </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>C^2</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;{&apos;} \geq 0</annotation></semantics></math><em> sur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em> alors </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> est convexe.
</em></div><p>
<span style="font-weight:bold">Démonstration</span> :<br>
L’équation de la tangente au graphe en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0</annotation></semantics></math> est 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>y</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> y=f(x_0)+f&apos;(x_0)(x&#x2d;x_0)  </annotation></semantics></math>
Soit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> g(x)=f(x)&#x2d;(f(x_0)+f&apos;(x_0)(x&#x2d;x_0))  </annotation></semantics></math>
on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>,</mo><mspace width="1em"/><mi>g</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><mi>g</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>,</mo><mspace width="1em"/><mi>g</mi><mo>&prime;</mo><mo>&prime;</mo><mo>=</mo><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> g(x_0)=0, \quad g&apos;(x)=f&apos;(x)&#x2d;f&apos;(x_0), \quad g&apos;(x_0)=0, 
\quad g&apos;{&apos;}=f&apos;{&apos;} \geq 0  </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>g&apos;</annotation></semantics></math> est croissante, comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>g&apos;(x_0)=0</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>g&apos;</annotation></semantics></math> est négative
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>&lt;</mi><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x&amp;lt;x_0</annotation></semantics></math> et positive pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>&gt;</mi><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x&amp;gt;x_0</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> est décroissante
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>&lt;</mi><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x&amp;lt;x_0</annotation></semantics></math> et croissante pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>&gt;</mi><msub><mi>x</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x&amp;gt;x_0</annotation></semantics></math>. On conclut alors que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>g \geq 0</annotation></semantics></math> puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>g(x_0)=0</annotation></semantics></math>. Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est bien au-dessus
de sa tangente.</p><p>On arrive au deuxième théorème sur la méthode de Newton
</p><div class="theorem"><span style="font-weight:bold">Théorème 47</span>  <em> </em><a id="hevea_default247"></a><em>
Si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>,</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(r)=0, f&apos;(r)&amp;gt;0</annotation></semantics></math><em> et si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;{&apos;} \geq 0</annotation></semantics></math><em> sur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[r,b]</annotation></semantics></math><em> alors
pour tout </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub><mo>&Element;</mo><mo stretchy="false">[</mo><mi>r</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>u_0 \in [r,b]</annotation></semantics></math><em> la suite de la méthode de Newton
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>,</mo></mrow><annotation encoding='application/x-tex'> u_{n+1} = u_n &#x2d;\frac{f(u_n)}{f&apos;(u_n)},   </annotation></semantics></math><em>
est définie, décroissante, minorée par </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math><em> et converge vers 
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math><em>. De plus
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>0</mn><mo>&leq;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo>&leq;</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> 0 \leq u_n &#x2d;r \leq \frac{f(u_n)}{f&apos;(r)}  </annotation></semantics></math><em>
(On prendra garde dans cette estimation aux erreurs en calcul
approché, le calcul de la valeur de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(u_n)</annotation></semantics></math><em>, proche de 0, va typiquement
faire intervenir la différence de deux termes très proches,
d’où perte de précision sur la mantisse)
</em></div><p><span style="font-weight:bold">Démonstration</span> :<br>
On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;{&apos;} \geq 0</annotation></semantics></math> donc si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;(r)&amp;gt;0</annotation></semantics></math> alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;&amp;gt;0</annotation></semantics></math>
sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[r,b]</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est donc strictement croissante sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[r,b]</annotation></semantics></math>
on en déduit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&amp;gt;0</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mi>r</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>]r,b]</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&leq;</mo><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_{n+1} \leq u_n</annotation></semantics></math>.
Comme la courbe représentative de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est au-dessus de la tangente,
on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&geq;</mo><mi>r</mi></mrow><annotation encoding='application/x-tex'>u_{n+1} \geq r</annotation></semantics></math> (car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>u_{n+1}</annotation></semantics></math> est l’abscisse du point
d’intersection de la tangente avec l’axe des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>). 
La suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> est donc décroissante minorée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>, donc convergente
vers une limite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo>&geq;</mo><mi>r</mi></mrow><annotation encoding='application/x-tex'>l\geq r</annotation></semantics></math>. À la limite, on a 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>l</mi><mo>=</mo><mi>l</mi><mo>&minus;</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>&Rightarrow;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> l=l&#x2d;\frac{f(l)}{f&apos;(l)} \Rightarrow f(l)=0  </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo>=</mo><mi>r</mi></mrow><annotation encoding='application/x-tex'>l=r</annotation></semantics></math> car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&amp;gt;0</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mi>r</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>]r,b]</annotation></semantics></math>.</p><p>Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(u_n)</annotation></semantics></math> est décroissante, on a bien <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn><mo>&leq;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi></mrow><annotation encoding='application/x-tex'>0 \leq u_n &#x2d;r</annotation></semantics></math>,
pour montrer l’autre inégalité, on applique le théorème
des accroissements finis, il existe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&theta;</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mi>r</mi><mo>,</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\theta \in [r,u_n]</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> f(u_n)&#x2d;f(r)=(u_n&#x2d;r)f&apos;(\theta)  </annotation></semantics></math>
comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(r)=0</annotation></semantics></math>, on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo>=</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&theta;</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> u_n&#x2d;r = \frac{f(u_n)}{f&apos;(\theta)}  </annotation></semantics></math>
et la deuxième inégalité du théorème
en découle parce que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>f&apos;</annotation></semantics></math> est croissante.</p><p><span style="font-weight:bold">Variantes</span> :<br>
Il existe des variantes, par exemple si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;(r)&amp;lt;0</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;{&apos;} \geq 0</annotation></semantics></math>
sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>r</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,r]</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo>&leq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f&apos;{&apos;} \leq 0</annotation></semantics></math>, on considère <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>f</mi></mrow><annotation encoding='application/x-tex'>g=&#x2d;f</annotation></semantics></math>.</p><p><span style="font-weight:bold">Application</span> :<br>
On peut calculer la valeur approchée de la 
racine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième d’un réel <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>a&amp;gt;0</annotation></semantics></math> en appliquant ce deuxième
théorème. En effet si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>a&amp;gt;0</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mi>k</mi></msup><mo>&minus;</mo><mi>a</mi></mrow><annotation encoding='application/x-tex'>x^k&#x2d;a</annotation></semantics></math> est 2 fois continument dérivable et 
de dérivée première <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><msup><mi>x</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>kx^{k&#x2d;1} </annotation></semantics></math> et
seconde <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mi>x</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>2</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>k(k&#x2d;1)x^{k&#x2d;2}</annotation></semantics></math> strictement positives sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mo>&ast;</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^{+\ast}</annotation></semantics></math> (car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&geq;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>k \geq 2</annotation></semantics></math>).
Il suffit donc de prendre une valeur de départ <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>u_0</annotation></semantics></math> plus grande que
la racine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième, par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo>+</mo><mi>a</mi><mo stretchy="false">/</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>1+a/k</annotation></semantics></math> (en effet
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo stretchy="false">/</mo><mi>k</mi><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><mo>&geq;</mo><mn>1</mn><mo>+</mo><mi>k</mi><mi>a</mi><mo stretchy="false">/</mo><mi>k</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi></mrow><annotation encoding='application/x-tex'>(1+a/k)^k \geq 1+k a/k=1+a</annotation></semantics></math>).
En appliquant l’inégalité du théorème, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>0</mn><mo>&leq;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mroot><mi>a</mi><mi>k</mi></mroot><mo>&leq;</mo><mfrac><mrow><msubsup><mi>u</mi> <mi>n</mi> <mi>k</mi></msubsup><mo>&minus;</mo><mi>a</mi></mrow><mrow><mi>k</mi><msup><mroot><mi>a</mi><mi>k</mi></mroot> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo>&leq;</mo><mfrac><mrow><msubsup><mi>u</mi> <mi>n</mi> <mi>k</mi></msubsup><mo>&minus;</mo><mi>a</mi></mrow><mrow><mi>k</mi><mi>a</mi></mrow></mfrac><mroot><mi>a</mi><mi>k</mi></mroot><mo>&leq;</mo><mfrac><mrow><msubsup><mi>u</mi> <mi>n</mi> <mi>k</mi></msubsup><mo>&minus;</mo><mi>a</mi></mrow><mrow><mi>k</mi><mi>a</mi></mrow></mfrac><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mi>a</mi><mi>k</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 0 \leq u_n &#x2d; \sqrt[k]{a} \leq  
\frac{u_n^k &#x2d; a}{k\sqrt[k]{a}^{k&#x2d;1} }
\leq \frac{u_n^k&#x2d;a}{ka}  \sqrt[k]{a}
\leq \frac{u_n^k&#x2d;a}{ka} (1+\frac{a}{k})
 </annotation></semantics></math>
Pour avoir une valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mroot><mi>a</mi><mi>k</mi></mroot></mrow><annotation encoding='application/x-tex'>\sqrt[k]{a}</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math> près,
on peut donc choisir comme test d’arrêt 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mi>u</mi> <mi>n</mi> <mi>k</mi></msubsup><mo>&minus;</mo><mi>a</mi><mo>&leq;</mo><mfrac><mrow><mi>k</mi><mi>a</mi></mrow><mrow><mn>1</mn><mo>+</mo><mfrac><mi>a</mi><mi>k</mi></mfrac></mrow></mfrac><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'> u_n^k &#x2d;a \leq \frac{ka}{1+\frac{a}{k}} \varepsilon  </annotation></semantics></math>
Par exemple pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math>, le test d’arrêt serait 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>u</mi> <mi>n</mi> <mn>2</mn></msubsup><mo>&minus;</mo><mn>2</mn><mo>&leq;</mo><mn>2</mn><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>u_n^2&#x2d;2 \leq 2 \varepsilon</annotation></semantics></math>.</p>
<!--TOC section id="sec215" La méthode de Newton dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math>.-->
<h2 id="sec215" class="section">21.5  La méthode de Newton dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math>.</h2><!--SEC END --><p>
Le premier énoncé du cas de la dimension 1 se généralise en :
</p><div class="theorem"><span style="font-weight:bold">Théorème 48</span>  <em> </em><a id="hevea_default248"></a><em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> une fonction de classe </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>C^2</annotation></semantics></math><em> (2 fois continument dérivable)
sur un fermé </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em> de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math><em>. Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math><em> une racine simple de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em>
située à l’intérieur de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em>
(telle que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(r)=0</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mo>&PartialD;</mo> <mi>j</mi></msub><msub><mi>f</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f&apos;(r)=(\partial_j f_i)(r)</annotation></semantics></math><em> inversible). 
Alors il existe </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\varepsilon&amp;gt;0</annotation></semantics></math><em>
tel que la suite définie par
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mo stretchy="false">(</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><mo stretchy="false">&vert;</mo><msub><mi>u</mi> <mn>0</mn></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'> u_{n+1} = u_n &#x2d;(f&apos;(u_n) )^{&#x2d;1}f(u_n), \quad |u_0&#x2d;r| \leq \varepsilon  </annotation></semantics></math><em>
converge vers </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math><em>.</em><p><em>Si on a </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>M</mi></mrow><annotation encoding='application/x-tex'>|f&apos;{&apos;}| \leq M</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>f</mi><mo>&prime;</mo><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>m</mi></mrow><annotation encoding='application/x-tex'>|(f&apos;)^{&#x2d;1}| \leq m</annotation></semantics></math><em> sur une boule
centré en </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math><em> de rayon </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&eta;</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\eta&amp;gt;0</annotation></semantics></math><em> contenue dans </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi></mrow><annotation encoding='application/x-tex'>I</annotation></semantics></math><em>, alors on peut prendre tout réel
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>\varepsilon&amp;gt;0</annotation></semantics></math><em> tel que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mi>&lt;</mi><mn>2</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>m</mi><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\varepsilon &amp;lt; 2/(mM)</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mo>&leq;</mo><mi>&eta;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon \leq \eta</annotation></semantics></math><em>.
</em></p></div><p>
La démonstration est calquée sur la dimension 1, mais il faut
prendre le reste intégral dans la formule de Taylor
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>r</mi><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo>&minus;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> u_{n+1}&#x2d;r = u_n &#x2d; r &#x2d; f&apos;(u_n)^{&#x2d;1} f(u_n) = 
f&apos;(u_n)^{&#x2d;1} (f&apos;(u_n)(u_n&#x2d;r)&#x2d;f(u_n) )  </annotation></semantics></math>
puis on applique Taylor le long du segment <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>r</mi><mo>,</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[r,u_n]</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mn>0</mn><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>r</mi><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>r</mi><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>&theta;</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>r</mi><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mspace width="thinmathspace"/><mi>d</mi><mi>&theta;</mi></mrow><annotation encoding='application/x-tex'> 0 = f(r)=f(u_n)+ f&apos;(u_n) (r&#x2d;u_n)+  \int_0^1 (1&#x2d;\theta)(r&#x2d;u_n)
f&apos;{&apos;}(r+\theta (u_n&#x2d;r)) (r&#x2d;u_n) \, d\theta  </annotation></semantics></math>
donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>r</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>r</mi><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mrow><mo>(</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>&theta;</mi><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mi>&theta;</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="thinmathspace"/><mi>d</mi><mi>&theta;</mi><mo>)</mo></mrow><mo stretchy="false">(</mo><mi>r</mi><mo>&minus;</mo><msub><mi>u</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>u_{n+1}&#x2d;r =&#x2d;f&apos;(u_n)^{&#x2d;1}  (r&#x2d;u_n) 
\left(\int_0^1 (1&#x2d;\theta)f&apos;{&apos;}(r+\theta (u_n&#x2d;r)) \, d\theta \right) (r&#x2d;u_n)   </annotation></semantics></math>
et on en déduit (<a href="#eqref_39">39</a>) et on conclut de même en
remplaçant intervalle centré en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> de rayon <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math>
par boule de rayon <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'>\varepsilon</annotation></semantics></math>.</p><p>Remarque : la convergence “numérique” (au sens du calcul en
flottant) de la suite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> ne suffit pas à montrer l’existence
d’une racine proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math>. Une méthode de preuve alternative
au calcul des constantes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> consiste
à trouver un rectangle ou une boule autour de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> préservée
par l’application <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&rightarrow;</mo><mi>x</mi><mo>&minus;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x\rightarrow x&#x2d;f&apos;(x)^{&#x2d;1} f(x)</annotation></semantics></math>.</p>
<!--TOC section id="sec216" Calcul approché des racines complexes simples-->
<h2 id="sec216" class="section">21.6  Calcul approché des racines complexes simples</h2><!--SEC END --><p> 
<a id="hevea_default249"></a> <a id="hevea_default250"></a> <a id="sec:proot"></a>
La section précédente nous a montré qu’on pouvait
se ramener à la recherche de racines simples, ce qui 
donne envie d’essayer la méthode de Newton. On a malheureusement
rarement la possibilité de pouvoir démontrer qu’à partir d’une valeur
initiale donnée, la méthode de Newton converge, 
parce que les racines peuvent être complexes, et même si elles
sont réelles, on n’a pas forcément de résultat sur la convexité
du polynôme (cf. cependant une application des suites de
Sturm qui permet de connaitre le signe
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;{&apos;}</annotation></semantics></math> sur un intervalle sans le factoriser).</p><p>Par contre, on peut montrer à postériori des estimations sur la
distance entre une racine approchée et la racine la plus proche
d’un polynôme, plus précisément cette distance est inférieure
ou égale au degré du polynôme multiplié par le module
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">/</mo><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P/P&apos;</annotation></semantics></math> en la racine approchée (<a href="#sec%3Aautres_algorithmes">7.3</a>).</p><p>On effectue donc souvent des itérations de Newton, en partant de
0.0, en espérant s’approcher suffisamment d’une racine pour que
le théorème de convergence théorique s’applique. On se fixe
un nombre maximal d’itérations, si on le dépasse on prend alors
une valeur initiale aléatoire complexe et on recommence.</p><p>Une fois une racine déterminée, on l’élimine en calculant
le quotient euclidien <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>&minus;</mo><mi>r</mi></mrow><annotation encoding='application/x-tex'>X&#x2d;r</annotation></semantics></math> (par l’algorithme de Horner),
puis on calcule les racines du quotient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> (qui sont des racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>).</p><p>Un problème pratique apparait alors, c’est que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> n’est pas exact
donc le quotient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> non plus, au fur et à mesure du calcul des
racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, on perd de plus en plus de précision.
Il existe une amélioration simple, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>r&apos;</annotation></semantics></math> est une racine
approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>, alors elle est racine approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
et on a toutes les chances qu’elle soit suffisamment proche
d’une racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> pour que le théorème s’applique, on
effectue alors 1 ou 2 itérations de Newton avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>r&apos;</annotation></semantics></math> mais pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
(et non <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>) afin d’améliorer sa précision comme racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.</p><p>Une méthode de calcul plus stable utilise la recherche des valeurs
propres de la matrice companion en double précision, 
puis affine par la méthode de
Newton pour obtenir des valeurs approchées multi-précision,
c’est ce que fait <code>proot</code>, par exemple <code>proot(x^3+x+1,50)</code>.
Il existe aussi un algorithme de recherche de racines
dû à Schönhage dont la convergence
est garantie, cet algorithme est implémenté dans PARI (voir
la thèse de Xavier Gourdon et l’article Splitting circle method de Wikipedia)
et est appelé par Xcas pour des polynômes mals conditionnés.</p><p>Enfin, on peut appliquer directement la méthode de Newton pour
trouver dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Copf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{C}^n</annotation></semantics></math> toutes les racines simultanément, c’est la
méthode de <span style="font-weight:bold">Durand-Kerner, Weierstrass</span><a id="hevea_default251"></a>.
On pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>g</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>z</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>g_x(z)=\prod_{i=1}^n (x&#x2d;z_i)</annotation></semantics></math>, il s’agit de résoudre en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>g</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>g_x(z)=P(x)</annotation></semantics></math>. On a a l’ordre 1 en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>g</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo>+</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>g</mi> <mi>x</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>w</mi> <mi>i</mi></msub><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>i</mi></mrow></munder><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>w</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>g_x(z+w)=g_x(z) &#x2d; \sum_{i=1}^n w_i \prod_{j \neq i} (x&#x2d;z_j) +O(w^2)
=P(x) </annotation></semantics></math>
pour trouver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>w_i</annotation></semantics></math>, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>z</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x=z_i</annotation></semantics></math>, on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>i</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>z</mi> <mi>i</mi></msub><mo>&minus;</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><msub><mi>w</mi> <mi>i</mi></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>z</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>&#x2d;\prod_{j \neq i}(z_i&#x2d;z_j) w_i = P(z_i) </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>z</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>i</mi></mrow></munder><mo stretchy="false">(</mo><msub><mi>z</mi> <mi>i</mi></msub><mo>&minus;</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>w_i=&#x2d;\frac{P(z_i)}{\prod_{j \neq i}(z_i&#x2d;z_j)} </annotation></semantics></math>
On peut aussi calculer le produit du dénominateur en effectuant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>g</mi> <mi>x</mi></msub><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>z</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>g_x&apos;(z_i)</annotation></semantics></math> (la dérivée porte sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>). 
On retrouve la méthode de Newton à une variable
où la dérivée du polynôme au dénominateur est remplacée 
par la valeur approchée du polynôme.
D’où le programme
</p><pre class="verbatim">dw(P,N,eps):={ // Weierstrass, Durand-Kerner polynomial rooter
  local l,v,w,n,j,k,q,q1;
  P:=P/lcoeff(P);
  n:=degree(P);
  assume(l,symbol);
  v:=seq(exp(i*l/n*2.0*pi),l,0,n-1); w:=v;
  for k from 1 to N do
    q:=pcoeff(v);
    q1:=q';
    for j from 0 to n-1 do
      w[j]:=v[j]-horner(P,v[j])/horner(q1,v[j]);
    od;
    if (l2norm(w-v)&lt;eps*l2norm(v))
      return w;
    v:=w;
  od;
  retourne "max iter reached";
}:;
</pre><p>
Par exemple <code>dw(x^3+x+1,100,1e-10)</code> renvoie des valeurs
approchées des racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^3+x+1</annotation></semantics></math>.</p><p>Si on s’intéresse seulement à la racine de module maximal d’un
polynôme, on peut
en trouver une estimation assez simplement en appliquant la méthode
de la puissance à la matrice companion du polynôme.
On peut améliorer la précision d’une racine
par des itérations inverses ou par la méthode de Newton en une
variable.</p>
<!--TOC section id="sec217" Méthodes de gradient (sans contrainte)-->
<h2 id="sec217" class="section">21.7  Méthodes de gradient (sans contrainte)</h2><!--SEC END --><p>
Il s’agit ici de minimiser une fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> d’un ouvert <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^n</annotation></semantics></math> 
à valeurs dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Ropf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{R}</annotation></semantics></math>. Lorsque la fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est
suffisamment régulière sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math>, une condition nécessaire
en un extremum local de l’ouvert est que la différentielle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mi>f</mi></mrow><annotation encoding='application/x-tex'>df</annotation></semantics></math>
s’annulle. Réciproquement, la recherche d’une solution de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(x)=0</annotation></semantics></math>
peut se ramener à minimiser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><mi>f</mi><msup><mo stretchy="false">&Vert;</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\|f\|^2</annotation></semantics></math>.
Les méthodes de gradient en dimension 2 peuvent se comprendre 
à partir de la représentation des lignes
de niveau de la fonction. Le long de la tangente à une ligne
de niveau <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> reste constant (la tangente est dans le noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mi>f</mi></mrow><annotation encoding='application/x-tex'>df</annotation></semantics></math>),
si on est en un point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> de la ligne de niveau,
intuitivement suivre la direction perpendiculaire à la ligne de niveau
devrait permettre de faire diminuer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> efficacement, c’est la ligne de
plus grande pente choisie par l’eau pour s’écouler vers le bas le
plus rapidement possible. Ceci n’est toutefois pas intrinsèque mais
dépendant du produit scalaire choisi, toutefois si on ne choisit pas la
direction du gradient, on choisira une direction de descente <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi></mrow><annotation encoding='application/x-tex'>w</annotation></semantics></math> telle
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>d_vf(w)&amp;lt;0</annotation></semantics></math>. Pour le gradient on a bien
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mo>&Del;</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>&lt;</mi><mo>&Del;</mo><mi>f</mi><mo stretchy="false">&vert;</mo><mo>&Del;</mo><mi>f</mi><mi>&gt;</mi><mi>&lt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>d_vf(&#x2d;\nabla f)=&#x2d;&amp;lt;\nabla f|\nabla f&amp;gt;&amp;lt;0 </annotation></semantics></math>
Une fois la direction de descente choisie, il faut déterminer quelle
distance parcourir dans cette direction, c’est le pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math> et le
nouveau <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> s’obtient par la formule
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mover><mi>v</mi><mo stretchy="false">&tilde;</mo></mover><mo>=</mo><mi>v</mi><mo>+</mo><mi>&rho;</mi><mi>w</mi><mo>=</mo><mi>v</mi><mo>&minus;</mo><mi>&rho;</mi><msub><mo>&Del;</mo> <mi>v</mi></msub><mi>f</mi></mrow><annotation encoding='application/x-tex'>\tilde{v}=v + \rho w = v&#x2d;\rho \nabla_v f </annotation></semantics></math>
pour la méthode de gradient. Plusieurs choix sont possibles pour
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math>
</p><ul class="itemize"><li class="li-itemize">
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math> est fixé une fois pour toutes, c’est le gradient à
pas constant, le cout d’une itération est minimal.
</li><li class="li-itemize">on détermine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math> pour minimiser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> le long de la
direction, c’est le gradient à pas optimial, le cout d’une
iteration peut être important car il faut minimiser une fonction
d’une variable
</li><li class="li-itemize">on détermine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math> pour faire diminuer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> un peu et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><mo>&Del;</mo><mi>f</mi><mo stretchy="false">&Vert;</mo></mrow><annotation encoding='application/x-tex'>\|
  \nabla f\|</annotation></semantics></math> suffisamment pour assurer la convergence. Les conditions
de Wolfe permettent de préciser ces objectifs. 
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn><mi>&lt;</mi><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><mi>&lt;</mi><msub><mi>&#x03B5;</mi> <mn>2</mn></msub><mi>&lt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>0&amp;lt;\varepsilon_1&amp;lt;\varepsilon_2&amp;lt;1</annotation></semantics></math> fixés (par exemple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><mo>=</mo><mn>1</mn><mi>e</mi><mo>&minus;</mo><mn>4</mn><mo>,</mo><msub><mi>&#x03B5;</mi> <mn>2</mn></msub><mo>=</mo><mn>0.99</mn></mrow><annotation encoding='application/x-tex'>\varepsilon_1=1e&#x2d;4, \varepsilon_2=0.99</annotation></semantics></math>)
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>&rho;</mi><mi>w</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>&leq;</mo></mtd> <mtd><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><mi>&rho;</mi><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>,</mo></mtd></mtr> <mtr><mtd><mn>0</mn><mo>&leq;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>d</mi> <mrow><mi>v</mi><mo>+</mo><mi>&rho;</mi><mi>w</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>&leq;</mo></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>&#x03B5;</mi> <mn>2</mn></msub><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} f(v+\rho w) &amp;\leq&amp; f(v) +\varepsilon_1 \rho d_vf(w) ,\\
0 \leq &#x2d;d_{v+\rho w}f(w) &amp;\leq&amp; &#x2d;\varepsilon_2 d_vf(w)
 \end{matrix} </annotation></semantics></math>
</li></ul><div class="theorem"><span style="font-weight:bold">Proposition 49</span>  <em>
Les conditions de Wolfe permettent d’assurer la convergence d’une
suite itérative </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>v</mi> <mi>k</mi></msub><mo>+</mo><msub><mi>&rho;</mi> <mi>k</mi></msub><msub><mi>w</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>v_{k+1}=v_k+\rho_k w_k</annotation></semantics></math><em> si la direction de descente
est “suffisante”, plus précisément si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> est </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mn>1</mn></msup></mrow><annotation encoding='application/x-tex'>C^1</annotation></semantics></math><em> de dérivée
lipschitizienne et bornée inférieurement, si on pose
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>cos</mi><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>&lt;</mi><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mi>&gt;</mi></mrow><mrow><mo stretchy="false">&Vert;</mo><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&Vert;</mo><mo stretchy="false">&Vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mo stretchy="false">&Vert;</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\cos(\theta_k)=\frac{&amp;lt;\nabla f(v_k)|w_k&amp;gt;}{\| \nabla f(v_k)\| \|w_k\|} </annotation></semantics></math><em>
alors la série
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo><mi>cos</mi><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mi>k</mi></msub><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">&Vert;</mo><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><msup><mo stretchy="false">&Vert;</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'> \sum \cos(\theta_k)^2 \| \nabla f(v_k)\|^2 </annotation></semantics></math><em> converge.
Ainsi si la direction de descente forme un angle minimal avec la
tangente à la courbe de niveau (en dimension 2), </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>cos</mi><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mi>k</mi></msub><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\cos(\theta_k)^2</annotation></semantics></math><em>
est borné indépendamment de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo><mo stretchy="false">&Vert;</mo><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><msup><mo stretchy="false">&Vert;</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\sum \|  \nabla f(v_k)\|^2</annotation></semantics></math><em>
est convergente donc le gradient de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em> tend vers 0.
</em></div><p>
Preuve : on a avec la deuxième condition de Wolfe
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mi>&gt;</mi><mo>=</mo><msub><mi>d</mi> <mrow><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>&geq;</mo><msub><mi>&#x03B5;</mi> <mn>2</mn></msub><msub><mi>d</mi> <mrow><msub><mi>v</mi> <mi>k</mi></msub></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><msub><mi>w</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>&#x03B5;</mi> <mn>2</mn></msub><mi>&lt;</mi><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;\nabla f(v_{k+1})|w_k&amp;gt;=d_{v_{k+1}}f(w_k) 
\geq \varepsilon_2 d_{v_k}f(w_k)= \varepsilon_2&amp;lt;\nabla f(v_k)|w_k&amp;gt; </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mi>&gt;</mi><mspace width="mediummathspace"/><mo>&geq;</mo><mo stretchy="false">(</mo><msub><mi>&#x03B5;</mi> <mn>2</mn></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>&lt;</mi><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;\nabla f(v_{k+1})&#x2d;\nabla f(v_k)|w_k&amp;gt; \ \geq (\varepsilon_2&#x2d;1) &amp;lt;\nabla f(v_k)|w_k&amp;gt; </annotation></semantics></math>
Par Cauchy-Schwartz et en notant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>M_2</annotation></semantics></math> la constante de Lipschitz de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&Del;</mo><mi>f</mi></mrow><annotation encoding='application/x-tex'>\nabla f</annotation></semantics></math>
le membre de gauche est plus petit que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&Vert;</mo><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&Vert;</mo><mo stretchy="false">&Vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mo stretchy="false">&Vert;</mo><mo>&leq;</mo><msub><mi>M</mi> <mn>2</mn></msub><mo stretchy="false">&Vert;</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">&Vert;</mo><mo stretchy="false">&Vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mo stretchy="false">&Vert;</mo><mo>=</mo><msub><mi>M</mi> <mn>2</mn></msub><msub><mi>&rho;</mi> <mi>k</mi></msub><mo stretchy="false">&Vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><msup><mo stretchy="false">&Vert;</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\| \nabla f(v_{k+1})&#x2d;\nabla f(v_k) \| \| w_k \| \leq 
M_2\|v_{k+1}&#x2d;v_k\| \| w_k\| = M_2 \rho_k \| w_k \|^2 </annotation></semantics></math>
Donc
<a id="eqref_40"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>&#x03B5;</mi> <mn>2</mn></msub><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>&lt;</mi><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mi>&gt;</mi><mo>&leq;</mo><msub><mi>M</mi> <mn>2</mn></msub><msub><mi>&rho;</mi> <mi>k</mi></msub><mo stretchy="false">&Vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><msup><mo stretchy="false">&Vert;</mo> <mn>2</mn></msup><mspace width="2em"/><mo stretchy="false">(</mo><mn>40</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 (\varepsilon_2&#x2d;1)&amp;lt;\nabla f(v_k)|w_k&amp;gt; \leq M_2 \rho_k \| w_k \|^2
\qquad (40) </annotation></semantics></math>
On considère ensuite la série de terme général
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(v_{k})&#x2d;f(v_{k+1})</annotation></semantics></math> qui est à terme positif, donc convergente
(elle ne peut tendre vers l’infini car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est bornée
inférieurement).
La première condition de Wolfe donne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mo>&geq;</mo><mspace width="mediummathspace"/><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><msub><mi>&rho;</mi> <mi>k</mi></msub><mi>&lt;</mi><mo>&minus;</mo><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><mi>&gt;</mi></mrow><annotation encoding='application/x-tex'>f(v_{k})&#x2d;f(v_{k+1})  \ \geq  \ \varepsilon_1 \rho_k &amp;lt;&#x2d;\nabla
f(v_k)|w_k&amp;gt;  </annotation></semantics></math>
puis (<a href="#eqref_40">40</a>) :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>&geq;</mo><mspace width="mediummathspace"/><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msub><mi>&#x03B5;</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mi>&lt;</mi><mo>&Del;</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><msup><mi>&gt;</mi> <mn>2</mn></msup><mfrac><mn>1</mn><mrow><msub><mi>M</mi> <mn>2</mn></msub><mo stretchy="false">&Vert;</mo><msub><mi>w</mi> <mi>k</mi></msub><msup><mo stretchy="false">&Vert;</mo> <mn>2</mn></msup></mrow></mfrac><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>f(v_{k})&#x2d;f(v_{k+1})  \geq \ 
\varepsilon_1  (1&#x2d;\varepsilon_2)&amp;lt;\nabla f(v_k)|w_k&amp;gt;^2\frac{1}{M_2  \|  w_k \|^2} 
 \geq 0  </annotation></semantics></math>
d’où le résultat.</p><p>L’existence de pas de Wolfe se montre en considérant le max <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> des
pas vérifiant la première condition de Wolfe
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>&rho;</mi><mi>w</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><mi>&rho;</mi><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(v+\rho w) \leq f(v) +\varepsilon_1 \rho d_vf(w)  </annotation></semantics></math>
C’est bien un max si la fonction
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est bornée inférieurement. On a alors l’égalité pour le pas
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> (par passage à la limite des deux cotés de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>)
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>r</mi><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><mi>r</mi><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(v+r w) = f(v) +\varepsilon_1 r d_vf(w)  </annotation></semantics></math>
et l’inégalité dans l’autre sens pour un pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi><mi>&gt;</mi><mi>r</mi></mrow><annotation encoding='application/x-tex'>\rho&amp;gt;r</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>&rho;</mi><mi>w</mi><mo stretchy="false">)</mo><mi>&gt;</mi><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><mi>&rho;</mi><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(v+\rho w) &amp;gt; f(v) +\varepsilon_1 \rho d_vf(w)  </annotation></semantics></math>
Donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>&rho;</mi><mi>w</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>r</mi><mi>w</mi><mo stretchy="false">)</mo><mi>&gt;</mi><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>&rho;</mi><mo>&minus;</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(v+\rho w)&#x2d;f(v+r w) &amp;gt; \varepsilon_1 d_vf(w) (\rho &#x2d;r) </annotation></semantics></math>
A la limite lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&rho;</mi></mrow><annotation encoding='application/x-tex'>\rho</annotation></semantics></math> tend vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>d</mi> <mrow><mi>v</mi><mo>+</mo><mi>r</mi><mi>w</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>&geq;</mo><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>&Rightarrow;</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>d</mi> <mrow><mi>v</mi><mo>+</mo><mi>r</mi><mi>w</mi></mrow></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>&leq;</mo><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>d</mi> <mi>v</mi></msub><mi>f</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>d_{v+rw}f(w) \geq \varepsilon_1 d_vf(w) \Rightarrow &#x2d;d_{v+rw}f(w) \leq \varepsilon_1 (&#x2d;d_vf(w)) </annotation></semantics></math>
et comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&#x03B5;</mi> <mn>1</mn></msub><mi>&lt;</mi><msub><mi>&#x03B5;</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>\varepsilon_1&amp;lt;\varepsilon_2</annotation></semantics></math> on vérifie la deuxième
condition de Wolfe.</p><p>La recherche d’un pas de Wolfe peut se faire par dichotomie. On
initialise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>s</mi> <mo>&minus;</mo></msub><mo>,</mo><msub><mi>s</mi> <mo>+</mo></msub><mo>,</mo><mi>s</mi><mo>=</mo><mn>0</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn><mo>,</mo></mrow><annotation encoding='application/x-tex'>s_&#x2d;,s_+,s=0,+\infty,</annotation></semantics></math>estimation initiale. Puis on fait une boucle
</p><ol class="enumerate" type=1><li class="li-enumerate">
On teste si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi></mrow><annotation encoding='application/x-tex'>s</annotation></semantics></math> vérifie la première condition de Wolfe:
</li><li class="li-enumerate">Si c’est le cas, on teste la deuxième condition de Wolfe
<ol class="enumerate" type=a><li class="li-enumerate">
si la deuxième condition est
vérifiée, on renvoie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi></mrow><annotation encoding='application/x-tex'>s</annotation></semantics></math> qui est un pas de Wolfe. 
</li><li class="li-enumerate">Sinon
on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>s</mi> <mo>&minus;</mo></msub><mo>=</mo><mi>s</mi></mrow><annotation encoding='application/x-tex'>s_&#x2d;=s</annotation></semantics></math>
et (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>=</mo><mn>2</mn><mi>s</mi></mrow><annotation encoding='application/x-tex'>s=2s</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>s=+\infty</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>s</mi> <mo>&minus;</mo></msub><mo lspace="verythinmathspace" rspace="0em">+</mo><msub><mi>s</mi> <mo>+</mo></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>s=(s_&#x2d;+s_+)/2</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>s</mi> <mo>+</mo></msub><mo>&ne;</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>s_+\neq +\infty</annotation></semantics></math>).
</li></ol>
</li><li class="li-enumerate">Si ce n’est pas le cas, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi></mrow><annotation encoding='application/x-tex'>s</annotation></semantics></math> est trop
grand, on pose donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>s</mi> <mo>+</mo></msub><mo>=</mo><mi>s</mi></mrow><annotation encoding='application/x-tex'>s_+=s</annotation></semantics></math>, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>s</mi> <mo>&minus;</mo></msub><mo lspace="verythinmathspace" rspace="0em">+</mo><msub><mi>s</mi> <mo>+</mo></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>s=(s_&#x2d;+s_+)/2</annotation></semantics></math> et on reéssaie.
</li></ol><p>
Cette dichotomie est couteuse car exécutée à chaque itération
de la descente, on peut l’accélérer en interpolant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>s</mi><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(v+sw)</annotation></semantics></math> (par
exemple par un polynôme de Lagrange/Hermite de degré 3 en 0,0,<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi></mrow><annotation encoding='application/x-tex'>s</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi></mrow><annotation encoding='application/x-tex'>s</annotation></semantics></math>).</p>
<!--TOC chapter id="sec218" Algèbre linéaire-->
</html>
