<!DOCTYPE html>
<html >
<head>
<h1 id="sec12" class="chapter">Chapitre 3  Calculer sur ordinateur</h1><!--SEC END --><p> <a id="sec:calculer"></a></p>
<!--TOC section id="sec13" Représentation des entiers-->
<h2 id="sec13" class="section">3.1  Représentation des entiers</h2><!--SEC END --><div class="theorem"><span style="font-weight:bold">Proposition 1</span>  <em>
</em><em><span style="font-weight:bold">Division euclidienne de deux entiers :</span></em><em> si </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math><em> et </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math><em> sont
deux entiers, </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&geq;</mo><mn>0</mn><mo>,</mo><mi>b</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>a \geq 0, b&amp;gt;0</annotation></semantics></math><em>, il existe un unique couple </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>q</mi><mo>,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(q,r)</annotation></semantics></math><em> tel que
</em><a id="hevea_default0"></a><em>
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mi>q</mi><mo>+</mo><mi>r</mi><mo>,</mo><mspace width="1em"/><mi>r</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>b</mi><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'> a = bq +r , \quad r \in [0, b[  </annotation></semantics></math><em>
</em></div><p>
Preuve : On prend pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> le plus grand entier tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&minus;</mo><mi>b</mi><mi>q</mi><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>a&#x2d;bq \geq 0</annotation></semantics></math>.<br>
Exemple : 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">iquorem(23,7)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>La division euclidienne permet d’écrire un nombre entier, en utilisant
une base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> et des caractères pour représenter les entiers
entre 0 et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>b&#x2d;1</annotation></semantics></math>. Nous écrivons les nombres entiers en <span style="font-weight:bold">base</span> <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>b=10</annotation></semantics></math><a id="hevea_default1"></a>
avec comme caractères les chiffres de 0 à 9.
Les ordinateurs utilisent des circuits binaires pour stocker
les informations, il est donc naturel d’y travailler en base 2 
en utilisant comme caractères 0 et 1 ou en base 16 en utilisant
comme caractères les chiffres de 0 à 9 et les lettres de A à F.
En général, pour trouver l’écriture d’un nombre en base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> (par
exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>b=2</annotation></semantics></math>), 
on effectue des divisions euclidienne successives par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> du nombre puis
de ses quotients successifs jusqu’à ce que le quotient soit 0 et on
accolle les restes obtenus (premier reste à droite, dernier
reste à gauche).
Inversement, pour retrouver un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> à partir
de son écriture <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>d</mi> <mi>n</mi></msub><mo>.</mo><mo>.</mo><mo>.</mo><msub><mi>d</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>d_n...d_0</annotation></semantics></math>, on traduit les divisions euclidiennes 
successives en 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>d</mi></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">(</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mi>d</mi> <mi>n</mi></msub><mi>b</mi><mo>+</mo><msub><mi>d</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mi>b</mi><mo>+</mo><msub><mi>d</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>d</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>b</mi><mo>+</mo><msub><mi>d</mi> <mn>0</mn></msub></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msub><mi>d</mi> <mi>n</mi></msub><msup><mi>b</mi> <mi>n</mi></msup><mo>+</mo><msub><mi>d</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msup><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>d</mi> <mn>0</mn></msub></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 d &amp;=&amp;( ... ((d_n b +d_{n&#x2d;1})b + d_{n&#x2d;2})...+d_1)b+d_0\\
&amp;=&amp; d_n b^n + d_{n&#x2d;1} b^{n&#x2d;1} + ... + d_0
 \end{matrix} </annotation></semantics></math>
Par exemple, vingt-cinq s’écrit en base 16 <code>0x19</code> car 25 divisé
par 16 donne quotient 1, reste 9<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">convert(25,base,16)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
En base 2, on trouverait <code>0b11001</code> car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>25</mn><mo>=</mo><msup><mn>2</mn> <mn>4</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>3</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>25=2^4+2^3+1</annotation></semantics></math>.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">convert(25,base,2)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
On peut effectuer les opérations arithmétiques de base 
(+,-,*, division) directement en base 2 (ou 16). Par exemple
la table de l’addition est 0+0=0, 0+1=1+0=1 et 1+1=0 je retiens 1,
donc :
</p><pre class="verbatim">  01001111
+ 01101011
----------
  10111010
</pre><p><span style="font-weight:bold">Exercice </span>: 
comment passe-t-on simplement de la représentation d’un nombre en
base 2 à un nombre en base 16 et réciproquement ?</p><p>Les microprocesseurs peuvent effectuer directement
les opérations arithmétiques de base sur les entiers “machine”
(déclinés en plusieurs variantes selon la taille et la
possibilité d’avoir un signe). Noter que la division de deux
entiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> n’a pas la même signification que la division de deux
réels, comme elle ne tomberait pas forcément juste, 
on calcule le quotient et le reste de la division euclidienne. </p><p>Ces entiers machines permettent
de représenter de manière exacte des petits entiers relatifs 
par exemple un entier machine signé sur 4 octets est
compris entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mn>2</mn> <mn>31</mn></msup><mo>,</mo><msup><mn>2</mn> <mn>31</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;2^{31},2^{31}&#x2d;1]</annotation></semantics></math>. </p><p>Ces entiers machines permettent de faire très rapidement
du calcul exact sur les
entiers, mais à condition qu’il n’y ait pas de dépassement
de capacité, par exemple pour des entiers 32 bits, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>30</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>30</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>30</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>30</mn></msup></mrow><annotation encoding='application/x-tex'>2^{30}+2^{30}+2^{30}+2^{30}</annotation></semantics></math>
renverra 0. Ils sont utilisables avec tous les langages de
programmation traditionnels.</p><p>Les logiciels de calcul formel et certains logiciels
de programmation permettent de travailler avec
des entiers de taille beaucoup plus grande, ainsi qu’avec des
rationnels, permettant de faire du calcul exact, mais on paie
cette exactitude par un temps de calcul plus long, de plus
pas mal de méthodes numériques ne gagnent rien à
faire des calculs intermédiaires exacts. Néanmoins, l’utilisation
d’un logiciel de calcul formel permettra dans certains cas d’illustrer
certains phénomènes dus au calcul approché.</p>
<!--TOC section id="sec14" Les réels-->
<h2 id="sec14" class="section">3.2  Les réels</h2><!--SEC END --><p>
On se ramène d’abord au cas des réels positifs, en machine
on garde traditionnellement un bit pour stocker le signe du réel
à représenter.</p>
<!--TOC subsection id="sec15" Virgule fixe et flottante.-->
<h3 id="sec15" class="subsection">3.2.1  Virgule fixe et flottante.</h3><!--SEC END --><p>
La première idée qui vient naturellement serait d’utiliser
un entier et de déplacer la virgule
d’un nombre fixe de position, ce qui revient à mulitplier
par une puissance (négative) de la base. Par exemple en base 10 avec un
décalage de 4, <code>1234.5678</code>
serait représenté par <code>12345678</code> et <code>1.2345678</code> par
<code>12345</code> (on passe de l’entier au réel par multiplication
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>10</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>4</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>10^{&#x2d;4}</annotation></semantics></math>. L’inconvénient d’une telle représentation est
qu’on ne peut pas représenter des réels grands ou petits,
comme par exemple le nombre d’Avogadro, la constante de Planck, etc.</p><p>D’où l’idée de ne pas fixer la position de la virgule, on parle
alors de représentation à virgule flottante ou de nombre flottant : on
représente un nombre par deux entier, l’un appelé <span style="font-weight:bold">mantisse</span><a id="hevea_default2"></a>
reprend les chiffres significatifs du réel sans virgule, l’autre
l’exposant, donne la position de la virgule. Attention, le séparateur
est un point et non une virgule dans la grande
majorité des logiciels scientifiques.
On sépare
traditionnellement la mantisse de l’exposant par la lettre <code>e</code>.
Par exemple <code>1234.5678</code> peut être représenté 
par <code>12345678e-8</code> (mantisse <code>12345678</code>, exposant -8)
mais aussi par <code>1234567800e-10</code>.</p><p>Naturellement, sur un ordinateur, il y a des limites pour les entiers 
représentant la mantisse <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> et l’exposant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi></mrow><annotation encoding='application/x-tex'>e</annotation></semantics></math>. 
Si on écrit les nombres en base
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>, la mantisse <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> s’écrira avec un nombre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> fixé de chiffres (ou
de bits en base 2), donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mi>b</mi> <mi>n</mi></msup><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>m \in [0,b^n[</annotation></semantics></math>. Soit un réel <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> représenté
par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>=</mo><mi>m</mi><msup><mi>b</mi> <mi>e</mi></msup><mo>,</mo><mspace width="1em"/><mi>m</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mi>b</mi> <mi>n</mi></msup><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'> x=mb^e, \quad m \in [0,b^n[  </annotation></semantics></math>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>m\in [0,b^{n&#x2d;1}[</annotation></semantics></math>, alors on peut aussi écrire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>m</mi><mo>&prime;</mo><msup><mi>b</mi> <mrow><mi>e</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>x=m&apos; b^{e&#x2d;1}</annotation></semantics></math> avec
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&prime;</mo><mo>=</mo><mi>m</mi><mi>b</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mi>b</mi> <mi>n</mi></msup><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>m&apos;=mb \in [0,b^n[</annotation></semantics></math>, quelle écriture faut-il choisir?
Intuitivement, on sent qu’il vaut mieux prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>m&apos;</annotation></semantics></math> le plus grand
possible, car cela augmente le nombre de chiffres significatifs (alors
que des 0 au début de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> ne sont pas significatifs).
Ceci est confirmé par le calcul de l’erreur d’arrondi pour
représenter un réel. En effet, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est un réel non nul, il ne
s’écrit pas forcément sous la forme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><msup><mi>b</mi> <mi>e</mi></msup></mrow><annotation encoding='application/x-tex'>mb^e</annotation></semantics></math>, on doit l’arrondir,
par exemple au plus proche réel de la forme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><msup><mi>b</mi> <mi>e</mi></msup></mrow><annotation encoding='application/x-tex'>mb^e</annotation></semantics></math>. La distance
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> à ce réel est inférieure ou égale à la moitié
de la distance entre deux flottants consécutifs, 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><msup><mi>b</mi> <mi>e</mi></msup></mrow><annotation encoding='application/x-tex'>mb^e</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><msup><mi>b</mi> <mi>e</mi></msup></mrow><annotation encoding='application/x-tex'>(m+1)b^e</annotation></semantics></math>, donc l’erreur d’arrondi
est inférieure ou égale à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>b</mi> <mi>e</mi></msup><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>b^e/2</annotation></semantics></math>. Si on divise par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&geq;</mo><mi>m</mi><msup><mi>b</mi> <mi>e</mi></msup></mrow><annotation encoding='application/x-tex'>x \geq mb^e</annotation></semantics></math>,
on obtient une erreur relative d’arrondi majorée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>1/(2m)</annotation></semantics></math>.
On a donc intérêt à prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> le plus grand possible pour
minimiser cette erreur. Quitte à mulitplier par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>, on peut
toujours se ramener (sauf exceptions, cf. ci-dessous), 
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&Element;</mo><mo stretchy="false">[</mo><msup><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>,</mo><msup><mi>b</mi> <mi>n</mi></msup><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>m \in [b^{n&#x2d;1},b^n[</annotation></semantics></math>, on a alors
une erreur d’arrondi relative majorée par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \frac{1}{2b^{n&#x2d;1}} </annotation></semantics></math></p><p>On appelle <span style="font-weight:bold">flottant normalisé</span><a id="hevea_default3"></a> un flottant tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&Element;</mo><mo stretchy="false">[</mo><msup><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>,</mo><msup><mi>b</mi> <mi>n</mi></msup><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>m \in
[b^{n&#x2d;1},b^n[</annotation></semantics></math>. Pour écrire un réel sous forme de flottant
normalisé, on écrit le réel en base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>, et on déplace
la virgule pour avoir exactement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> chiffres non nuls avant la
virgule et on arrondit (par exemple au plus proche). 
L’exposant est égal au décalage effectué.
Notez qu’en base 2, un flottant normalisé commence forcément
par 1, ce qui permet d’économiser un bit dans le stockage.</p><p>Ainsi, l’erreur d’<span style="font-weight:bold">arrondi</span><a id="hevea_default4"></a> commise lorsqu’on
représente un réel (connu exactement) par un double normalisé 
est une erreur relative inférieure à
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;53}</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>b=2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>52</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n=52+1</annotation></semantics></math> pour les doubles).</p><p>Exemples : 
</p><ul class="itemize"><li class="li-itemize">
en base 10 avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding='application/x-tex'>n=6</annotation></semantics></math>, pour représenter
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&pi;</mi><mo>=</mo><mn>3,141</mn><mn>59265</mn><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>\pi=3,14159265...</annotation></semantics></math>, on doit décaler la virgule de 5 positions,
on obtient <code>314159.265...</code> on arrondit à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>314159</mn></mrow><annotation encoding='application/x-tex'>314159</annotation></semantics></math> donc
on obtient <code>314159e-5</code>.
</li><li class="li-itemize">en base 2 avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>n=10</annotation></semantics></math>, pour représenter trois cinquièmes (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>3</mn><mo stretchy="false">/</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>3/5</annotation></semantics></math>
en base 10, noté <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>11</mn><mo stretchy="false">/</mo><mn>101</mn></mrow><annotation encoding='application/x-tex'>11/101</annotation></semantics></math> en base 2), 
on pose la division en base 2 de <code>11</code> par 
<code>101</code>, ce qui donne
<pre class="verbatim"> 11        | 101
 110       ---------
-101       | 0.1001
----       |
  010      |
   100     |
   1000    |
  - 101    |
  -----    |
    011    |
</pre>
on retrouve le nombre de départ donc le développement est
périodique et vaut <code>0.1001 1001 1001 ...</code>.
On décale le point de 10 positions, on arrondit,
donc trois cinquièmes est
représenté par la mantisse <code>1001100110</code> et l’exposant
<code>-10</code>. On observe aussi sur cet exemple que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>3</mn><mo stretchy="false">/</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>3/5</annotation></semantics></math> dont l’écriture
en base 10 <code>0.6</code> est exacte, n’a pas d’écriture exacte en base
2 (de même que 1/3 n’a pas d’écriture exacte en base 10).
</li></ul><p>Il existe une exception à la possibilité de normaliser les flottants,
lorsqu’on atteint la limite inférieure de l’exposant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi></mrow><annotation encoding='application/x-tex'>e</annotation></semantics></math>. 
Soit en effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>e</mi> <mi>m</mi></msub></mrow><annotation encoding='application/x-tex'>e_m</annotation></semantics></math> le plus petit exposant des flottants normalisés
et considérons les flottants <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>b</mi> <mrow><msub><mi>e</mi> <mi>m</mi></msub></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy="false">/</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x=b^{e_m}(1+1/b)</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><msup><mi>b</mi> <mrow><msub><mi>e</mi> <mi>m</mi></msub></mrow></msup></mrow><annotation encoding='application/x-tex'>y=b^{e_m}</annotation></semantics></math>. Ces
flottants sont distincts, 
mais leur différence n’est plus représentable par un flottant normalisé.
Comme on ne souhaite pas représenter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&minus;</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>x&#x2d;y</annotation></semantics></math> par 0, 
(puisque le test <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>x==y</annotation></semantics></math> renvoie faux), on introduit les flottants 
<span style="font-weight:bold">dénormalisés</span> <a id="hevea_default5"></a>, il s’agit de
flottants dont l’exposant est l’exposant minimal représentable sur
machine et dont la mantisse appartient à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>[0,b^{n&#x2d;1}[</annotation></semantics></math>. Par exemple
0 est représenté par un flottant dénormalisé de mantisse 0
(en fait 0 a deux reprśentation, une de signe positif et une de
signe négatif).</p><p>Enfin, on utilise traditionnellement une valeur de l’exposant pour
représenter les nombres plus grands que le plus grand réel
reprśentable sur machine (traditionnellement appelé plus ou
moins infini)
et les erreurs (par exemple 0./0. ou racine carrée d’un nombre
réel négatif, traditionnellement appelé NaN, Not a Number).</p><p><span style="font-weight:bold">Exercice</span> : quels sont les nombres réels représentables exactement
en base 10 mais pas en base 2 ?
Si on écrit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>1/10</annotation></semantics></math> en base 2 avec 53 bits de précision, puis que
l’on arrondit avec 64 bits de précision, ou si on écrit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>1/10</annotation></semantics></math> en
base 2 avec 64 bits de précision, obtient-on la même chose ?</p><p>Les ordinateurs reprśentent généralement les flottants en base 2 
(cf. la section suivante pour
plus de précisions), mais cette représentation n’est pas utilisée
habituellement par les humains, qui préfèrent compter
en base 10. Les ordinateurs effectuent donc la conversion dans
les routines d’entrée-sortie. Le format standard utilisé
pour saisir ou afficher un nombre flottant dans un logiciel
scientifique est composé d’un nombre à virgule
flottante utilisant le point comme séparateur décimal (et
non la virgule) suivi si nécessaire de la lettre <code>e</code> puis de l’exposant,
par exemple <code>1.23e-5</code> ou <code>0.0000123</code>. Dans les
logiciels de calcul formel, pour distinguer un entiers
représentés par un entier
d’un entier représenté par un flottant on écrit
l’entier suivi de <code>.0</code> par exemple <code>23.0</code>.</p><p><span style="font-weight:bold">Remarque</span> :<br>
Les microprocesseurs ayant un mode <span style="font-weight:bold">BCD</span><a id="hevea_default6"></a> peuvent avoir un format
de représentation des flottants en base 10, les nombres décimaux
comme par exemple 0.3 peuvent être représentés exactement. 
Certains logiciels, notamment maple, utilisent par défaut des
flottants logiciels en base 10 sur des microprocesseurs sans mode BCD, 
ce qui entraine une baisse de
rapidité importante pour les calculs numériques (on peut
partiellement améliorer les performances en utilisant <code>evalhf</code>
en maple).</p>
<!--TOC subsection id="sec16" Les flottants au format <span style="font-family:monospace">double</span>-->
<h3 id="sec16" class="subsection">3.2.2  Les flottants au format <span style="font-family:monospace">double</span></h3><!--SEC END --><p> 
<a id="hevea_default7"></a> <a id="hevea_default8"></a>
Cette section développe les notions de la section précédente
pour les flottants machine selon la norme IEEE-754, utilisables dans les langage de
programmation usuels, elle peut être omise en première lecture.
La représentation d’un double
en mémoire se compose de 3 parties : le bit<a id="hevea_default9"></a> 
de signe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>=</mo><mo>&pm;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>s=\pm 1</annotation></semantics></math> sur 1 bit, 
la mantisse<a id="hevea_default10"></a> <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mn>2</mn> <mn>52</mn></msup><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>M \in [0,2^{52}[</annotation></semantics></math> sur 52 bits, 
et l’exposant<a id="hevea_default11"></a> <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mn>2</mn> <mn>11</mn></msup><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>e \in [0, 2^{11}[</annotation></semantics></math> sur 11 bits. Pour les nombres
“normaux”, l’exposant est en fait compris entre 1 et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>11</mn></msup><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>2^{11}&#x2d;2</annotation></semantics></math>,
le nombre représenté est le rationnel
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mi>M</mi><mrow><msup><mn>2</mn> <mn>52</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><msup><mn>2</mn> <mrow><mi>e</mi><mo>+</mo><mn>1</mn><mo>&minus;</mo><msup><mn>2</mn> <mn>10</mn></msup></mrow></msup></mrow><annotation encoding='application/x-tex'> (1+\frac{M}{2^{52}}) 2^{e+1&#x2d;2^{10}}  </annotation></semantics></math>
Pour écrire un nombre sous cette forme, il faut d’abord chercher par
quel multiple de 2 il faut le diviser pour obtenir un réel <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>[1,2[</annotation></semantics></math>, ce qui permet de déterminer l’exposant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi></mrow><annotation encoding='application/x-tex'>e</annotation></semantics></math>. Ensuite on
écrit la représentation en base 2 de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>&minus;</mo><mn>1</mn><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>r&#x2d;1 \in [0,1[</annotation></semantics></math>.
Exemples :
</p><ul class="itemize"><li class="li-itemize">
-2 <br>
Signe négatif. Il faut diviser sa valeur absolue 
2 par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>1</mn></msup></mrow><annotation encoding='application/x-tex'>2^1</annotation></semantics></math> pour être entre 1 et 2 dont
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>+</mo><mn>1</mn><mo>&minus;</mo><msup><mn>2</mn> <mn>10</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>e+1&#x2d;2^{10}=1</annotation></semantics></math>, l’exposant est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>=</mo><msup><mn>2</mn> <mn>10</mn></msup></mrow><annotation encoding='application/x-tex'>e=2^{10}</annotation></semantics></math>. On a alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>r=1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>&minus;</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>r&#x2d;1=0</annotation></semantics></math>.
Représentation <br>
<code>1 10000000000 00000000...0000</code>
</li><li class="li-itemize">1.5=3/2<br>
Signe positif, compris entre 1 et 2 dont l’exposant vérifie
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>+</mo><mn>1</mn><mo>&minus;</mo><msup><mn>2</mn> <mn>10</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>e+1&#x2d;2^{10}=0</annotation></semantics></math> soit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>=</mo><msup><mn>2</mn> <mn>10</mn></msup><mo>&minus;</mo><mn>1</mn><mo>=</mo><msup><mn>2</mn> <mn>9</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>8</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>7</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>6</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>5</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>4</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>3</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>2</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>1</mn></msup><mo>+</mo><msup><mn>2</mn> <mn>0</mn></msup></mrow><annotation encoding='application/x-tex'>e=2^{10}&#x2d;1=2^9+2^8+2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0</annotation></semantics></math>. 
On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>&minus;</mo><mn>1</mn><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo>=</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>r&#x2d;1=1/2=2^{&#x2d;1}</annotation></semantics></math>. D’où la représentation<br>
<code>0 01111111111 10000000...0000</code>
</li><li class="li-itemize">6.4=32/5<br>
Positif. Il faut le diviser par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>2^{2}</annotation></semantics></math> pour avoir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>8</mn><mo stretchy="false">/</mo><mn>5</mn><mo>&Element;</mo><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>8/5 \in [1,2[</annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>+</mo><mn>1</mn><mo>&minus;</mo><msup><mn>2</mn> <mn>10</mn></msup><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>e+1&#x2d;2^{10}=2</annotation></semantics></math> soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>=</mo><msup><mn>2</mn> <mn>10</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>e=2^{10}+1</annotation></semantics></math>. Ensuite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mn>3</mn><mo stretchy="false">/</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>r=3/5</annotation></semantics></math> qu’il faut
écrire en base 2 (cf. section précédente),
on écrit donc les 52 premiers éléments du développement
avec une règle d’arrondi du dernier bit au nombre le plus proche. 
Ici le bit suivant le dernier <code>1001</code> est un <code>1</code>, on arrondit
donc à <code>1010</code>. D’où la représentation<br>
<code>0 1000000001 100110011001...10011010</code><br>
</li></ul><p>
On observe que la représentation en base 2 de 6.4 a du être
arrondie (car elle est infinie en base 2) bien qu’elle soit exacte
(finie) en base 10.
Seuls les entiers et les rationnels dont le dénominateur est une puissance
de 2 peuvent être représentés exactement.
Ceci entraine des résultats qui peuvent surprendre
comme par exemple le fait que
<code>0.5 - 5*0.1</code> n’est pas nul.</p><p>Des représentations spéciales (avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>e=0</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>e</mi><mo>=</mo><msup><mn>2</mn> <mn>11</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>e=2^{11}&#x2d;1</annotation></semantics></math>) 
ont été introduites
pour représenter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&pm;</mo><mn>&infin;</mn></mrow><annotation encoding='application/x-tex'>\pm \infty</annotation></semantics></math> (pour les flottants plus grands
en valeur absolue que le plus grand flottant représentable), et pour
représenter les
nombres non nuls plus petits que le plus petit flottant représentable
de la manière exposée ci-dessus (on parle de flottants dénormalisés),
ainsi que le nombre NaN (Not a Number) lorsqu’une opération a un résultat
indéfini (par exemple 0/0).</p><p>Remarque : Sur les processeurs compatibles avec les i386, 
le coprocesseur arithmétique i387 gère en interne des flottants
avec 80 bits dont 64 bits de mantisse. Sur les architectures 64 bits
(x86 ou AMD), le jeu d’instruction SSE permet de travailler avec
des flottants de 128 bits. Le compilateur gcc permet d’utiliser
ces flottants longs avec le type <code>long double</code> ou
les types <code>__float80</code> et <code>__float128</code> en utilisant
un drapeau de compilation du type <code>-msse</code></p>
<!--TOC subsection id="sec17" Opérations sur les flottants-->
<h3 id="sec17" class="subsection">3.2.3  Opérations sur les flottants</h3><!--SEC END --><p>
Les opérations arithmétiques de base sur les flottants
se font de la manière suivante :
</p><ul class="itemize"><li class="li-itemize">
addition et soustraction : on détecte s’il faut additionner
ou soustraire en valeur absolue en analysant les signes,
on détermine l’exposant le plus grand et on décale la partie mantisse 
du flottant dont l’exposant est le plus petit pour se ramener à additionner
deux entiers (partie mantisses correspondant au même exposant), 
on décale à nouveau la partie mantisse en modifiant l’exposant 
après l’opération pour normaliser le flottant
</li><li class="li-itemize">multiplication : on additionne les exposants et on multiplie
les parties mantisses (vus comme des entiers), on arrondit et
on ajuste l’exposant si nécessaire
</li><li class="li-itemize">division : on soustrait les exposants et on divise les parties
mantisses (division “à virgule”), on tronque et on
ajuste l’exposant si nécessaire
</li></ul>
<!--TOC subsection id="sec18" Erreurs-->
<h3 id="sec18" class="subsection">3.2.4  Erreurs</h3><!--SEC END --><p> <a id="hevea_default12"></a>
La représentation des nombres réels par des doubles présente
des avantages, les opérations arithmétiques
sont faites au plus vite par le microprocesseur.
Les coprocesseurs arithmétiques (intégrés sur les microprocesseurs
de PC) proposent même
le calcul des fonctions usuelles (trigonométriques, racine carrée, log et exp)
sur le type double et utilisent des formats de représentation interne
ayant plus de 64 bits pour les doubles, ce qui permet de limiter
les erreurs d’arrondi. 
Par contre, des erreurs vont être introduites,
on parle de calcul approché par opposition au calcul exact sur les
rationnels. En effet, la représentation doit d’abord arrondir 
tout réel qui n’est pas un rationnel dont le dénominateur
est une puissance de 2. Ensuite chaque opération va entrainer
une propagation de ces erreurs et va y ajouter une erreur d’arrondi 
sur le résultat.
Enfin, l’utilisation du type double peut provoquer un dépassement
de capacité (par exemple <code>100!*100!</code>).</p><p>Pour diminuer ces erreurs et les risques de dépassement de
capacité, il existe des types flottants multiple précision,
qui permettent de travailler avec un nombre fixé à l’avance
de décimales et une plage d’exposants plus grande. Les calculs sont plus longs mais les erreurs
plus faibles. Attention, il s’agit toujours de calcul approché!
De plus, pour des quantités dont la valeur est déterminée
de manière expérimentale, la source principale de propagation
d’erreurs est la précision des quantités initiales, il ne sert
souvent à rien d’utiliser des types flottants multiprécision car les
erreurs dus à la représentation (double) sont négligeables devant
les erreurs de mesure. Dans ce cas, il est pertinent lorsqu’on
évalue <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> mal connu de calculer aussi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f&apos;(x)</annotation></semantics></math>, en effet :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>x</mi><mi>h</mi><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x(1+h))= f(x)+xh f&apos;(x) + O(h^2) </annotation></semantics></math>
l’erreur relative sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)</annotation></semantics></math> est donc au premier ordre multipliée par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mfrac><mrow><mi>x</mi><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|\frac{xf&apos;(x)}{f(x)}| </annotation></semantics></math>
Par exemple, l’erreur relative sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mi>x</mi></msup></mrow><annotation encoding='application/x-tex'>e^x</annotation></semantics></math> est au premier ordre l’erreur relative sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>
multipliée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|x|</annotation></semantics></math>.
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a:=convert(100,interval); (right(a)-left(a))/evalf(a,12) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">b:=exp(a); (right(b)-left(b))/evalf(b,12) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p>
<!--TOC subsection id="sec19" Erreur absolue, relative, arrondi propagation des erreurs.-->
<h3 id="sec19" class="subsection">3.2.5  Erreur absolue, relative, arrondi propagation des erreurs.</h3><!--SEC END --><p>
On a vu précédemment que pour représenter un réel, on devait
l’arrondir, ce qui introduit une erreur même si le réel est
connu exactement (par exemple 1/10).
Voyons comment se propagent les <span style="font-weight:bold">erreurs</span><a id="hevea_default13"></a> 
dans les opérations arithmétiques
de base : on distingue l’addition, la multiplication
et l’inversion. La soustraction se ramène à l’addition car
le calcul de l’opposé n’introduit aucune erreur nouvelle.
Pour l’addition, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>&#x03B5;</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>|x &#x2d;x_0| \leq \varepsilon_0</annotation></semantics></math> et si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>y</mi><mo>&minus;</mo><msub><mi>y</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>&#x03B5;</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>|y&#x2d;y_0| \leq \varepsilon_1</annotation></semantics></math>
alors par l’inégalité triangulaire (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mi>a</mi><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">&vert;</mo><mi>b</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|a+b|\leq |a|+|b|</annotation></semantics></math>), on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>y</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">&vert;</mo><mi>y</mi><mo>&minus;</mo><msub><mi>y</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>&#x03B5;</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>&#x03B5;</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'> |(x+y)&#x2d;(x_0+y_0)| \leq |x&#x2d;x_0| + | y&#x2d;y_0 | \leq 
\varepsilon_0 + \varepsilon_1  </annotation></semantics></math>
on dit que les erreurs <em>absolues</em> s’additionnent. 
</p><div class="theorem"><span style="font-weight:bold">Définition 2</span>  <em>
L’</em><em><span style="font-weight:bold">erreur absolue</span></em><a id="hevea_default14"></a><em>
est définie comme un majorant de la valeur absolue
de la différence entre le nombre réel et
son représentant double :
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&#x03B5;</mi></mrow><annotation encoding='application/x-tex'> |x&#x2d;x_0| \leq \varepsilon  </annotation></semantics></math><em>
</em></div><p>
Mais comme il faut représenter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0+y_0</annotation></semantics></math>
en machine, on doit ajouter une erreur d’arrondi, qui est
proportionnelle à la valeur absolue de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>+</mo><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0+y_0</annotation></semantics></math> d’où la notion
d’erreur <em>relative</em> :
</p><div class="theorem"><span style="font-weight:bold">Définition 3</span>  <em>
L’</em><em><span style="font-weight:bold">erreur relative</span></em><a id="hevea_default15"></a><em> 
est égale à l’erreur absolue divisée par
la valeur absolue du nombre
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mi>&#x03B5;</mi><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'> |x&#x2d;x_0| \leq \varepsilon |x_0|  </annotation></semantics></math><em>
</em></div><p>
Remarquons au passage que les erreurs de mesure expérimentales sont 
pratiquement toujours des erreurs relatives.</p><p>Donc lorsqu’on effectue une addition (ou une soustraction) de deux réels
sur machine, on doit additionner les deux erreurs absolues sur les opérandes
et ajouter une erreur d’arrondi (relative de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;53}</annotation></semantics></math>, à titre
d’exercice, on pourra vérifier que cette erreur
d’arrondi est majorée par l’erreur absolue de la somme 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>x+y</annotation></semantics></math> dès l’instant où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> ont eux-même une erreur d’arrondi).</p><p>Lorsqu’on effectue une multiplication de deux nombres <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>x,y</annotation></semantics></math> dont les
représentants <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0,y_0</annotation></semantics></math> sont non nuls, on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>&vert;</mo><mfrac><mrow><mi>x</mi><mi>y</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><msub><mi>y</mi> <mn>0</mn></msub></mrow><mrow><msub><mi>x</mi> <mn>0</mn></msub><msub><mi>y</mi> <mn>0</mn></msub></mrow></mfrac><mo>&vert;</mo></mrow><mo>=</mo><mrow><mo>&vert;</mo><mfrac><mi>x</mi><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac><mfrac><mi>y</mi><mrow><msub><mi>y</mi> <mn>0</mn></msub></mrow></mfrac><mo>&minus;</mo><mn>1</mn><mo>&vert;</mo></mrow><mo>=</mo><mrow><mo>&vert;</mo><mo stretchy="false">(</mo><mfrac><mi>x</mi><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mfrac><mi>y</mi><mrow><msub><mi>y</mi> <mn>0</mn></msub></mrow></mfrac><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mfrac><mi>x</mi><mrow><msub><mi>x</mi> <mn>0</mn></msub></mrow></mfrac><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mfrac><mi>y</mi><mrow><msub><mi>y</mi> <mn>0</mn></msub></mrow></mfrac><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&vert;</mo></mrow></mrow><annotation encoding='application/x-tex'> \left| \frac{xy&#x2d;x_0 y_0}{x_0 y_0} \right| = 
\left| \frac{x}{x_0} \frac{y}{y_0} &#x2d;1 \right|
= \left| 
(\frac{x}{x_0}&#x2d;1)(\frac{y}{y_0} &#x2d;1)+(\frac{x}{x_0}&#x2d;1)+(\frac{y}{y_0} &#x2d;1) 
\right|   </annotation></semantics></math>
l’erreur relative est donc la somme des erreurs relatives et du produit
des erreurs relatives (on peut souvent négliger le produit devant la somme). Il
faut aussi y ajouter une erreur relative d’arrondi de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;53}</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><msub><mi>y</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>x_0 y_0</annotation></semantics></math>.</p><p>On observe que la multiplication est une opération posant moins
de problèmes que l’addition, car on manipule toujours des erreurs
relatives, par exemple si l’erreur relative sur deux doubles
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> non nuls
est de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;53}</annotation></semantics></math>, alors l’erreur relative sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>y</mi></mrow><annotation encoding='application/x-tex'>xy</annotation></semantics></math> sera de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup><mo>+</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup><mo>+</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>106</mn></mrow></msup><mo>+</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup><mo>&approx;</mo><mn>3</mn><mo>&times;</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> 2^{&#x2d;53} + 2^{&#x2d;53} + 2^{&#x2d;106} + 2^{&#x2d;53} \approx 3 \times 2^{&#x2d;53}  </annotation></semantics></math>
Lorsque l’erreur relative sur les données est grande devant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;53}</annotation></semantics></math>,
l’erreur relative d’arrondi final est négligeable, on peut alors dire que
les erreurs relatives s’additionnent pour un produit (c’est aussi vrai
pour un quotient: exercice!).
Par contre, si on additionne deux nombres dont le représentant de
la somme est proche de 0, la somme des erreurs absolues peut
devenir non négligeable par rapport à la somme des représentants, entrainant
une erreur relative très grande. Par exemple si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> est représenté
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>=</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>52</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>x_0=1+2^{&#x2d;52}</annotation></semantics></math> avec
une erreur d’arrondi de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;53}</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>y</mi> <mn>0</mn></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>y_0=&#x2d;1</annotation></semantics></math> avec la même erreur d’arrondi, 
l’addition de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> renvoie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>52</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;52}</annotation></semantics></math> avec une erreur
absolue de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo>*</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>2 * 2^{&#x2d;53}</annotation></semantics></math> (ici il n’y a pas d’arrondi lorsqu’on fait la somme).
C’est une erreur relative de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn></mrow><annotation encoding='application/x-tex'>1</annotation></semantics></math> (qui domine largement
l’erreur d’arrondi) ce qui signifie que dans la mantisse, seul le
premier bit sur les 52 a un sens, la perte de précision est très grande.</p><p>Une autre conséquence importante est que l’addition de réels sur machine
n’est pas une opération associative,
par exemple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2.0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup><mo>+</mo><msup><mn>2.0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup><mo stretchy="false">)</mo><mo>+</mo><mn>1.0</mn><mo>&rightarrow;</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>52</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> (2.0^{&#x2d;53}+2.0^{&#x2d;53})+1.0 \rightarrow 1+2^{&#x2d;52}  </annotation></semantics></math>
alors que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mn>2.0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><msup><mn>2.0</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>53</mn></mrow></msup><mo>+</mo><mn>1.0</mn><mo stretchy="false">)</mo><mo>&rightarrow;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'> 2.0^{&#x2d;53}+(2.0^{&#x2d;53}+1.0) \rightarrow 1  </annotation></semantics></math>
Dans Xcas, il n’y a que 48 bits de mantisse :
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">(2.^(-48)+(2.^(-48)+1.))-1.; ((2.^(-48)+2.^(-48))+1.)-1. 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

Si on a plusieurs termes
à additionner, il faut commencer par additionner entre eux
les termes les plus petits, pour que les petits termes ne soient
pas absorbés un à un dans les erreurs d’arrondi (les petits ruisseaux
font les grands fleuves).</p><p>Exercice : pour calculer la valeur
numérique d’une dérivée de fonction, il vaut mieux
calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>h</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(f(x+h)&#x2d;f(x&#x2d;h))/(2h)</annotation></semantics></math> que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>h</mi></mrow><annotation encoding='application/x-tex'>(f(x+h)&#x2d;f(x))/h</annotation></semantics></math> car le terme
d’erreur est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(h^2)</annotation></semantics></math> et non en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(h)</annotation></semantics></math>. Attention
toutefois à ne pas prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> trop petit, sinon <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>+</mo><mi>h</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x+h=x</annotation></semantics></math>
en flottants et même si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>+</mo><mi>h</mi><mo>&ne;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x+h \neq x</annotation></semantics></math>, l’erreur absolue sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x+h)&#x2d;f(x&#x2d;h)</annotation></semantics></math> est (au moins) d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\varepsilon |f(x)|</annotation></semantics></math>, donc l’erreur
relative est d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03B5;</mi><mo stretchy="false">/</mo><mi>h</mi><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\varepsilon/h |f(x)|</annotation></semantics></math>. 
Par exemple pour <span style="font-family:monospace">h=1e-8</span> le reste est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(h^2)</annotation></semantics></math> donc
de l’ordre des erreurs d’arrondi mais l’erreur relative sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>h</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x+h)&#x2d;f(x&#x2d;h)</annotation></semantics></math> est d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo stretchy="false">/</mo><mi>h</mi></mrow><annotation encoding='application/x-tex'>\epsilon/h</annotation></semantics></math> largement supérieure
(en flottants double-précision). On choisira plutôt <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo stretchy="false">/</mo><mi>h</mi></mrow><annotation encoding='application/x-tex'>\epsilon/h</annotation></semantics></math> soit proche de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>h^2</annotation></semantics></math>, donc de l’ordre de <span style="font-family:monospace">1e-5</span>, qui
fournira une valeur approchée avec une erreur relative de l’ordre
de <span style="font-family:monospace">1e-10</span>.
Exemple : calcul de la dérivée numérique de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>exp</mi><mo stretchy="false">(</mo><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\exp(\sin(x))</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x=1</annotation></semantics></math>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;height:40px;font-style:large">f(x):=exp(sin(x)); seq(taux_accroissement(f(x),1.0-10^(-k),1.0+10^(-k))-f'(1.0),k,1,11) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>Remarquons néanmoins que les erreurs calculées ici sont des majorations
des erreurs réelles (ou si on préfère l’erreur obtenue dans le pire
des cas), statistiquement les erreurs sur les résultats sont moindres,
par exemple si on effectue <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> calculs susceptibles de provoquer
des erreurs indépendantes suivant une même loi d’espérance nulle, la moyenne des
erreurs divisée par l’écart-type de la loi
tend vers une loi normale centrée réduite. De manière plus
déterministe, on a l’inégalité de Bienaymé-Tchebyshev
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mo stretchy="false">&vert;</mo><mi>X</mi><mo stretchy="false">&vert;</mo><mi>&gt;</mi><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mfrac><mrow><mi>n</mi><msup><mi>&sigma;</mi> <mn>2</mn></msup></mrow><mrow><msup><mi>&alpha;</mi> <mn>2</mn></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> P(|X|&amp;gt;\alpha) \leq \frac{n\sigma^2}{\alpha^2} </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math> est la variable aléatoire somme des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> erreurs, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>
l’erreur et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><msup><mi>&sigma;</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>n\sigma^2</annotation></semantics></math> la variance de la somme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> erreurs
supposées indépendantes, cette probabilité tend vers 0 pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
grand si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> est d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, et ne tend
pas vers 0 si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> est de l’ordre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{n}</annotation></semantics></math>.
Exemple : somme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>400</mn></mrow><annotation encoding='application/x-tex'>n=400</annotation></semantics></math> nombres répartis sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math> selon la loi
uniforme (représentant des erreurs), on divise par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>n</mi></msqrt><mo>=</mo></mrow><annotation encoding='application/x-tex'>\sqrt{n}=</annotation></semantics></math>20, 
on effectue plusieurs tirages (par exemple 500) on trace l’histogramme et 
on compare avec la loi normale de moyenne
nulle (l’espérance de la somme) et d’écart-type celui de la loi
uniforme.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">m:=ranm(400,500,-1..1):;gl_x=-2..2;histogram(sum(m)/20,-1,0.1); plot(normald(0,0.57),-2..2)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Attention, si on effectue la somme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> réels <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>j</mi></msub><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\sum_j x_j</annotation></semantics></math>, 
les erreurs d’arrondis
ne satisfont pas à ces hypothèses. En effet, l’erreur d’arrondi
à chaque opération est une erreur relative, l’erreur absolue 
correspondante est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\epsilon |x_1+x_2|</annotation></semantics></math> puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub><mo>+</mo><msub><mi>x</mi> <mn>3</mn></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\epsilon |x_1+x_2+x_3|</annotation></semantics></math>
puis ... <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>+</mo><msub><mi>x</mi> <mn>2</mn></msub><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\epsilon |x_1+x_2+...+x_n|</annotation></semantics></math>, que l’on peut majorer par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&epsi;</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>2</mn></msub><mo stretchy="false">&vert;</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\epsilon ((n&#x2d;1)|x_1|+(n&#x2d;2)|x_2|+...+|x_n||) </annotation></semantics></math>
La majoration de l’erreur d’arrondi dépend donc de l’ordre des termes,
on a intérêt à sommer en commençant par les termes les
plus petits en valeur absolue.
Mais on peut faire mieux, 
il est possible de corriger les erreurs d’arrondi dans une somme
avec le programme suivant pour une liste (on peut bien sur
adapter à la somme d’une expression dépendant d’une variable
entière sans stocker de liste) :

</p><pre class="verbatim">Somme(l):={
  local x,s,c;
  s:=0.0;
  c:=0.0;
  pour x in l faire
    c += (x-((s+x)-s));
    s += x;
  fpour;
  print(c);
  return s+c;
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


En effet, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> devrait valoir 0 sans erreurs d’arrondis,
avec les erreurs d’arrondis, on a le premier calcul <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>+</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>s+x</annotation></semantics></math> qui donnera
une erreur opposée à celui du calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi></mrow><annotation encoding='application/x-tex'>s</annotation></semantics></math> à la ligne
suivante, le 2ième calcul effectué <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>s</mi></mrow><annotation encoding='application/x-tex'>(s+x)&#x2d;s</annotation></semantics></math> donne une erreur
absolue en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo stretchy="false">&vert;</mo><mi>x</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>\epsilon |x|</annotation></semantics></math> au pire (car c’est une erreur relative
par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>s</mi></mrow><annotation encoding='application/x-tex'>(s+x)&#x2d;s</annotation></semantics></math>), 
et la 3ième erreur d’arrondi est négligeable
(puisque la somme vaut 0). On a donc une erreur absolue sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>s+c</annotation></semantics></math>
qui est au premier ordre au pire en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>&epsi;</mi><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(\epsilon \sum|x_i|)</annotation></semantics></math>, 
bien meilleure que
la majoration <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mn>2</mn></msub><mo stretchy="false">&vert;</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo stretchy="false">&vert;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\epsilon ((n&#x2d;1)|x_1|+(n&#x2d;2)|x_2|+...+|x_n||)</annotation></semantics></math>
calculée précédemment.</p><p>Par exemple

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">n:=25000; l:=seq(1/j,j,1,n):; Somme(l);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

à comparer avec

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">S:=sum(1/j,j,1,n):; evalf(S); sum(1. /j,j,1,n);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

(le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi></mrow><annotation encoding='application/x-tex'>S</annotation></semantics></math> est fait en exact, celui de <span style="font-family:monospace">sum(1. /j,j,1,n)</span>
est approché sans correction).</p><p>En conclusion, il est souvent très difficile de calculer une majoration
rigoureuse de l’erreur pour des calculs (sauf les plus simples), et cette
majoration est en général bien trop pessimiste.
Lorsqu’on doute de la précision d’un calcul, un test peu couteux consiste
à refaire ce calcul en utilisant des flottants en précision plus
grande et tester si le résultat varie en fonction du nombre de chiffres
significatifs utilisés, ou faire varier légèrement
les données et observer la sensibilité du résultat.
Si on veut travailler en toute rigueur sans
pour autant calculer les erreurs à priori, il faut utiliser un logiciel
utilisant des intervalles pour représenter les réels (section suivante)</p>
<!--TOC section id="sec20" L’arithmétique d’intervalle.-->
<h2 id="sec20" class="section">3.3  L’arithmétique d’intervalle.</h2><!--SEC END --><p><a id="hevea_default16"></a></p><p>Certains systèmes de calcul formel peuvent manipuler directement
des intervalles réels, par exemple par l’intermédiaire de la
bibliothèque C MPFI. Les opérations arithmétiques sur des
intervalles renvoient alors le meilleur intervalle possible contenant
toutes les valeurs possibles lorsque les opérandes parcourent
leurs intervalles respectifs.
Exemple en Xcas (version 1.1.1 et ultérieures) :
<code>[-1..2]*[-1..2]</code> renvoie <code>[-2..4]</code>.
Attention ici on parcourt toutes les valeurs possibles de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>y</mi><mo>,</mo><mspace width="mediummathspace"/><mi>x</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo><mo>,</mo><mi>y</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>xy, \ x \in [&#x2d;1,2], y \in [&#x2d;1,2]</annotation></semantics></math>. Ce qui est différent du carré
d’un intervalle ou plus généralement de l’évaluation
d’un polynôme en un intervalle, <code>horner(x^2,[-1..2])</code>
renvoie ainsi <code>[0..4]</code>.</p><p>Les fonctions disponibles sont souvent moins riches qu’en
arithmétique flottante, le calcul d’une fonction non monotone
sur un intervalle peut s’avérer délicat, alors que si la fonction
est monotone, il suffit de calculer l’image des deux bornes
de l’intervalle. Pour les polynômes, Xcas décompose
les coefficients en deux parties <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>P</mi> <mo>+</mo></msub><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>P</mi> <mo>&minus;</mo></msub></mrow><annotation encoding='application/x-tex'>P=P_+&#x2d;P_&#x2d;</annotation></semantics></math> en fonction
du signe, puis utilise la monotonie de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mo>+</mo></msub></mrow><annotation encoding='application/x-tex'>P_+</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mo>&minus;</mo></msub></mrow><annotation encoding='application/x-tex'>P_&#x2d;</annotation></semantics></math> sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mo>+</mo></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^+</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>&Ropf;</mi> <mo>&minus;</mo></msup></mrow><annotation encoding='application/x-tex'>\mathbb{R}^&#x2d;</annotation></semantics></math> respectivement.</p><p>L’arithmétique d’intervalle dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{C}</annotation></semantics></math> est beaucoup plus difficile
à mettre en oeuvre puisqu’il n’y a plus d’ordre ni de monotonie,
on doit alors s’en remettre à des estimations sur les parties
réelles et imaginaires qui ne tiendront pas compte du phénomène
ci-dessus sur la différence entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>y</mi><mo>,</mo><mspace width="mediummathspace"/><mi>x</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo><mo>,</mo><mi>y</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>xy, \ x \in [&#x2d;1,2], y \in [&#x2d;1,2]</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>,</mo><mspace width="mediummathspace"/><mi>x</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>x^2, \ x \in [&#x2d;1,2]</annotation></semantics></math>.</p>
<!--TOC section id="sec21" Calcul exact et approché, types, évaluation.-->
<h2 id="sec21" class="section">3.4  Calcul exact et approché, types, évaluation.</h2><!--SEC END --><p><a id="hevea_default17"></a>
Dans les langages de programmation traditionnel (C, Pascal,...), il existe 
déjà des types permettant une représentation 
exacte des données (type entier) ou une représentation approchée 
(type flottant). Mais ces types de donnée de base 
occupent une taille fixe en mémoire, le type entier est donc
limité à un intervalle d’entiers (par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mn>2</mn> <mn>32</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,2^{32}&#x2d;1]</annotation></semantics></math> pour un entier
non signé sur une machine utilisant un processeur 32 bits) alors que le 
type flottant peut représenter des nombres réels, mais est 
limité à une précision en nombre de digits de la mantisse et de l’exposant 
(par exemple 12 chiffres significatifs et un 
exposant compris entre -499 et 499). </p><p>En calcul formel, on souhaite pouvoir calculer rigoureusement d’une part, 
et avec des paramètres dont la valeur n’est 
pas connue d’autre part ; il faut donc s’affranchir de ces limites : 
</p><ul class="itemize"><li class="li-itemize">
pour les entiers relatifs, on utilise des entiers de 
<em>précision arbitraire</em>
dont la taille en mémoire est dynamique (déterminée pendant l’exécution et non
à la compilation),
</li><li class="li-itemize">pour les nombres complexes, on utilise un couple de nombres réels,
</li><li class="li-itemize">pour les rationnels, on utilise un couple d’entiers relatifs,
</li><li class="li-itemize">pour les irrationnels algébriques (par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math>), 
on utilise un polynôme irréductible dont ils sont racines,
</li><li class="li-itemize">pour les paramètres (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>,</mo><mi>t</mi><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>x,y,z,t...</annotation></semantics></math>), on utilise un type 
structuré contenant un champ de type chaine de caractères pour 
représenter le nom du paramètre et
un champ pour attribuer une valeur à (ou une hypothèse sur) ce paramètre,
</li><li class="li-itemize">pour les nombres transcendants (par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&pi;</mi></mrow><annotation encoding='application/x-tex'>\pi</annotation></semantics></math>), on est obligé
d’introduire un paramètre auquel on attribue une valeur numérique, 
qui ne sera utilisée qu’au moment où on veut une 
approximation numérique d’une expression contenant ce nombre transcendant,
on parle de constante,
</li><li class="li-itemize">lorsqu’on a besoin d’une approximation numérique d’un nombre,
on peut utiliser des conversions de ces types en un type flottant. On peut 
aussi pour lutter contre les erreurs 
d’arrondi utiliser des nombres flottants étendus dont la précision est 
dynamique ou même des intervalles de flottants étendus,
</li><li class="li-itemize">il faut aussi
un nouveau type, appelé expression ou symbolique, permettant d’appliquer
une fonction qu’on ne peut évaluer directement sur les objets précédents,
par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sin(x)</annotation></semantics></math>. Il
doit s’agir d’une opération de clôture, au sens où appliquer une fonction à
un objet symbolique ne nécessite pas la création d’un nouveau type
(en général on renvoie un objet symbolique).
</li></ul><p>Enfin, il faut pouvoir évaluer un objet (en particulier symbolique) :
par exemple évaluer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sin(x)</annotation></semantics></math> lorsqu’on assigne une valeur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>. 
Dans cet exemple, on voit qu’il faut d’abord remplacer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> par
sa valeur avant de lui appliquer la fonction sinus. C’est le mécanisme
général de l’évaluation, mais il y a quelques exceptions où
on souhaite empêcher l’évaluation d’un ou plusieurs arguments
d’une fonction avant l’évaluation de la fonction. Par exemple si on 
veut calculer la valeur numérique d’une intégrale par des méthodes
de quadrature, on ne souhaitera pas rechercher une primitive de la 
fonction à intégrer. Dans le jargon, on parle alors de “quoter” un argument 
(l’origine du terme vient probablement de la notation <code>'</code> du langage 
Lisp). Certaines fonctions doivent toujours quoter leurs arguments
(par exemple la fonction qui permet de purger le contenu d’un paramètre),
on parle parfois d’autoquotation.</p>
<!--TOC section id="sec22" Forme normale et reconnaissance du 0.-->
<h2 id="sec22" class="section">3.5  Forme normale et reconnaissance du 0.</h2><!--SEC END --><p>
Une fois défini ces types de base représentant les nombres d’un système de 
calcul formel, il faut pouvoir comparer ces 
nombres, en particulier décider si deux représentations distinctes 
correspondent au même nombre ou, ce qui revient au 
même, par soustraction décider quand un nombre est nul. 
Par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>4</mn><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>4/2</annotation></semantics></math> et 2 représentent le même nombre. 
Lorsqu’on dispose d’un algorithme permettant de représenter un nombre 
d’une manière unique, on parle de forme normale. 
C’est par exemple le cas pour les nombres rationnels, la forme normale 
usuelle est la fraction irréductible de 
dénominateur positif. C’est aussi le cas pour les fractions rationnelles 
de polynômes à coefficients entiers représentées par une fraction 
irréductible, avec au dénominateur un coefficient de plus haut degré
positif.
Malheureusement, il n’est pas toujours possible de trouver une forme normale
pour diverses raisons théoriques ou pratiques : 
</p><ul class="itemize"><li class="li-itemize">
on ne connaît pas toujours le statut de certaines constantes
(par exemple la constante d’Euler),
</li><li class="li-itemize">il n’existe pas d’algorithmes permettant de déterminer
s’il existe des relations algébriques entre constantes,
</li><li class="li-itemize">il n’existe pas forcément une seule forme plus simple, par exemple :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><msqrt><mn>2</mn></msqrt><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>x</mi><mo>+</mo><msqrt><mn>2</mn></msqrt><mo>+</mo><mn>1</mn></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>x</mi><mo>+</mo><msqrt><mn>2</mn></msqrt><mo>&minus;</mo><mn>1</mn></mrow><mrow><mo stretchy="false">(</mo><msqrt><mn>2</mn></msqrt><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \frac{(\sqrt{2}+1)x+1}{x+\sqrt{2}+1}=\frac{x+\sqrt{2}&#x2d;1}{(\sqrt{2}&#x2d;1)x+1}  </annotation></semantics></math>
Ce cas se présente fréquemment avec les extensions algébriques.
</li><li class="li-itemize">en pratique il peut être trop coûteux d’utiliser une forme
normale, par exemple le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>1000</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x^{1000}&#x2d;1)/(x&#x2d;1)</annotation></semantics></math> possède 1000 monômes
</li></ul><p>
En résumé, au mieux on a une forme normale, au pire on risque de ne pas 
reconnaître un zéro, entre les deux on peut ne
pas avoir de forme normale mais être capable de reconnaître à coup sûr 
une expression nulle (par contre, si le système 
de calcul formel détermine qu’une expression est nulle, alors elle l’est).</p><p>Il n’existe pas d’algorithme solution
pour le problème de la reconnaissance du zéro pour une classe 
d’expressions "assez générale". Heureusement, 
dans la plupart des cas pratiques on sait résoudre ce problème, en
se ramenant le plus souvent au cas des polynômes et fractions rationnelles.
Par exemple, pour simplifier une expression trigonométrique,
on remplace les fonctions trigonométriques <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mi>cos</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mi>tan</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\sin(x), \cos(x), \tan(x)</annotation></semantics></math>
par leur expression en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mi>tan</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>t=\tan(x/2)</annotation></semantics></math>, on est ainsi ramené
à une fraction rationnelle en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> que l’on écrit sous forme normale.</p><p>Les polynômes ont un rôle central dans tout système de calcul formel
puisque sauf dans les cas les plus simples (fractions d’entiers par exemple), 
la simplification d’expressions
fait appel à un moment ou à un autre à des calculs
de PGCD de polynômes. Le PGCD de polynômes est un algorithme 
très sollicité auquel nous consacrerons une section. En effet,
l’application brutale de l’algorithme d’Euclide pose des problèmes
d’efficacité ce qui a obligé à inventer des méthodes plus efficaces.
Anticipons rapidement sur un exemple qui montre l’un des problèmes
majeurs des algorithmes de calcul formel, l’explosion en taille
(ici des coefficients des restes successifs).
Voici donc les restes successifs lorsqu’on applique l’algorithme
d’Euclide pour calculer le PGCD de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>7</mn></msup><mo>&minus;</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>6</mn></msup></mrow><annotation encoding='application/x-tex'>P(x)=(x+1)^{7}&#x2d;(x&#x2d;1)^{6}</annotation></semantics></math> avec
sa dérivée (les deux polynômes sont premiers entre eux) :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mn>7</mn><mo>&times;</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>6</mn></msup><mo>&minus;</mo><mn>6</mn><mo>&times;</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mn>5</mn></msup></mtd> <mtd/> <mtd/></mtr> <mtr><mtd><mfrac><mn>162</mn><mn>49</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>390</mn></mrow><mn>49</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mfrac><mn>1060</mn><mn>49</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>780</mn></mrow><mn>49</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mfrac><mn>474</mn><mn>49</mn></mfrac><mo>&times;</mo><mi>x</mi><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>78</mn></mrow><mn>49</mn></mfrac></mtd> <mtd/> <mtd/></mtr> <mtr><mtd><mfrac><mn>157780</mn><mn>729</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>507640</mn></mrow><mn>2187</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mfrac><mn>290864</mn><mn>729</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>101528</mn></mrow><mn>729</mn></mfrac><mo>&times;</mo><mi>x</mi><mo>+</mo><mfrac><mn>28028</mn><mn>729</mn></mfrac></mtd> <mtd/> <mtd/></mtr> <mtr><mtd><mfrac><mn>1</mn><mn>49</mn></mfrac><mo>&times;</mo><mo stretchy="false">(</mo><mfrac><mn>1400328</mn><mn>2645</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>732888</mn></mrow><mn>2645</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mfrac><mn>1133352</mn><mn>3703</mn></mfrac><mo>&times;</mo><mi>x</mi><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>732888</mn></mrow><mn>18515</mn></mfrac><mo stretchy="false">)</mo></mtd> <mtd/> <mtd/></mtr> <mtr><mtd><mfrac><mn>1</mn><mn>2187</mn></mfrac><mo>&times;</mo><mo stretchy="false">(</mo><mfrac><mn>2161816376832</mn><mn>4669921</mn></mfrac><mo>&times;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>555436846944</mn></mrow><mn>4669921</mn></mfrac><mo>&times;</mo><mi>x</mi><mo>+</mo><mfrac><mn>301917024864</mn><mn>4669921</mn></mfrac><mo stretchy="false">)</mo></mtd> <mtd/> <mtd/></mtr> <mtr><mtd><mfrac><mn>1</mn><mn>907235</mn></mfrac><mo>&times;</mo><mo stretchy="false">(</mo><mfrac><mn>469345063045455</mn><mn>129411872</mn></mfrac><mo>&times;</mo><mi>x</mi><mo>+</mo><mfrac><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>47641670106615</mn></mrow><mn>129411872</mn></mfrac><mo stretchy="false">)</mo></mtd> <mtd/> <mtd/></mtr> <mtr><mtd><mfrac><mn>5497465490623352995840</mn><mn>209648836272383412129</mn></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
7\* (x+1)^{6}&#x2d;6\* (x&#x2d;1)^{5} &amp; &amp;\\
\frac{162}{49} \* x^{5}+\frac{&#x2d;390}{49} \* x^{4}+\frac{1060}{49} \* x^{3}+\frac{&#x2d;780}{49} \* x^{2}+\frac{474}{49} \* x+\frac{&#x2d;78}{49}&amp; &amp;\\
\frac{157780}{729} \* x^{4}+\frac{&#x2d;507640}{2187} \* x^{3}+\frac{290864}{729} \* x^{2}+\frac{&#x2d;101528}{729} \* x+\frac{28028}{729}&amp; &amp;\\
\frac{1}{49} \* (\frac{1400328}{2645} \* x^{3}+\frac{&#x2d;732888}{2645} \* x^{2}+\frac{1133352}{3703} \* x+\frac{&#x2d;732888}{18515})&amp; &amp;\\
\frac{1}{2187} \* (\frac{2161816376832}{4669921} \* x^{2}+\frac{&#x2d;555436846944}{4669921} \* x+\frac{301917024864}{4669921})&amp; &amp;\\
\frac{1}{907235} \* (\frac{469345063045455}{129411872} \* x+\frac{&#x2d;47641670106615}{129411872})&amp; &amp;\\
\frac{5497465490623352995840}{209648836272383412129}
 \end{matrix} </annotation></semantics></math>
Le lecteur voulant tester d’autres exemples pourra utiliser le programme 
<code>Xcas</code> suivant :

</p><pre class="verbatim">pgcdderiv(a):={
  local b,r,res;
  b:=diff(a,x);
  res:=NULL;
  for (;b!=0;){
    res:=res,b;
    r:=rem(a,b);
    a:=b;
    b:=r;
  }
  return(res);
}
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>



<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">P:=(x+1)^7-(x-1)^6;pgcdderiv(P)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC section id="sec23" Valeur générique des variables et
hypothèses-->
<h2 id="sec23" class="section">3.6  Valeur générique des variables et
hypothèses</h2><!--SEC END --><p><a id="hevea_default18"></a> <a id="hevea_default19"></a>
Lorsqu’on utilise un symbole sans lui affecter de valeurs en mathématiques 
on s’attend à une discussion en fonction du 
paramètre représenté par ce symbole. Ce qui nécessiterait de créer un 
arborescence de calculs (on retrouve ici les problèmes 
d’explosion évoqués dans la section précédente). 
La plupart des systèmes de calcul formel contournent la difficulté en 
supposant que le paramètre possède une valeur 
générique (par exemple la solution de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>t</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>x</mi><mo>=</mo><mi>t</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>(t^2&#x2d;1)x=t&#x2d;1</annotation></semantics></math> sera <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x=1/(t+1)</annotation></semantics></math>) ou 
choisissent une branche pour les fonctions 
possédant un point de branchement (par exemple pour résoudre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>=</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>x^2=t</annotation></semantics></math> 
en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>). Certains systèmes demandent de 
manière interactive à l’utilisateur si la variable est par exemple positive 
ou différente de 1 mais cela s’oppose à un 
traitement automatique. 
On peut aussi anticiper ce type de décision en faisant des hypothèses
sur une paramètre, la plupart des systèmes de calcul formel actuel
proposent cette possibilité.</p>
<!--TOC section id="sec24" Structures de données-->
<h2 id="sec24" class="section">3.7  Structures de données</h2><!--SEC END --><p>
On a vu plus haut qu’on souhaitait manipuler des entiers de taille non 
fixe, des réels de précision fixe ou non, des
fractions, des nombres complexes, des extensions algébriques, des 
paramètres, des expressions symboliques. La plupart des systèmes
proposent un type générique qui recouvre ces divers types de scalaire.
On peut par exemple utiliser un type structuré comportant un champ
type et la donnée ou un pointeur sur la donnée (avec dans ce cas un 
pointeur sur un compteur de références de la donnée
pour pouvoir la détruire dès qu’elle n’est plus référencée<sup><a id="text1" href="#note1">1</a></sup>). 
En programmation orientée objet, on utiliserait plutôt un
type abstrait dont dérivent ces différents scalaires et le polymorphisme.</p><p>Il faut aussi un type pour les vecteurs, les matrices et les
listes. Il faut prendre garde à la méthode utilisée
par le système lorsqu’on modifie un élément
d’un vecteur, matrice ou liste : soit on effectue une copie de tout
l’objet en modifiant l’élément, soit on modifie l’élément
de l’objet original. La première méthode (par valeur) est
plus aisée à comprendre pour un débutant mais
la seconde méthode (par référence) est bien plus efficace.</p><p>On peut se poser la question de savoir s’il faut inclure 
ces types dans le type générique ; en général la 
réponse est affirmative, une des raisons étant que les 
interpréteurs qui permettront de lire des données dans un 
fichier texte sont en général basé sur le couple de logiciels
<code>lex(flex)/yacc(bison)</code> qui ne peut compiler qu’à destination d’un 
seul type. Ceci permet également d’unifier en un seul type symbolique 
les fonctions ayant un ou plusieurs arguments en 
voyant plusieurs arguments comme un vecteur d’arguments. 
Les fonctions sont le plus souvent elle-même incluses dans le 
type générique permettant ainsi à l’utilisateur de saisir des 
commandes ou programmes fonctionnels (on peut
utiliser une fonction comme argument d’une commande).</p><p>Pour des raisons d’efficacité, les systèmes de calcul formel
utilisent souvent des représentations particulières pour les polynômes
dont on a dit qu’ils jouaient un rôle central.
Pour les polynômes à une variable,
on peut utiliser la liste des coefficients du polynôme, on parle
alors de représentation dense. On peut aussi décider de ne stocker
que les coefficients non nuls, on parle alors de représentation creuse
(on stocke alors un couple formé par le coefficient et le degré
du monôme correspondant). Pour les polynômes à plusieurs variables,
on peut les considérer comme des polynômes à une variable à
coefficients polynomiaux, on parle alors de représentation récursive.
On peut aussi décider de ne pas briser la symétrie entre les
variables (pas de variable principale), on parle alors de représentation
distribuée, le plus souvent les représentation distribuées
sont creuses car les représentations
denses nécessitent très vite beaucoup de coefficients. Les méthodes
de représentation creuses sont parfois aussi utilisées pour les
matrices ayant beaucoup de coefficients nuls.</p><p>Voyons maintenant plus précisément sur quelques exemples de logiciels
de calcul formel répandus quelles structures de données sont
utilisées. Plusieurs éléments entrent en compte dans les choix faits :
</p><ul class="itemize"><li class="li-itemize">
le(s) profil(s) d’utilisation (enseignement, ingéniérie,
calcul intensif, recherche)
</li><li class="li-itemize">les ressources disponibles (mémoire, puissance du processeur...)
</li><li class="li-itemize">la facilité d’implémentation (choix du langage, outils
disponibles en particulier débuggueurs, ...)
</li><li class="li-itemize">l’histoire du système (un système conçu avec les outils
disponibles aujourd’hui est forcément différent d’un système 
conçu il y a 20 ans)
</li></ul><p>
Voyons quelques exemples, d’abord Giac, puis des systèmes 
pour ordinateur où les ressources
(par exemple mémoire) sont moins limitées ce qui permet 
d’utiliser des langages de programmation de plus haut niveau.
On termine par les calculatrices formelles
HP et TI des années 2000<sup><a id="text2" href="#note2">2</a></sup>.
Ce sont des systèmes plutôt destinés à l’enseignement, soumis 
à de fortes contraintes en termes de taille mémoire, et destinés
à traiter des petits problèmes.</p>
<!--TOC subsection id="sec25" Maple, Mathematica, ...-->
<h3 id="sec25" class="subsection">3.7.1  Maple, Mathematica, ...</h3><!--SEC END --><p>
Ces systèmes ont un noyau fermé, au sens où l’utilisateur n’a pas
accès du tout, ou en tout cas pas facilement, aux structures de données
de base. Je ne dispose donc pas d’information sur les structures de données
utilisées par le noyau.</p><p>L’interaction système-utilisateur se fait quasiment toujours en utilisant le
langage de programmation propre au système, langage interprété
par le noyau du système (ce qui ralentit l’exécution). Ces langages 
utilisateurs sont essentiellement
non typés : on travaille avec des variables du type générique sans pouvoir
accéder aux types sous-jacents. On ne bénéficie en général pas des
vérifications faites lors de la compilation avec un langage typé,
de plus ces systèmes ne sont pas toujours fourni avec de bon outils de 
mise au point. Enfin ces langages ne sont pas standardisés d’un
système à l’autre et il est en général impossible
d’utiliser ces systèmes comme des librairies depuis un langage
de programmation traditionnel. Leur intérêt principal réside donc
dans une utilisation interactive en profitant de la librairie de 
fonctions accessibles.</p>
<!--TOC subsection id="sec26" Giac/Xcas-->
<h3 id="sec26" class="subsection">3.7.2  Giac/Xcas</h3><!--SEC END --><p>
Il s’agit du système de calcul formel que j’implémente actuellement sous 
forme d’une bibliothèque C++ (ce qui
permettra aux programmes tiers d’utiliser beaucoup plus facilement du 
calcul formel qu’avec les systèmes précédents). L’objectif est 
d’avoir un système facile à programmer directement en C++, proche 
du langage utilisateur, lui-même compatible avec Maple ou MuPAD, 
tout cela sans trop perdre en performances comparativement aux
librairies spécialisées écrites en C/C++. Ce qui explique un choix 
de type générique (<code>gen</code>) non orienté objet, avec un champ type 
et soit une donnée immédiate (pour les nombres flottants par exemple), 
soit un pointeur vers un objet du type correspondant au champ type pour 
les données de taille non fixe (on pourrait donc se
contenter du langage C, mais le langage C++ permet de redéfinir 
les opérateurs sur des types utilisateurs ce qui
améliore considérablement la lisibilité du code source). 
Les données dynamiques ne sont pas dupliquées, Giac
utilise un pointeur sur un compteur de référence pour détruire 
ces données lorsqu’elles ne sont plus référencées.</p><p>Les entiers en précision arbitraire sont hérités de la bibliothque
GMP (écrite en C) du projet GNU. Les flottants en précision arbitraire
utiliseront aussi GMP (plus précisément MPFR).
Il y a un type fraction, structure C composé d’un champ numérateur
et d’un champ dénominateur, et un type nombre complexe.</p><p>Les listes, vecteurs, matrices utilisent le type paramétré <code>vector&lt;&gt;</code>
de la librairie standard C++ (Standard Template Library).
Les objets symboliques sont des structures composés d’un champ sommet
qui est une fonction prenant un argument de type <code>gen</code>
et renvoyant un résultat
de type <code>gen</code>, et d’un champ feuille qui est de type <code>gen</code>.
Lorsqu’une fonction possède plusieurs arguments, ils sont rassemblés
en une liste formant le champ feuille de l’objet symbolique.
Les programmes sont aussi des objets symboliques, dont le champ
sommet est la fonction évaluation d’un programme.
Les listes sont aussi utilisées pour représenter vecteurs, matrices
et polynômes en une variable en représentation dense, on peut
y accéder par valeur (<code>:=</code>) ou par référence
(<code>=&lt;</code>). Ces polynômes servent eux-mêmes á représenter
des éléments d’une 
<span style="font-weight:bold">extension algébrique</span><a id="hevea_default20"></a><a id="hevea_default21"></a> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Q}</annotation></semantics></math> (vus comme
un couple de polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>,</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>P,Q</annotation></semantics></math>, où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est un polynome minimal
irréductible à coefficients entiers, autrement dit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>,</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>P,Q</annotation></semantics></math> vaut <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(\alpha)</annotation></semantics></math> 
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>Q(\alpha)=0</annotation></semantics></math>),
ou des éléments d’un corps fini (comme ci-dessus, mais ici <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est
à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> premier, cf. la commande <code>GF</code>).
Giac posséde aussi un type pour les polynômes
en représentation creuse distribuée en plusieurs
indéterminées (cf. les commandes <code>symb2poly</code> et <code>poly2symb</code>).</p><p>L’évaluation d’un objet symbolique se fait en regardant d’abord si
la fonction au sommet doit évaluer ou non ses arguments (autoquote),
on évalue les arguments si nécessaire puis on applique la fonction.</p><p>Une hypthèse sur un paramètre est une valeur spéciale
affectée au paramètre, valeur ignorée par la routine d’évaluation.</p>
<!--TOC subsection id="sec27" Calculatrices formelles HP48/49-->
<h3 id="sec27" class="subsection">3.7.3  Calculatrices formelles HP48/49</h3><!--SEC END --><p>
Les langages utilisés pour programmer ces calculateurs sont l’assembleur
et le RPL (Reverse Polish Lisp) adapté à l’écriture de code
en mémoire morte très compact.</p><p>Le type générique est implémenté avec un champ type appelé prologue (qui est
en fait un pointeur sur la fonction chargée d’évaluer ce type d’objet)
suivi de la donnée elle-même (et non d’un pointeur sur la donnée, on
économise ainsi la place mémoire du compteur de référence).</p><p>Le type entier en précision arbitraire est codé par le nombre de digits 
(sur 5 quartets<sup><a id="text3" href="#note3">3</a></sup>) suivi du signe sur un 
quartet et de la représentation BCD (en base 10) de la valeur absolue de 
l’entier. Le choix de la représentation BCD a été fait pour optimiser 
les temps de conversion en chaîne de caractères pour l’affichage. La mémoire
vive disponible est de 256K, c’est elle qui limite la taille des entiers 
et non le champ longueur de l’entier. Il n’y a pas de type spécifique 
pour les rationnels (on utilise un objet
symbolique normal). </p><p>Les fonctions internes des HP49/50/40 utilisent 
le type programme pour représenter les entiers de Gauß (complexes
dont la partie réelle et imaginaire est entière).
Les nombres algébriques ne sont pas implémentés, sauf les racines carrées
(représentée de manière interne par le type programme). 
Il y a un type spécifique prévu pour les flottants en précision arbitraire, 
mais l’implémentation des opérations sur ces types
n’a pas été intégrée en ROM à ce jour. </p><p>Les types listes, programmes et objet symbolique sont composés du prologue
(champ type) suivi par la succession d’objets situés en
mémoire vive ou de pointeurs sur des objets situés en mémoire en lecture 
seule (ROM) et se terminent par un pointeur sur une
adresse fixe (appelée <code>SEMI</code>). Ces types sont eux-mêmes des 
objets et peuvent donc être utilisés de manière
récursive. La longueur des types listes, programmes, symboliques 
n’est stockée nulle part, c’est le délimiteur final
qui permet de la connaître, ce qui est parfois source d’inefficacité.
On utilise de manière interne les listes pour représenter les 
polynômes denses (avec 
représentation récursive pour les polynômes à plusieurs variables). </p><p>Les calculatrices HP4xG utilisent une pile<sup><a id="text4" href="#note4">4</a></sup>, c’est-à-dire une liste
de taille non fixée d’objets. On place les objets sur la pile,
l’exécution d’une fonction prend ces arguments sur
la pile et renvoie un ou plusieurs résultats sur la pile (ce qui est
une souplesse du RPN comparé aux langages où on ne peut renvoyer
qu’une valeur de retour). Il faut donc
donner les arguments avant d’appeler la fonction correspondante. Par
exemple pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>a+b</annotation></semantics></math> on tapera <code>a b +</code>. C’est
la syntaxe dite polonaise inversée (RPN). Un avantage de cette syntaxe
est que le codage d’un objet symbolique par cette syntaxe est évidente,
il suffit de stocker la liste précédente <code>{a b +}</code>.
Les objets symboliques sont donc représenté par une suite d’objets écrit
en syntaxe polonaise inversée. L’évaluation d’un objet symbolique se fait
dans l’ordre polonaise inversé : les arguments sont évalués
puis les fonctions leur sont appliqués. Pour des raisons d’efficacité, 
on représente souvent les objets composites (listes, symboliques) par 
leurs composants placés sur la pile (appelé meta-objets).</p><p>Une rigidité de la syntaxe polonaise est
que les fonctions ont toujours un nombre fixe d’arguments<sup><a id="text5" href="#note5">5</a></sup>, par
exemple l’addition a toujours 2 arguments, ainsi
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>a+b+c</annotation></semantics></math> est obtenu par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>(a+b)+c</annotation></semantics></math> ou par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>a+(b+c)</annotation></semantics></math>
c’est-à-dire respectivement <code>a b + c +</code> ou <code>a b c + +</code> ce qui
brise parfois artificiellement la symétrie de certaines opérations. En
polonaise inversée, le système doit de plus jongler avec l’autoquote puisque
les arguments sont évalués avant l’opérateur qui éventuellement demanderait
à ne pas évaluer ses arguments. À noter l’existence d’une commande 
<code>QUOTE</code> permettant à l’utilisateur de quoter une sous-expression.</p><p>Les hypothèses sur des variables réelles sont regroupées dans une liste
stockée dans la variable globale <code>REALASSUME</code>, on peut supposer
qu’une variable est dans un intervalle. Il n’y a pas à ce jour
de possibilité de supposer qu’une variable est entière (ni à fortiori
qu’une variable à une valeur modulo un entier fixé), bien qu’il ait été
décidé de réserver la variable globale <code>INTEGERASSUME</code> à cet effet.
Il n’y a pas de possibilité de faire des hypothèses ayant une portée
locale.</p>
<!--TOC subsection id="sec28" Calculatrices formelles TI92/89/Voyage 200-->
<h3 id="sec28" class="subsection">3.7.4  Calculatrices formelles TI92/89/Voyage 200</h3><!--SEC END --><p>
Le langage utilisé pour programmer ces calculatrices est le langage C
(on peut aussi écrire du code en assembleur pour ces calculatrices).
On retrouve ici les différents types de données regroupé en un
type générique qui est un tableau d’octets (aussi appelé quantum). 
Le champ type
est appelé tag dans la documentation TI. Contrairement à ce qui
précède, ce champ type est placé en mémoire à la fin de l’objet,
ce qui est possible car la longueur d’un objet est toujours indiquée
au début de l’objet. Ceci est fait afin de faciliter l’évaluation (cf.
infra).</p><p>Les entiers en précision arbitraire sont codés par un tag parmi deux (pour
différencier le signe), un octet pour la longueur, puis la valeur
absolue de l’entier (en base 256). Ils sont donc limités par le
champ longueur à 255 octets, le plus grand entier représentable est
<sup><a id="text6" href="#note6">6</a></sup> <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mn>256</mn> <mn>255</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(256^{255}&#x2d;1)</annotation></semantics></math>.
Il existe un tag spécifique pour les rationnels, pour les constantes 
réelles et entières qui apparaissent par exemple en résolvant une équation.
Il existe des tags utilisés de manière interne, par exemple
pour les nombres complexes. 
Il n’y a pas de tag prévu pour les flottants en précision arbitraire.
ni pour les nombres algébriques (racines carrées par 
exemple).</p><p>Les listes sont codées par la succession de leurs éléments. En principe
elles ne peuvent pas contenir des listes (sauf pour représenter
une matrice).
Quelques fonctions utilisent les listes pour représenter des polynômes 
denses à une variable, mais probablement pas pour représenter de manière
récursive des polynômes à plusieurs variables (puisque le type liste
n’est en principe pas récursif).</p><p>Comme les HP, les TI utilisent une pile (non visible par
l’utilisateur) appelée expression stack
afin de traduire un expression mathématique sous forme d’un texte
en un objet symbolique codé exactement comme ci-dessus en syntaxe
polonaise. Toutefois, la présence du champ longueur
permet d’évaluer un objet symbolique sans perdre en efficacité
en partant de l’opérateur
final et en redescendant ensuite sur ces arguments, c’est la stratégie
adoptée. C’est pour cela que le tag d’identification
se trouve à la fin de l’objet. L’utilisation de cette méthode
facilite grandement l’autoquotation (on peut toutefois regretter
que le système n’ait pas prévu d’instruction permettant à l’utilisateur 
d’empêcher l’évaluation d’une sous-expression).</p><p>On ne peut pas faire d’hypothèse globale sur un paramètre par
contre on peut faire des hypothèses de type appartenance à un intervalle 
ayant une portée locale.</p>
<!--TOC section id="sec29" Algorithmes et complexité.-->
<h2 id="sec29" class="section">3.8  Algorithmes et complexité.</h2><!--SEC END --><p>
On va présenter dans la suite quelques algorithmes que l’on peut
considérer comme classiques dans le domaine du calcul formel. Avant 
d’implémenter ce type d’algorithmes, on a besoin des algorithmes de base
en arithmétique. </p><p>La plupart des problèmes posés en calcul formel nécessitent des
calculs dont la taille croit de manière exponentielle voire
doublement exponentielle en fonction de la taille des données et
ce même si le résultat est lui aussi de taille petite. Un
exemple est la réduction des systèmes de plusieurs équations polynomiales
(bases de Groebner).</p>
<!--TOC subsection id="sec30" Algorithmes modulaires ou p-adiques-->
<h3 id="sec30" class="subsection">3.8.1  Algorithmes modulaires ou p-adiques</h3><!--SEC END --><p>
Dans certains cas, l’application de théories mathématiques
parfois sophistiquées permet de réduire la complexité (par exemple,
M. Van Hoeij a découvert récemment qu’un algorithme très utilisé en théorie des
nombres, l’algorithme LLL, permettait d’améliorer la complexité d’une des
étapes de la factorisation des polynomes à coefficients entiers sur les
entiers). Heureusement, dans de nombreux cas, on peut réduire la
complexité (donc le temps de calcul) par des adaptations au
problème d’une même idée à condition de faire des
hypothèses sur les données (autrement dit en abandonnant la volonté
d’implémenter un algorithme très générique, ou tout au moins
en spécialisant des algorithmes génériques).
Par exemple lorsqu’on travaille
avec des entiers (ou des polynômes à coefficients entiers, ou
des matrices à coefficients entiers...) on utilise souvent des algorithmes
modulaires et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-adiques. Comme le calcul exact nécessite
presque toujours de calculer avec des entiers, ces méthodes
ont un rôle central en calcul formel, nous les présentons donc
maintenant brièvement. Dans les prochaines sections, nous utiliserons
ce type de méthode, par exemple pour le calcul de PGCD ou la factorisation
de polynômes à coefficients entiers.</p><p>Les méthodes <span style="font-weight:bold">modulaires</span><a id="hevea_default22"></a> consistent à réduire un problème dans 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> à son équivalent dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math> pour une ou 
plusieurs valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, nombre premier. Le calcul dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math>
a l’avantage de se faire avec des entiers dont la taille est bornée.
Ensuite à l’aide d’estimations 
à priori sur la taille des solutions 
éventuelles du problème initial, on reconstruit la solution au problème
initial avec le théorème des restes chinois. </p><p>Par exemple, on peut calculer un déterminant d’une matrice
à coefficients entiers en cherchant ce déterminant dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math>
pour plusieurs nombres premiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, dont le produit est deux fois plus grand qu’une 
estimation à priori de la taille du déterminant 
(donnée par exemple par l’inégalité d’Hadamard, cf. Cohen, p. 50). </p><p>Les méthodes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math><span style="font-weight:bold">-adiques</span><a id="hevea_default23"></a> commencent de manière identique par un 
calcul dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math>, on augmente ensuite la
précision de la solution en la «liftant»de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>n</mi> <mi>k</mi></msup><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n^k \mathbb{Z}</annotation></semantics></math> vers 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>n</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n^{k+1}\mathbb{Z}</annotation></semantics></math> ou vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>n</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n^{2k}\mathbb{Z}</annotation></semantics></math> (lift
linéaire ou lift quadratique), on s’arrête lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est assez grand 
(à l’aide d’estimations à priori) et on
reconstruit alors la solution initiale. L’étape de «lift»est en 
général un lemme de Hensel dont on verra quelques exemples dans les
prochains articles. L’algorithme
commun au lemme de Hensel et au théorème des restes chinois est 
l’identité de Bézout, que l’on retrouve 
d’ailleurs un peu partout (par exemple pour le calcul de primitives). </p><p>Illustrons cette méthode sur un exemple simple, la recherche de 
<span style="font-weight:bold">racines rationnelles</span><a id="hevea_default24"></a> d’un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi> <mi>d</mi></msub><msup><mi>X</mi> <mi>d</mi></msup><mo>+</mo><mi>&ctdot;</mi><mo>+</mo><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P(X)=a_d X^d + \cdots + a_0</annotation></semantics></math> 
à coefficients entiers ou polynomiaux, avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>a_d</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>a_0</annotation></semantics></math> non nuls. 
L’algorithme générique (assez connu) consiste 
à chercher les diviseurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>a_0</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>a_d</annotation></semantics></math> et à tester toutes 
les fractions de ces diviseurs, on montre en effet 
aisément que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>=</mo><mi>p</mi><mo stretchy="false">/</mo><mi>q</mi></mrow><annotation encoding='application/x-tex'>X=p/q</annotation></semantics></math> fraction irréductible est racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> 
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>a_d</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>a_0</annotation></semantics></math>. Cet 
algorithme est très inefficace si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>a_d</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>a_0</annotation></semantics></math> est un grand entier 
(car on ne sait pas forcément le factoriser) ou 
s’il a beaucoup de facteurs premiers (la liste des diviseurs à tester 
est alors très grande). </p><p>Lorsque les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> sont entiers, la recherche précédente 
revient à trouver un facteur à
coefficients entiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mi>X</mi><mo>&minus;</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>qX&#x2d;p</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, on peut donc réduire le problème 
modulo un entier premier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> qui ne divise pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>a_d</annotation></semantics></math> : si un tel facteur 
existe dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> alors ce facteur (réduit modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>) est un facteur 
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> admet une racine dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math> (puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> est inversible 
modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> car on a choisi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> premier ne divisant pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>a_d</annotation></semantics></math>). On
évalue maintenant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> en les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> éléments de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math>. S’il n’y a pas 
de 0, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> n’a pas de racine rationnelle. S’il y a des racines, on va 
les lifter de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>n</mi> <mi>k</mi></msup><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n^k\mathbb{Z}</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>n</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n^{2k}\mathbb{Z}</annotation></semantics></math>.</p><p>On suppose donc que pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&geq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k\geq 1</annotation></semantics></math>, il existe un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>p_k</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>p</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>n</mi> <mi>k</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> P(p_k)=0 \pmod{n^k}  </annotation></semantics></math>
Il s’agit de trouver un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>p</mi> <mi>k</mi></msub><mo>+</mo><msup><mi>n</mi> <mi>k</mi></msup><mo>&times;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>p_{k+1}=p_k+n^k \* x</annotation></semantics></math>
vérifie
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>p</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>n</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> P(p_{k+1})=0 \pmod{n^{2k}}  </annotation></semantics></math>
On applique la formule de Taylor à l’ordre 1 pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>p_k</annotation></semantics></math>, le
reste est nul modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>n^{2k}</annotation></semantics></math>, donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>p</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msup><mi>n</mi> <mi>k</mi></msup><mo>&times;</mo><mi>x</mi><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>p</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>n</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> P(p_k)+ n^k \* x P&apos;(p_k)=0 \pmod{n^{2k}}  </annotation></semantics></math>
soit finalement :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>p</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><mrow><msup><mi>n</mi> <mi>k</mi></msup></mrow></mfrac><mo>&times;</mo><mo stretchy="false">(</mo><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>p</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>n</mi> <mi>k</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'> x=&#x2d;\frac{P(p_k)}{n^k} \* ( P&apos;(p_k) \pmod{n^k}) ^{&#x2d;1}  </annotation></semantics></math>
On reconnaît au passage la méthode de Newton<a id="hevea_default25"></a>, pour qu’elle fonctionne 
il suffit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>p</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P&apos;(p_k) \neq 0 \pmod n</annotation></semantics></math> ce qui
permet de l’inverser modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>n^k</annotation></semantics></math> (et c’est ici qu’intervient 
l’identité de Bézout). En pratique quand on factorise
un polynôme, on commence par retirer les multiplicités, 
on peut donc supposer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est sans facteur multiple dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>. Ceci n’entraîne pas forcément qu’il le reste dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math> 
ce qui crée une contrainte supplémentaire sur le choix
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, à savoir que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math> restent premier entre eux dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math> 
(il existe forcément de tels <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, par exemple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> premier plus grand que le plus grand entier intervenant dans le calcul 
du PGCD de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>).</p><p>Reste donc à revenir dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> à partir d’une racine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>p_k</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msup><mi>n</mi> <mi>k</mi></msup><mi>&Zopf;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/(n^k \mathbb{Z})</annotation></semantics></math>
(où on peut choisir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>). 
On va maintenant utiliser la représentation 
<span style="font-weight:bold">modulaire symétrique</span><a id="hevea_default26"></a> :
on prend comme représentant modulaire d’un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>n</mi> <mi>k</mi></msup><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n^k\mathbb{Z}</annotation></semantics></math>
l’unique entier congru à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> qui est strictement compris entre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>n</mi> <mi>k</mi></msup><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>&#x2d;n^k/2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mi>k</mi></msup><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n^k/2</annotation></semantics></math> (si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est pair, la deuxième inégalité
est choisie large).</p><p>Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mi>X</mi><mo>&minus;</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>qX&#x2d;p</annotation></semantics></math> est un facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub><mi>X</mi><mo>&minus;</mo><mfrac><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><mi>q</mi></mfrac><mi>p</mi></mrow><annotation encoding='application/x-tex'>a_dX&#x2d;\frac{a_d}{q}p</annotation></semantics></math> est encore 
un facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> (le quotient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub><mi>X</mi><mo>&minus;</mo><mfrac><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><mi>q</mi></mfrac><mi>p</mi></mrow><annotation encoding='application/x-tex'>a_dX&#x2d;\frac{a_d}{q}p</annotation></semantics></math>
est à coefficients rationnels mais le facteur est à coefficients entiers). 
Si on a choisi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mi>k</mi></msup><mi>&gt;</mi><mn>2</mn><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>d</mi></msub><msub><mi>a</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>n^k&amp;gt;2|a_d a_0|</annotation></semantics></math>, l’écriture en représentation
modulaire symétrique de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub><mi>X</mi><mo>&minus;</mo><mfrac><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><mi>q</mi></mfrac><mi>p</mi></mrow><annotation encoding='application/x-tex'>a_dX&#x2d;\frac{a_d}{q}p</annotation></semantics></math> est inchangée,
en effet on a des estimations à priori sur les entiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> : 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>q</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>d</mi></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|q|\leq |a_d|</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>p</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|p| \leq |a_0|</annotation></semantics></math> puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> 
divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>a_d</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>a_0</annotation></semantics></math>. 
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub><mi>X</mi><mo>&minus;</mo><mfrac><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><mi>q</mi></mfrac><mi>p</mi></mrow><annotation encoding='application/x-tex'>a_dX&#x2d;\frac{a_d}{q}p</annotation></semantics></math> est égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>p</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>a_d(X&#x2d;p_k)</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msup><mi>n</mi> <mi>k</mi></msup><mi>&Zopf;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/(n^k \mathbb{Z})</annotation></semantics></math>,
il nous suffit d’écrire en représentation modulaire 
symétrique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>p</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi> <mi>d</mi></msub><mi>X</mi><mo>&minus;</mo><mi>p</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>a_d(X&#x2d;p_k)=a_d X&#x2d;p&apos;</annotation></semantics></math>.
Pour conclure, on sait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub><mi>X</mi><mo>&minus;</mo><mi>p</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>a_d X&#x2d;p&apos;</annotation></semantics></math> est un multiple entier de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mi>X</mi><mo>&minus;</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>qX&#x2d;p</annotation></semantics></math>.
On divise donc le facteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub><mi>X</mi><mo>&minus;</mo><mi>p</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>a_d X&#x2d;p&apos;</annotation></semantics></math> par le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>a_d</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>p&apos;</annotation></semantics></math> et on
teste la divisibilité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par ce facteur réduit.</p><p><span style="font-weight:bold">Exemple</span><br>
Considérons le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><msup><mi>X</mi> <mn>3</mn></msup><mo>&minus;</mo><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>X</mi><mo>&minus;</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>2 X^3&#x2d;X^2&#x2d;X&#x2d;3</annotation></semantics></math> qui est sans facteur carré.
On ne peut pas choisir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n=2</annotation></semantics></math> car on réduirait le degré, pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>n=3</annotation></semantics></math>,
on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo>=</mo><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P&apos;=X&#x2d;1</annotation></semantics></math> qui est facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>n=5</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo>=</mo><mn>6</mn><msup><mi>X</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn><mi>X</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P&apos;=6X^2&#x2d;2X&#x2d;1</annotation></semantics></math>,
on vérifie que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math> sont premiers entre eux (par exemple
avec <code>GCDMOD</code> sur une HP49 où on aura fixé la variable <code>MODULO</code>
à 5).</p><p>On teste ensuite les entiers de -2 à 2 sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Seul -1 est racine
modulo 5 (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>P(&#x2d;1)=&#x2d;5</annotation></semantics></math>), on va maintenant lifter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mn>1</mn></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p_1=&#x2d;1</annotation></semantics></math>. </p><p>L’estimation à priori est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mi>d</mi></msub><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><msub><mi>a</mi> <mn>0</mn></msub><mo stretchy="false">&vert;</mo><mo>=</mo><mn>12</mn></mrow><annotation encoding='application/x-tex'>2|a_d||a_0|=12</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>k=2</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>5</mn> <mn>2</mn></msup><mo>=</mo><mn>25</mn><mi>&gt;</mi><mn>12</mn></mrow><annotation encoding='application/x-tex'>5^2=25&amp;gt;12</annotation></semantics></math>), 
une itération suffira. On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>7</mn></mrow><annotation encoding='application/x-tex'>P&apos;(&#x2d;1)=7</annotation></semantics></math>, l’inverse de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>5</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P&apos;(&#x2d;1) \pmod 5</annotation></semantics></math>
est -2 donc:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>5</mn></mfrac><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&times;</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'> x= &#x2d;\frac{P(&#x2d;1)}{5} (&#x2d;2) = &#x2d;(&#x2d;1) \* (&#x2d;2)=&#x2d;2  </annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mn>2</mn></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>+</mo><mn>5</mn><mo>&times;</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>11</mn></mrow><annotation encoding='application/x-tex'>p_2=&#x2d;1+5\times(&#x2d;2)=&#x2d;11</annotation></semantics></math> est racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>25</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/25\mathbb{Z}</annotation></semantics></math>.
On calcule ensuite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>d</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>p</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>11</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mi>X</mi><mo>+</mo><mn>22</mn><mo>=</mo><mn>2</mn><mi>X</mi><mo>&minus;</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>a_d(X&#x2d;p_k)=2(X+11)=2X+22=2X&#x2d;3</annotation></semantics></math> en représentation
symétrique, le PGCD de 2 et -3 est 1 donc on teste le facteur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>X</mi><mo>&minus;</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>2X&#x2d;3</annotation></semantics></math>, ici il divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> admet un unique facteur entier
de degré 1 qui est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>X</mi><mo>&minus;</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>2X&#x2d;3</annotation></semantics></math>.</p>
<!--TOC subsection id="sec31" Algorithmes déterministes. Algorithmes probabilistes: Las Vegas
et Monte-Carlo-->
<h3 id="sec31" class="subsection">3.8.2  Algorithmes déterministes. Algorithmes probabilistes: Las Vegas
et Monte-Carlo</h3><!--SEC END --><p><a id="hevea_default27"></a><a id="hevea_default28"></a><a id="hevea_default29"></a><a id="hevea_default30"></a>
L’algorithme p-adique présenté ci-dessus est un algorithme
déterministe, il renvoie toujours un résultat certifié et 
le temps de calcul nécessaire à son exécution ne dépend
pas du hasard (sauf si on choisit le nombre premier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> au hasard...).
Ce type d’algorithmes est parfois trop long par rapport 
à d’autres type d’algorithmes utilisant le hasard :
</p><ul class="itemize"><li class="li-itemize">
les algorithmes de type Las Vegas. Ceux-ci utilisent un 
élément aléatoire (dont dépend le temps d’exécution) mais
certifient le résultat. Par exemple pour calculer le polynôme
caractéristique d’une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, on choisit 
un vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> aléatoirement
et on cherche une relation linéaire entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>,</mo><mi>M</mi><mi>v</mi><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>M</mi> <mi>n</mi></msup><mi>v</mi></mrow><annotation encoding='application/x-tex'>v,Mv,...,M^nv</annotation></semantics></math>,
s’il n’y en a qu’une à constante multiplicative près, alors
elle donne le polynôme caractéristique, sinon on se rabat
sur une autre méthode (ou on renvoie une erreur).
</li><li class="li-itemize">les algorithmes de type Monte-Carlo. Ceux-ci utilisent un
élément aléatoire mais ne certifient pas le résultat, qui a
une très faible probabilité d’être inexact. Par exemple,
pour calculer un déterminant d’une matrice à coefficients
entiers, on peut faire le calcul modulo plusieurs nombres
premiers et reconstruire le résultat par le théorème
des restes chinois et décider de s’arrêter lorsque
le résultat reconstruit est stable pour un, deux, ... nombres
premiers. L’inverse de la probabilité d’erreur est égale
au produit des nombres premiers pour lesquel on observe la
stabilité. Autre exemple: le test de pseudo-primalité
de Miller-Rabin.
</li></ul><p>
Dans Xcas, certains algorithmes sont de type Monte-Carlo par
défaut, notamment le calcul de déterminant de grandes matrices
à coefficients entiers ou de bases de Gröbner, et un warning
s’affiche alors. La variable
<code>proba_epsilon</code> permet de régler le niveau de probabilité
d’erreur acceptée, on peut la mettre à 0 pour forcer l’utilisation
d’algorithmes déterministes ou de type Las Vegas avec certification
du résultat. Si l’on fait des calculs à but expérimental pour
établir une conjecture, il n’est pas nécessaire de certifier un
calcul et il ne sert à rien de mettre <code>proba_epsilon</code> à 0.
Par contre, pour établir une preuve (au sens mathématique du terme) qui
nécessite un calcul fait sur machine,
on prendra soin de mettre <code>proba_epsilon</code> à 0. 
On remarquera au passage que ce type de
preuve ne peut se faire qu’avec un logiciel open-source, puisqu’il
faut aussi pouvoir montrer que l’algorithme utilisé
est correctement implémenté.</p>
<!--TOC section id="sec32" Quelques algorithmes d’arithmétique de base.-->
<h2 id="sec32" class="section">3.9  Quelques algorithmes d’arithmétique de base.</h2><!--SEC END --><ul class="itemize"><li class="li-itemize">
Les algorithmes de multiplication et division dit rapides
des entiers et polynômes (Karatsuba, FFT, ...). Cf. par exemple Knuth.
ou pour les entiers la documentation de GMP, ou infra pour Karatsuba.
</li><li class="li-itemize">Au lieu de la division euclidienne, on utilise très souvent la
<span style="font-weight:bold">pseudo-division</span><a id="hevea_default31"></a> pour les polynômes : étant donné deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> de degrés <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> à coefficients dans un anneau contenu dans un corps
(par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>), on multiplie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> par une puissance du coefficient
dominant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mi>b</mi></msub></mrow><annotation encoding='application/x-tex'>B_b</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>, plus précisément par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>B</mi> <mi>b</mi> <mrow><mi>a</mi><mo>&minus;</mo><mi>b</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding='application/x-tex'>B_b^{a&#x2d;b+1}</annotation></semantics></math>, ce qui permet 
d’effectuer la division par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> sans que
les coefficients sortent de l’anneau.
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mi>B</mi> <mi>b</mi> <mrow><mi>a</mi><mo>&minus;</mo><mi>b</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mi>A</mi><mo>=</mo><mi>B</mi><mi>Q</mi><mo>+</mo><mi>R</mi></mrow><annotation encoding='application/x-tex'> B_b^{a&#x2d;b+1} A= B Q + R  </annotation></semantics></math>
On utilise cette méthode lorsqu’on peut multiplier les polynômes par
des constantes sans changer le problème (par exemple pour l’algorithme
d’Euclide).
</li><li class="li-itemize">L’algorithme d’Euclide est un algorithme «générique»de calcul
de PGCD. Il n’est en général pas utilisé tel quel. Pour les entiers 
on utilise une variation adaptée à la
représentation binaire des entiers (cf. Cohen ou le manuel de GMP version 4 
pour plus de détails). Nous décrirons des
algorithmes de PGCD plus efficaces pour les polynômes dans le prochain article.
</li><li class="li-itemize">l’<span style="font-weight:bold">identité de Bézout</span><a id="hevea_default32"></a>, aussi appelée PGCD étendu. Étant donné
deux entiers ou deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> tels que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>u</mi><mo>+</mo><mi>b</mi><mi>v</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>au+bv=d</annotation></semantics></math>. On écrit la matrice :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="left left left"><mtr><mtd><mi>a</mi></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mi>b</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> \left( \begin{array}{lll}
a &amp; 1 &amp; 0 \\
b &amp; 0 &amp; 1
\end{array} \right)  </annotation></semantics></math>
où on remarque que pour chaque ligne le coefficient de la 1ère colonne 
est égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> multiplié par le coefficient de la
2ème colonne additionné à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> multiplié par le coefficient de la 
3ème colonne. Ce qui reste vrai si on effectue des
combinaisons linéaires de lignes (type réduction de Gauß). 
Comme on travaille dans les entiers ou les polynômes, on remplace la
réduction de Gauß des matrices à coefficients réels par une combinaison 
linéaire utilisant le quotient <em>euclidien</em> (entier ou polynomial
selon le cas) <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math>
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>. On obtient alors le reste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> en 1ère colonne :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="right left left left"><mtr><mtd><msub><mi>L</mi> <mn>1</mn></msub></mtd> <mtd><mi>a</mi></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><msub><mi>L</mi> <mn>2</mn></msub></mtd> <mtd><mi>b</mi></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><msub><mi>L</mi> <mn>3</mn></msub><mo>=</mo><msub><mi>L</mi> <mn>1</mn></msub><mo>&minus;</mo><mi>q</mi><msub><mi>L</mi> <mn>2</mn></msub></mtd> <mtd><mi>r</mi></mtd> <mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>q</mi></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>  \left( \begin{array}{rlll}
L_1 &amp; a &amp; 1 &amp; 0 \\
L_2 &amp; b &amp; 0 &amp; 1 \\
L_3=L_1&#x2d;qL_2 &amp; r &amp; 1 &amp; &#x2d;q
\end{array} \right)  </annotation></semantics></math>
et on recommence jusqu’à obtenir 0 en 1ère colonne.
L’avant-dernière ligne obtenue est l’identité de Bézout (la dernière
ligne donne les cofacteurs du PPCM de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>). 
Si l’on veut l’inverse de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> modulo
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> on remarque qu’il n’est pas utile de calculer les coefficients
appartenant à la 3ème colonne. Enfin, les lignes intermédiaires
peuvent servir à reconstruire une fraction d’entier représentée
par un entier de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math> lorsque le numérateur et le dénominateur
sont de valeur absolue inférieure à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mrow><mi>n</mi><mo stretchy="false">/</mo><mn>2</mn></mrow></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{n/2}</annotation></semantics></math>. Exemple :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">step_infolevel:=1;iegcd(1234,357);step_infolevel:=0 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
Voir aussi dans Xcas la session exemple depuis le menu Exemple,arit,bezout.xws.
</li><li class="li-itemize">Le théorème des <span style="font-weight:bold">restes chinois</span><a id="hevea_default33"></a><a id="hevea_default34"></a>. 
Si on connaît <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x=a \pmod m</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>b</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x= b \pmod n </annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> premiers entre eux,
on détermine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>c</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><mi>m</mi><mo>&times;</mo><mi>n</mi></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x=c \pmod{m\times n}</annotation></semantics></math>. On a donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mo>+</mo><mi>m</mi><mi>u</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>n</mi><mi>v</mi></mrow><annotation encoding='application/x-tex'>c=a+mu=b+nv</annotation></semantics></math> et on applique
Bézout pour trouver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi></mrow><annotation encoding='application/x-tex'>u</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>, on en déduit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math>. En pratique,
on cherche un des coefficients de Bézout, par exemple on cherche <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math>
tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mi>U</mi><mo>+</mo><mi>n</mi><mi>V</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>mU+nV=1</annotation></semantics></math>, on a alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>c</mi><mo>=</mo><mi>a</mi><mo>+</mo><mi>m</mi><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mi>U</mi></mrow><annotation encoding='application/x-tex'> c=a+m (b&#x2d;a)U  </annotation></semantics></math>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est petit devant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> (par exemple 32 bits), <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> est aussi petit,
on commence par réduire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><annotation encoding='application/x-tex'>b&#x2d;a</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>,
puis on multiplie par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math>, on réduit à nouveau modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> et on
multiple enfin par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math>.
</li><li class="li-itemize">L’algorithme de <span style="font-weight:bold">Hörner</span><a id="hevea_default35"></a>
pour évaluer un polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>X</mi> <mi>n</mi></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P(X)=a_nX^n+...+a_0</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>. Il consiste à réécrire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(x)</annotation></semantics></math> sous
la forme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msub><mi>a</mi> <mi>n</mi></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mi>x</mi><mo>+</mo><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>P(x)=(...((a_nx+a_{n&#x2d;1})x+a_{n&#x2d;2})x+...+a_1)x+a_0 </annotation></semantics></math>
on calcule donc successivement 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>b</mi> <mi>n</mi></msub><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><mo>,</mo><mspace width="mediummathspace"/><msub><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>b</mi> <mi>n</mi></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mspace width="mediummathspace"/><msub><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>.</mo><mspace width="mediummathspace"/><msub><mi>b</mi> <mn>0</mn></msub><mo>=</mo><msub><mi>b</mi> <mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>a</mi> <mn>0</mn></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>b_n=a_n, \ b_{n&#x2d;1}=b_nx+a_{n&#x2d;1}, \ b_{n&#x2d;2}=b_{n&#x2d;1}x+a_{n&#x2d;2},
.... \ b_0=b_1x+a_0=P(x) </annotation></semantics></math>
ce qui nécessite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> multiplications et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> additions, donc une
complexité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n)</annotation></semantics></math> (sur un corps fini ou un anneau dont les
opérations se font en temps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(1)</annotation></semantics></math>) avec une constante optimale.
Voir aussi l’exercice sur cette méthode et son application au calcul
du développement de Taylor d’un polynôme
dans la section <a href="#sec%3Aexos_algobase">3.11</a>.
Voir aussi la session exemple depuis le menu Exemples, poly, horner.xws.
</li><li class="li-itemize">La puissance rapide et les tests de pseudo-primalité. Il est essentiel d’avoir une
méthode rapide permettant de générer des nombres premiers pour appliquer
des méthodes modulaires et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-adiques. On utilise souvent le
<span style="font-weight:bold">test de Miller-Rabin</span><a id="hevea_default36"></a><a id="hevea_default37"></a>, qui prolonge le petit théorème de Fermat
(si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> est premier, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mi>p</mi></msup><mo>=</mo><mi>a</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a^p=a \pmod p</annotation></semantics></math>). Voir le manuel de
programmation de Xcas.
</li></ul>
<!--TOC subsection id="sec33" Exemple de multiplication rapide : l’algorithme de Karatsuba-->
<h3 id="sec33" class="subsection">3.9.1  Exemple de multiplication rapide : l’algorithme de Karatsuba</h3><!--SEC END --><p><a id="hevea_default38"></a>
Soient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>,</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>P, Q</annotation></semantics></math> deux polynômes de degrés strictement inférieur à
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding='application/x-tex'>2n</annotation></semantics></math>. On suppose que le cout d’une opération arithmétique dans le
corps des coefficients vaut 1 et on néglige les autres
opérations (on suppose par exemple que le corps des coefficients
est un corps fini). On écrit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>=</mo><mi>A</mi><mo>+</mo><msup><mi>x</mi> <mi>n</mi></msup><mi>B</mi><mo>,</mo><mspace width="1em"/><mi>Q</mi><mo>=</mo><mi>C</mi><mo>+</mo><msup><mi>x</mi> <mi>n</mi></msup><mi>D</mi></mrow><annotation encoding='application/x-tex'> P=A+x^n B, \quad Q=C+x^n D </annotation></semantics></math>
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo>,</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'>A,B,C,D</annotation></semantics></math> de degrés strictement inférieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, on a
alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mi>Q</mi><mo>=</mo><mi>A</mi><mi>C</mi><mo>+</mo><msup><mi>x</mi> <mi>n</mi></msup><mo stretchy="false">(</mo><mi>A</mi><mi>D</mi><mo>+</mo><mi>B</mi><mi>C</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mi>x</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msup><mi>B</mi><mi>D</mi></mrow><annotation encoding='application/x-tex'>P Q = AC + x^n(AD+BC)+x^{2n} BD </annotation></semantics></math>
Il y a 4 produits de polynômes de degrés <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><mi>n</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;n</annotation></semantics></math>, mais au prix
d’additions intermédiaires, on peut se ramener à 3 produits, en
effet
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>+</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>C</mi><mo>+</mo><mi>D</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>A</mi><mi>C</mi><mo>&minus;</mo><mi>B</mi><mi>D</mi><mo>=</mo><mi>A</mi><mi>D</mi><mo>+</mo><mi>B</mi><mi>C</mi></mrow><annotation encoding='application/x-tex'>(A+B)(C+D)&#x2d;AC&#x2d;BD = AD+BC </annotation></semantics></math>
donc pour calculer le cofacteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>x^n</annotation></semantics></math> il suffit de soustraire
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>+</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>C</mi><mo>+</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(A+B)(C+D)</annotation></semantics></math> les produits <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding='application/x-tex'>AC</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mi>D</mi></mrow><annotation encoding='application/x-tex'>BD</annotation></semantics></math> que l’on calcule par
ailleurs.
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>M(n)</annotation></semantics></math> le temps nécessaire pour calculer le produit de 2
polynômes par cette méthode, on a alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mi>M</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mn>8</mn><mi>n</mi></mrow><annotation encoding='application/x-tex'>M(2n) = 3M(n)+ 8n </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>8</mn><mi>n</mi></mrow><annotation encoding='application/x-tex'>8n</annotation></semantics></math> représente le nombre d’additions ou de soustractions
pour former <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding='application/x-tex'>A+B</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo>+</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'>C+D</annotation></semantics></math>, soustraire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding='application/x-tex'>AC</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mi>D</mi></mrow><annotation encoding='application/x-tex'>BD</annotation></semantics></math>, et tenir compte
des "retenues" (les termes de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&geq;</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>\geq n</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding='application/x-tex'>AC</annotation></semantics></math> se combinent
avec ceux de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><mn>2</mn><mi>n</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;2n</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>D</mi><mo>+</mo><mi>B</mi><mi>C</mi></mrow><annotation encoding='application/x-tex'>AD+BC</annotation></semantics></math> et les termes de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><mn>3</mn><mi>n</mi></mrow><annotation encoding='application/x-tex'>&amp;lt; 3n</annotation></semantics></math>
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msup><mi>B</mi><mi>D</mi></mrow><annotation encoding='application/x-tex'>x^{2n}BD</annotation></semantics></math> avec ceux de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&geq;</mo><mn>2</mn><mi>n</mi></mrow><annotation encoding='application/x-tex'>\geq 2n</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mi>D</mi><mo>+</mo><mi>B</mi><mi>C</mi></mrow><annotation encoding='application/x-tex'>AD+BC</annotation></semantics></math>).
On en déduit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub><mo>=</mo><mi>M</mi><mo stretchy="false">(</mo><msup><mn>2</mn> <mi>n</mi></msup><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>3</mn><msub><mi>u</mi> <mi>n</mi></msub><mo>+</mo><mn>8</mn><mo>&times;</mo><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>u_n=M(2^n), \quad u_{n+1}=3u_n+8 \times 2^n  </annotation></semantics></math> 
cette récurrence se résoud facilement par la commande<br>
<code>rsolve(u(n+1)=3*u(n)+8*2^n,u(n),u(0)=1)</code><br>
qui donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><msup><mn>2</mn> <mi>n</mi></msup><mo stretchy="false">)</mo><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>8</mn><mo>&sdot;</mo><msup><mn>2</mn> <mi>n</mi></msup><mo>+</mo><mn>9</mn><mo>&sdot;</mo><msup><mn>3</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>M(2^n)=u_n=&#x2d;8\cdot 2^{n}+9\cdot 3^{n}</annotation></semantics></math>.</p><p>Asymptotiquement, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><msup><mn>2</mn> <mi>n</mi></msup><mo stretchy="false">)</mo><mo>&approx;</mo><mn>9</mn><mo>&sdot;</mo><msup><mn>3</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>M(2^n) \approx 9\cdot 3^{n}</annotation></semantics></math> ce qui est bien
meilleur que la multiplication naive en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo>&sdot;</mo><msup><mn>4</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>2 \cdot 4^n</annotation></semantics></math>, mais pour de
petites valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, la multiplication naive est plus rapide, on
utilise Karatsuba (récursivement) uniquement pour des valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
suffisamment grandes (théoriquement lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>8</mn><mi>n</mi></mrow><annotation encoding='application/x-tex'>8n</annotation></semantics></math>, le surcout dû
aux additions est plus petit que la multiplication économisée,
soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>8</mn><mi>n</mi><mi>&lt;</mi><mn>2</mn><msup><mi>n</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>8n&amp;lt;2n^2</annotation></semantics></math> soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&gt;</mi><mn>4</mn></mrow><annotation encoding='application/x-tex'>n&amp;gt;4</annotation></semantics></math>, en pratique plutôt pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> de l’ordre de quelques
dizaines selon les implémentations, car nous n’avons tenu compte
que des opérations arithmétiques).</p>
<!--TOC subsection id="sec34" Calcul de la racine carrée entière-->
<h3 id="sec34" class="subsection">3.9.2  Calcul de la racine carrée entière</h3><!--SEC END --><p>
Étant donné un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>, il s’agit de déterminer le plus grand
entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>n</mi> <mn>2</mn></msup><mo>&leq;</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>n^2\leq N</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est la racine
carrée<a id="hevea_default39"></a> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>.
On choisit une base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>b=10</annotation></semantics></math> pour un humain ou une
puissance de 2 pour une machine, et on écrit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> en base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>, en
découpant les chiffres par blocs de 2 en commençant par la
droite, par exemple 2 00 00 00. On initialise la racine carrée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> à 0
et son carré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> à 0, on va calculer la racine carrée entière bloc par bloc en
commençant par la gauche. Pour calculer le bloc suivant, on
multiplie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>b</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>b^2</annotation></semantics></math> (c’est un simple décalage de
l’écriture en ajoutant un ou deux zéros). Puis on ajoute les
nombres impairs successifs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2n+1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>(2n+1)+2</annotation></semantics></math>, ... à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> tant que l’on est
inférieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> tronqué au bloc. Le nombre d’impairs successifs
ajouté est ajouté à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. En pratique, il suffit de conserver
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>N&#x2d;c</annotation></semantics></math> tronqué et de lui retrancher les impairs successifs.</p><p>Ainsi, pour 2 00 00 00, au 1er bloc 2, on initialise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>n=c=0</annotation></semantics></math>, on
ajoute <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2n+1=1</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> qui vaut alors 1 et on s’arrête car 1+3
est supérieur à 2. On passe au 2ième bloc, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>N&#x2d;c</annotation></semantics></math> tronqué vaut
100, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> vaut 10, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2n+1</annotation></semantics></math> vaut 21, on retranche donc à 100
successivement 21, 23, 25, 27 et on s’arrête car le reste est
4. Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> devient 14, et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mi>c</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>N&#x2d;c=4</annotation></semantics></math>. On passe au troisième bloc,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mi>c</mi><mo>=</mo><mn>400</mn></mrow><annotation encoding='application/x-tex'>N&#x2d;c=400</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>140</mn></mrow><annotation encoding='application/x-tex'>n=140</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>281</mn></mrow><annotation encoding='application/x-tex'>2n+1=281</annotation></semantics></math>, on retranche de 400 les impairs
successifs à partir de 281, ce qui n’est possible qu’une seule fois,
cela donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mi>c</mi><mo>=</mo><mn>119</mn></mrow><annotation encoding='application/x-tex'>N&#x2d;c=119</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>141</mn></mrow><annotation encoding='application/x-tex'>n=141</annotation></semantics></math>. On passe au dernier bloc,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>&minus;</mo><mi>c</mi><mo>=</mo><mn>11900</mn></mrow><annotation encoding='application/x-tex'>N&#x2d;c=11900</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>1410</mn></mrow><annotation encoding='application/x-tex'>n=1410</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>2821</mn></mrow><annotation encoding='application/x-tex'>2n+1=2821</annotation></semantics></math>, on soustrait
2821, 2823, 2825, 2827 de 11900, il reste 604 et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>1414</mn></mrow><annotation encoding='application/x-tex'>n=1414</annotation></semantics></math>.</p><p>Exercice : calculer la quatrième décimale de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math> de cette
manière.</p><p>La complexité de cet algorithme est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mi>log</mi> <mi>b</mi></msub><mo stretchy="false">(</mo><mi>N</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(\log_b(N)^2)</annotation></semantics></math>. En effet,
pour calculer un chiffre il faut faire un nombre de soustraction au
plus égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>, ces soustractions ayant au plus le nombre de
chiffres de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> en base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>.
(On peut accélérer le calcul à la manière de Karatsuba en
choisissant une base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> puissance de 2 (ou 10) de l’ordre de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>N</mi></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{N}</annotation></semantics></math> et en divisant pour régner).</p><pre class="verbatim">isqrt(x):={
  local l,j,k,s,n,N,res;
  l:=revlist(convert(x,base,100));
  res:=seq(0,size(l));
  s:=0;
  N:=0;
  pour k de 0 jusque size(l)-1 faire
    N := (N-s)*100+l[k];
    n:=2*horner(res[0..k],10)+1;
    s:=n; // ajout de la somme des impairs consecutifs
    pour j de 0 jusque 10 faire
      si s&gt;N alors break; fsi;
      n+=2;
      s+=n;
    fpour;
    s -= n;
    res[k]:=j;
  fpour;
  retourne horner(res,10);
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>



<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">isqrt(2*10^8)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p>
<!--TOC subsection id="sec35" Bezout sur les entiers et les fractions continues-->
<h3 id="sec35" class="subsection">3.9.3  Bezout sur les entiers et les fractions continues</h3><!--SEC END --><p>
Il existe une variante de l’identité de Bézout présentée
ci-dessus pour les entiers. Soient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>&geq;</mo><mi>b</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>a\geq b&amp;gt;0</annotation></semantics></math> deux entiers, on pose
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>L</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mspace width="1em"/><mi>a</mi><msub><mi>u</mi> <mi>n</mi></msub><mo>&minus;</mo><mi>b</mi><msub><mi>v</mi> <mi>n</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup><msub><mi>r</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>(L_n) \quad a u_n &#x2d; b v_n = (&#x2d;1)^n r_n  </annotation></semantics></math> 
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mn>0</mn></msub><mo>=</mo><mi>a</mi><mo>,</mo><msub><mi>r</mi> <mn>1</mn></msub><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>r_0=a, r_1=b</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{n+2}</annotation></semantics></math> est le reste de la division
euclidienne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>r_n</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>r</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>r_{n+1}</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>q</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>q_{n+2}</annotation></semantics></math> le quotient), <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mn>0</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>u</mi> <mn>1</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>v</mi> <mn>0</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>v</mi> <mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>u_0=1, u_1=0, v_0=0,v_1=1</annotation></semantics></math>.
Comme précedemment, chaque ligne s’obtient par combinaison
linéaire des deux précédentes, mais cette fois avec une addition
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>L</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>L</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>q</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><msub><mi>L</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>L_{n+2}=L_n+q_{n+2} L_{n+1} </annotation></semantics></math> 
ce qui se traduit par :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>u</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>q</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mspace width="1em"/><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>v</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>q</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>u_{n+2}=u_n+q_{n+2} u_{n+1}, \quad v_{n+2}=v_n+q_{n+2} v_{n+1} </annotation></semantics></math>
Les suites <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>v_n</annotation></semantics></math> sont alors strictement croissantes (à
partir du rang 1 pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math>). Au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> du dernier reste non nul on
a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>a</mi><msub><mi>u</mi> <mi>k</mi></msub><mo>&minus;</mo><mi>b</mi><msub><mi>v</mi> <mi>k</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup><msub><mi>r</mi> <mi>k</mi></msub><mo>,</mo><mspace width="1em"/><msub><mi>r</mi> <mi>k</mi></msub><mo>=</mo><mi>d</mi><mo>=</mo><mtext>gcd</mtext><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>a u_k &#x2d; b v_k = (&#x2d;1)^k r_k, \quad r_k=d=\mbox{gcd}(a,b) </annotation></semantics></math>
et au rang suivant :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>a</mi><msub><mi>u</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><mi>b</mi><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>au_{k+1} &#x2d;b v_{k+1}=0 </annotation></semantics></math>
On montre par récurrence que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>v</mi> <mi>n</mi></msub><msub><mi>r</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>r</mi> <mi>n</mi></msub><mo>=</mo><mi>a</mi></mrow><annotation encoding='application/x-tex'>v_n r_{n+1} + v_{n+1} r_n=a </annotation></semantics></math>
et une relation analogue pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>u_n</annotation></semantics></math>, on en déduit alors que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>a</mi><mo stretchy="false">/</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>v_{k+1}=a/d</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>b</mi><mo stretchy="false">/</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>u_{k+1}=b/d</annotation></semantics></math> (ce sont les cofacteurs du PPCM de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math>), 
en particulier les coefficients de
Bézout vérifient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mi>k</mi></msub><mi>&lt;</mi><mi>b</mi></mrow><annotation encoding='application/x-tex'>u_k&amp;lt;b</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>k</mi></msub><mi>&lt;</mi><mi>a</mi></mrow><annotation encoding='application/x-tex'>v_k&amp;lt;a</annotation></semantics></math>.</p><p>On va aussi voir que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo stretchy="false">/</mo><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>u_{n+2}/v_{n+2}</annotation></semantics></math> est la <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>-ième réduite du
développement
en fractions continues de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">/</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>a/b</annotation></semantics></math> (donc les coefficients de Bézout
se lisent sur l’avant-dernière réduite). On introduit la notation
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>a</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>a</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>a</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>=</mo><msub><mi>a</mi> <mn>0</mn></msub><mo>+</mo><mfrac><mn>1</mn><mrow><msub><mi>a</mi> <mn>1</mn></msub><mo>+</mo><mfrac><mn>1</mn><mrow><msub><mi>a</mi> <mn>2</mn></msub><mo>+</mo><mfrac><mrow><mo>.</mo><mo>.</mo><mo>.</mo></mrow><mrow><msub><mi>a</mi> <mi>k</mi></msub></mrow></mfrac></mrow></mfrac></mrow></mfrac></mrow><annotation encoding='application/x-tex'>[a_0,a_1,..,a_n] =a_0+\frac{1}{a_1+\frac{1}{a_2+\frac{...}{a_k}}} </annotation></semantics></math>
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>0</mn></msub><mo>&geq;</mo><mn>0</mn><mo>,</mo><msub><mi>a</mi> <mn>1</mn></msub><mi>&gt;</mi><mn>0</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>a</mi> <mi>n</mi></msub><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>a_0 \geq 0, a_1&amp;gt;0, ..., a_n&amp;gt;0</annotation></semantics></math>.
On a alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac><mo>=</mo><mo stretchy="false">[</mo><msub><mi>q</mi> <mn>2</mn></msub><mo>,</mo><msub><mi>q</mi> <mn>3</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>q</mi> <mi>k</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\frac{a}{b}=[q_2,q_3,..,q_k] </annotation></semantics></math>
En effet :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mi>a</mi><mi>b</mi></mfrac><mo>=</mo><mfrac><mrow><msub><mi>r</mi> <mn>0</mn></msub></mrow><mrow><msub><mi>r</mi> <mn>1</mn></msub></mrow></mfrac><mo>=</mo><msub><mi>q</mi> <mn>2</mn></msub><mo>+</mo><mfrac><mrow><msub><mi>r</mi> <mn>2</mn></msub></mrow><mrow><msub><mi>r</mi> <mn>1</mn></msub></mrow></mfrac><mo>=</mo><msub><mi>q</mi> <mn>2</mn></msub><mo>+</mo><mfrac><mn>1</mn><mfrac><mrow><msub><mi>r</mi> <mn>1</mn></msub></mrow><mrow><msub><mi>r</mi> <mn>2</mn></msub></mrow></mfrac></mfrac><mo>=</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>\frac{a}{b}= \frac{r_0}{r_1}=q_2 +\frac{r_2}{r_1} = q_2 +
\frac{1}{\frac{r_1}{r_2}} = ... </annotation></semantics></math>
D’autre part, on montre par récurrence sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&geq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n\geq 1</annotation></semantics></math> que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>&gt;</mi><mn>0</mn></mrow><annotation encoding='application/x-tex'>x&amp;gt;0</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>q</mi> <mn>2</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>q</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mfrac><mrow><msub><mi>v</mi> <mi>n</mi></msub><mi>x</mi><mo>+</mo><msub><mi>v</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><mrow><msub><mi>u</mi> <mi>n</mi></msub><mi>x</mi><mo>+</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>[q_2,..., q_n,x]=\frac{v_{n}x+v_{n&#x2d;1}}{u_{n}x+u_{n&#x2d;1}} </annotation></semantics></math>
en effet au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n=1</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi><mo>=</mo><mfrac><mrow><msub><mi>v</mi> <mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>v</mi> <mn>0</mn></msub></mrow><mrow><msub><mi>u</mi> <mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>u</mi> <mn>0</mn></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>[x]=x=\frac{v_1 x + v_0}{u_1 x+u_0 } </annotation></semantics></math>
et pour l’induction :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mo stretchy="false">[</mo><msub><mi>q</mi> <mn>2</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>q</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">[</mo><msub><mi>q</mi> <mn>2</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>q</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>q</mi> <mi>n</mi></msub><mo>+</mo><mfrac><mn>1</mn><mi>x</mi></mfrac><mo stretchy="false">]</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><msub><mi>v</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>q</mi> <mi>n</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>v</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>q</mi> <mi>n</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow></mfrac></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><mi>x</mi><mo stretchy="false">(</mo><msub><mi>v</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>q</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>v</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>v</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><mrow><mi>x</mi><mo stretchy="false">(</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>q</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><msub><mi>v</mi> <mi>n</mi></msub><mi>x</mi><mo>+</mo><msub><mi>v</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><mrow><msub><mi>u</mi> <mi>n</mi></msub><mi>x</mi><mo>+</mo><msub><mi>u</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
  [q_2,..., q_n,x] &amp;= &amp; [q_2,..., q_{n&#x2d;1},q_n+\frac{1}{x}] \\
&amp;=&amp; \frac{v_{n&#x2d;1}(q_n+1/x)+v_{n&#x2d;2}}{u_{n&#x2d;1}(q_n+1/x)+u_{n&#x2d;2}} \\
&amp;=&amp;
\frac{x(v_{n&#x2d;1}q_n+v_{n&#x2d;2})+v_{n&#x2d;1}}{x(u_{n&#x2d;1}q_n+u_{n&#x2d;2})+u_{n&#x2d;1}} \\
&amp; = &amp; 
\frac{v_{n}x+v_{n&#x2d;1}}{u_{n}x+u_{n&#x2d;1}}
 \end{matrix} </annotation></semantics></math>
Donc au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> et pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>q</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x=q_{n}</annotation></semantics></math>, on obtient 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>q</mi> <mn>2</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>q</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo>=</mo><mfrac><mrow><msub><mi>v</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mrow><msub><mi>u</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>[q_2,..., q_n]=\frac{v_{n+1}}{u_{n+1}} </annotation></semantics></math></p><p>Les <span style="font-weight:bold">fractions continues</span><a id="hevea_default40"></a> <a id="hevea_default41"></a>
servent bien entendu aussi et d’abord à approcher les
réels par des rationnels.
L’algorithme de calcul des termes du développement est le suivant :
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>x\geq0</annotation></semantics></math>. On initialise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>y=x</annotation></semantics></math> et la liste des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>a_p</annotation></semantics></math> à vide. 
Puis on fait une boucle : on ajoute la partie entière de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> à la
liste, on calcule la partie fractionnaire de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>, si elle est nulle on
s’arrête (dans ce cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mi>&Qopf;</mi></mrow><annotation encoding='application/x-tex'>x\in \mathbb{Q}</annotation></semantics></math>),
sinon on stocke dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> l’inverse de cette partie fractionnaire et on recommence.
On note classiquement :
<a id="eqref_1"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>h</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mrow></msub><mo>=</mo><mn>0</mn><mo>,</mo></mtd> <mtd><msub><mi>h</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>1</mn><mo>,</mo></mtd> <mtd><msub><mi>h</mi> <mi>p</mi></msub><mo>=</mo><msub><mi>a</mi> <mi>p</mi></msub><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd></mtr> <mtr><mtd><msub><mi>k</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mrow></msub><mo>=</mo><mn>1</mn><mo>,</mo></mtd> <mtd><msub><mi>k</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn><mo>,</mo></mtd> <mtd><msub><mi>k</mi> <mi>p</mi></msub><mo>=</mo><msub><mi>a</mi> <mi>p</mi></msub><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable></mrow><mspace width="2em"/><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \begin{matrix} h_{&#x2d;2}=0, &amp; h_{&#x2d;1}=1, &amp; h_p=a_p h_{p&#x2d;1}+h_{p&#x2d;2}\\
k_{&#x2d;2}=1, &amp; k_{&#x2d;1}=0, &amp; k_p=a_p k_{p&#x2d;1}+k_{p&#x2d;2}
\end{matrix} \qquad (1) </annotation></semantics></math>
On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>h</mi> <mn>0</mn></msub><mo>=</mo><msub><mi>a</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>h</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>a</mi> <mn>1</mn></msub><msub><mi>a</mi> <mn>0</mn></msub><mo>+</mo><mn>1</mn><mo>,</mo><msub><mi>k</mi> <mn>0</mn></msub><mo>=</mo><mn>1</mn><mo>,</mo><msub><mi>k</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>a</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>h_0=a_0, h_1=a_1 a_0+1, k_0=1, k_1=a_1</annotation></semantics></math>.
Les suites <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>h</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>h_p</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>k</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>k_p</annotation></semantics></math> sont donc positives et strictement croissantes pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>&geq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p
\geq 1</annotation></semantics></math>, puisque pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>&geq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p \geq 1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>p</mi></msub><mo>&geq;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a_p\geq 1</annotation></semantics></math>, elles tendent vers
l’infini au moins aussi vite que des suites de Fibonacci (à vitesse
au moins géométrique donc).
On a aussi aisément par récurrence :
<a id="eqref_2"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>h</mi> <mi>p</mi></msub><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>k</mi> <mi>p</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msup><mspace width="2em"/><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 h_p k_{p&#x2d;1} &#x2d; h_{p&#x2d;1}k_p=(&#x2d;1)^{p+1}
\qquad (2) </annotation></semantics></math>
On montre aussi comme ci-dessus :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>a</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>a</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mfrac><mrow><mi>y</mi><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow><mrow><mi>y</mi><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>[a_0,...,a_{p&#x2d;1},y]=\frac{yh_{p&#x2d;1}+h_{p&#x2d;2}}{yk_{p&#x2d;1}+k_{p&#x2d;2}} </annotation></semantics></math>
On définit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>x_p</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>a</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>a</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>x</mi> <mi>p</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>x=[a_0,...,a_{p&#x2d;1},x_p]</annotation></semantics></math>, en faisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>x</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>y=x_p</annotation></semantics></math>
on a alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><msub><mi>x</mi> <mi>p</mi></msub><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow><mrow><msub><mi>x</mi> <mi>p</mi></msub><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>x=\frac{x_ph_{p&#x2d;1}+h_{p&#x2d;2}}{x_p k_{p&#x2d;1}+k_{p&#x2d;2}}</annotation></semantics></math> ce qui
donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>x_p</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mi>p</mi></msub><mo>=</mo><mtext>floor</mtext><mrow><mo>(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><mi>x</mi><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>2</mn></mrow></msub><mo>&minus;</mo><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow><mrow><mi>x</mi><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>a_p=\mbox{floor}\left( &#x2d; \frac{xk_{p&#x2d;2}&#x2d;h_{p&#x2d;2}}{xk_{p&#x2d;1}&#x2d;h_{p&#x2d;1}} \right) </annotation></semantics></math>
En faisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>a</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>y=a_p</annotation></semantics></math> on obtient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><msub><mi>a</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>a</mi> <mi>p</mi></msub><mo stretchy="false">]</mo><mo>=</mo><mfrac><mrow><msub><mi>h</mi> <mi>p</mi></msub></mrow><mrow><msub><mi>k</mi> <mi>p</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>[a_0,...,a_p]=\frac{h_p}{k_p}</annotation></semantics></math>.
On montre ensuite que les suites <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>h</mi> <mi>p</mi></msub><mo stretchy="false">/</mo><msub><mi>k</mi> <mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(h_p/k_p)</annotation></semantics></math> pour les indices pairs et impairs sont deux
suites adjacentes qui convergent vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>, et on a
<a id="eqref_3"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><msub><mi>h</mi> <mi>p</mi></msub></mrow><mrow><msub><mi>k</mi> <mi>p</mi></msub></mrow></mfrac><mo>&minus;</mo><mfrac><mrow><msub><mi>h</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><mrow><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><mrow><msub><mi>k</mi> <mi>p</mi></msub><msub><mi>k</mi> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow></mfrac><mspace width="2em"/><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
\frac{h_p}{k_p} &#x2d; \frac{h_{p&#x2d;1}}{k_{p&#x2d;1}} = \frac{(&#x2d;1)^{p&#x2d;1}}{k_p
  k_{p&#x2d;1}}
\qquad (3) </annotation></semantics></math>
En effet, la dernière égalité est une conséquence immédiate
de (<a href="#eqref_2">2</a>), la croissance ou décroissance des suites
d’indice pair ou impair s’en déduit en ajoutant (<a href="#eqref_3">3</a>) au cran
suivant. La convergence vient de la
limite infinie de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>k</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>k_p</annotation></semantics></math> en l’infini.
On a donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>=</mo><msub><mi>a</mi> <mn>0</mn></msub><mo>+</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>p</mi><mo>=</mo><mn>0</mn></mrow> <mn>&infin;</mn></munderover><mfrac><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mrow><mi>p</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><mrow><msub><mi>k</mi> <mi>p</mi></msub><msub><mi>k</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mfrac><mo>,</mo><mspace width="1em"/><mfrac><mn>1</mn><mrow><msub><mi>k</mi> <mi>p</mi></msub><mo stretchy="false">(</mo><msub><mi>k</mi> <mi>p</mi></msub><mo>+</mo><msub><mi>k</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>&leq;</mo><mo stretchy="false">&vert;</mo><mi>x</mi><mo>&minus;</mo><mfrac><mrow><msub><mi>h</mi> <mi>p</mi></msub></mrow><mrow><msub><mi>k</mi> <mi>p</mi></msub></mrow></mfrac><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mn>1</mn><mrow><msub><mi>k</mi> <mi>p</mi></msub><msub><mi>k</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>x=a_0+\sum_{p=0}^\infty \frac{(&#x2d;1)^{p&#x2d;1}}{k_p k_{p+1}}, 
\quad \frac{1}{k_p(k_p+k_{p+1})} \leq |x&#x2d;\frac{h_p}{k_p}| \leq \frac{1}{k_p
  k_{p+1}} </annotation></semantics></math>
La convergence est d’autant plus rapide que les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>k</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>k_p</annotation></semantics></math> tendent
rapidement vers l’infini, donc si les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>a_p</annotation></semantics></math> sont plus grands que 1.
La convergence la plus lente correspond au cas où tous les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>p</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a_p=1</annotation></semantics></math>
cas du nombre d’or, ou à partir d’un certain rang (nombre de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">[</mo><msqrt><mn>5</mn></msqrt><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>Q[\sqrt{5}]</annotation></semantics></math>).</p>
<!--TOC subsection id="sec36" La puissance rapide itérative-->
<h3 id="sec36" class="subsection">3.9.4  La puissance rapide itérative</h3><!--SEC END --><p><a id="hevea_default42"></a><a id="hevea_default43"></a>
Pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mi>k</mi></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a^k \pmod n</annotation></semantics></math>, on décompose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> en base 2
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>k</mi><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>J</mi></munderover><msub><mi>k</mi> <mi>j</mi></msub><msup><mn>2</mn> <mi>j</mi></msup><mo>,</mo><mspace width="1em"/><msup><mi>a</mi> <mi>k</mi></msup><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>J</mi></munderover><msup><mi>a</mi> <mrow><msub><mi>k</mi> <mi>j</mi></msub><msup><mn>2</mn> <mi>j</mi></msup></mrow></msup><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo stretchy="false">/</mo><msub><mi>k</mi> <mi>j</mi></msub><mo>&ne;</mo><mn>0</mn></mrow></munder><msup><mi>a</mi> <mrow><msup><mn>2</mn> <mi>j</mi></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>k=\sum_{j=0}^J k_j 2^j, \quad a^k = \prod_{j=0}^{J} a^{k_j 2^j} 
= \prod_{j/k_j \neq 0} a^{2^j}  </annotation></semantics></math>
On initialise une variable <code>B</code> à 1, <code>B</code> vaudra <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mi>k</mi></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a^k \pmod
n</annotation></semantics></math> en fin de calcul, on initialise une variable <code>k</code> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>.
On calcule dans une boucle les carrés successifs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a
\pmod n</annotation></semantics></math> que l’on stocke dans une variable <code>A</code> (<code>A</code> 
vaudra donc successivement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo><msup><mi>a</mi> <mn>2</mn></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo><msup><mi>a</mi> <mn>4</mn></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>a \pmod n, a^2 \pmod n, a^{4} \pmod n,
...</annotation></semantics></math>) et simultanément on teste si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>k</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>k_j</annotation></semantics></math> vaut 1 en prenant le reste de la
division par 2 de <code>k</code> (dans ce cas on multuplie <code>B</code> par
<code>A</code> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>), on divise ensuite <code>k</code> par 2 au sens du quotient
euclidien.

</p><pre class="verbatim">rapide(a,k,n):={
  local A,B;
  A:=a; B:=1;
  tantque k!=0 faire
    si irem(k,2)==1 alors B:=irem(A*B,n); fsi;
    k:=iquo(k,2);
    A:=irem(A*A,n);
  ftantque;
  return B;
}
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>



<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">rapide(123,4567890,123456)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
<br>
Pour tester en mode pas à pas, ajoutez <code>debug(</code> au
début de la commande qui précède<br>
<code>debug(rapide(123,4567890,123456))</code></p>
<!--TOC section id="sec37" Pour en savoir plus.-->
<h2 id="sec37" class="section">3.10  Pour en savoir plus.</h2><!--SEC END --><p>
Sur des aspects plus théoriques :
</p><ul class="itemize"><li class="li-itemize">
Knuth: TAOCP (The Art of Computer Programming), volumes 1 et suivants
</li><li class="li-itemize">Henri Cohen: A Course in Computational Algebraic Number Theory
</li><li class="li-itemize">Davenport, Siret, Tournier: Calcul formel: Systèmes et algorithmes 
de manipulations algébriques
</li></ul><p>Sur des aspects plus pratiques, quelques références en ligne, 
la plupart sont accessibles gratuitement :
</p><ul class="itemize"><li class="li-itemize">
le code source de Giac disponible à l’URL :<br>
<code>http://www-fourier.ujf-grenoble.fr/~parisse/giac.html</code>
</li><li class="li-itemize">en Maple, il est possible de
décompiler une instruction <code>Maple</code> avec la commande<br>
<code>eval(instruction);</code><br>
après avoir tapé<br>
<code>interface(verboseproc=2);</code>
</li><li class="li-itemize">le source du plus ancien système de calcul formel <code>maxima</code>
(devenu logiciel libre) pour les personnes familières du langage Lisp<br>
<code>http://sourceforge.net/projects/maxima</code><br>
de même pour le système Axiom
</li><li class="li-itemize">le source de librairies plus spécialisées (GMP, MPFR, MPFI, GP-PARI, Singular,
NTL, GAP, CoCoA, ...), rechercher ces mots-clefs sur un moteur de recherche.
</li></ul>
<!--TOC section id="sec38" Exercices sur types, calcul exact et approché, 
algorithmes de bases-->
<h2 id="sec38" class="section">3.11  Exercices sur types, calcul exact et approché, 
algorithmes de bases</h2><!--SEC END --><p> <a id="sec:exos_algobase"></a>
Vous pouvez 

<a href="http://www-fourier.ujf-grenoble.fr/~parisse/xcasfr.html" target="_blank">tester directement dans votre navigateur</a>

Pour télécharger et installer Xcas sur votre ordinateur, suivre
les instructions données sur<br>
<code>http://www-fourier.ujf-grenoble.fr/~parisse/giac_fr.html</code><br>
Pour lancer <span style="font-family:monospace">xcas</span> sous linux, cherchez Xcas dans le menu
Education ou ouvrir un fenêtre terminal et
taper la commande<br>
<code>  xcas &amp; </code><br>
Lors de la première exécution, vous devrez choisir entre
différents types de syntaxe (compatible C, maple ou TI89). Vous
pouvez changer ce choix à tout moment en utilisant le menu
Configuration-&gt;mode (syntaxe). On vous propose aussi d’ouvrir le
tutoriel, qui est également accessible depuis le menu Aide,
Débuter en calcul formel.</p><p>L’aide en ligne est accessible en tapant <code>?nom_de_commande</code>.
Dans Xcas, vous pouvez aussi taper le début d’un
nom de commande puis la touche de tabulation (à gauche du A sur
un clavier francais), sélectionner la commande dans la boite
de dialogues puis cliquer sur Details pour avoir une aide plus
complète dans votre navigateur. Pour plus de détails sur
l’interface de Xcas, consultez le manuel (Aide-&gt;Interface).
Si vous n’avez jamais utilisé de logiciel de calcul formel,
vous pouvez commencer par lire le tutoriel (menu Aide-&gt;Debuter en
calcul formel-&gt;tutoriel) et faire certains des exercices 
proposés (des corrigés sous forme de sessions Xcas sont 
dans Aide-&gt;Debuter en calcul formel-&gt;solutions)</p><p>Il peut être interessant de tester ces exercices
en parallèle avec Xcas et des calculatrices
formelles....</p><ol class="enumerate" type=1><li class="li-enumerate">
À quelle vitesse votre logiciel multiplie-t-il des
grands entiers (en fonction du nombre de chiffres)? 
On pourra tester le temps de calcul du produit
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>a(a+1)</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mn>10</mn><mn>000</mn><mo>!</mo></mrow><annotation encoding='application/x-tex'>a=10 000!</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mn>15000</mn><mo>!</mo></mrow><annotation encoding='application/x-tex'>a=15000!</annotation></semantics></math>, etc. .
Même question pour des polynômes en une variable (à générer
par exemple avec <code>symb2poly(randpoly(n))</code> ou avec <code>poly1[op(ranm(.))]</code>).

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">n:=100; p:=symb2poly(randpoly(n)):; time(p*p);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Comparer le temps de calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mi>n</mi></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a^n \pmod m</annotation></semantics></math> par la fonction
<code>powmod</code> et la méthode prendre le reste modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> après avoir 
calculé <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>a^n</annotation></semantics></math>.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:20px;font-style:large">a:=123; n:=456; m:=789; time(powmod(a,n,m)); time(irem(a^n,m));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Programmez la méthode rapide et la méthode lente.
Refaites la
comparaison. Pour la méthode rapide, programmer aussi la version
itérative utilisant la décomposition en base 2 de l’exposant :
on stocke dans une variable locale <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> les puissances successives
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mrow><msup><mn>2</mn> <mn>0</mn></msup></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo><msup><mi>a</mi> <mrow><msup><mn>2</mn> <mn>1</mn></msup></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>a</mi> <mrow><msup><mn>2</mn> <mi>k</mi></msup></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>m</mi><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>a^{2^0} \pmod m,a^{2^1} \pmod m, ..., a^{2^k} \pmod m, ...</annotation></semantics></math>,
on forme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mi>n</mi></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>n</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a^n \pmod n</annotation></semantics></math> en prenant le produit modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> de ces puissances
successives lorsque le bit correspondant est à 1 (ce qui se
détecte par le reste de divisions euclidiennes sucessives par 2, le
calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> et du bit correspondant se font dans une même boucle).</li><li class="li-enumerate">Déterminer un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>3</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>c=1 \pmod 3</annotation></semantics></math>, 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mn>3</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>5</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>c=3 \pmod 5</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mn>5</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>7</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>c=5 \pmod 7</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mn>2</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>11</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>c=2 \pmod{11}</annotation></semantics></math>.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">ichinrem()
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Calculez dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>11</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/11\mathbb{Z}</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>a</mi><mo>=</mo><mn>0</mn></mrow> <mn>10</mn></munderover><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>  \prod_{a=0}^{10} (x&#x2d;a) </annotation></semantics></math>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">product()
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Algorithmes fondementaux : écrire des programmes implémentant
<ol class="enumerate" type=a><li class="li-enumerate">
le pgcd de 2 entiers
</li><li class="li-enumerate">l’algorithme de Bézout
</li><li class="li-enumerate">l’inverse modulaire en ne calculant que ce qui est nécessaire
dans l’algorithme de Bézout
</li><li class="li-enumerate">les restes chinois
</li></ol></li><li class="li-enumerate">Construire un corps fini de cardinal 128 (<code>GF</code>), puis factoriser
le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>x^2&#x2d;y</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math> est un élément quelconque du corps
fini.
Comparer avec la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mi>y</mi></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{y}</annotation></semantics></math>.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">GF(2,7);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Utiliser la commande <span style="font-family:monospace">type</span> ou <span style="font-family:monospace">whattype</span> ou équivalent
pour déterminer la représentation
utilisée par le logiciel pour représenter
une fraction, un nombre complexe, un flottant en précision machine, 
un flottant avec 100 décimales, la variable <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>, l’expression <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\sin(x)+2</annotation></semantics></math>,
la fonction <span style="font-family:monospace">x-&gt;sin(x)</span>, une liste, une séquence, un vecteur,
une matrice. Essayez d’accéder aux parties de
l’objet pour les objets composites (en utilisant <span style="font-family:monospace">op</span> par exemple).

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">a:=sin(x)+2; type(a); a[0]; a[1]
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Comparer le type de l’objet <code>t</code> si on effectue
la commande <code>t[2]:=0;</code> après avoir purgé <code>t</code>
ou après avoir affecté <code>t:=[1,2,3]</code> ?

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">t[2]:=0; type(t); t:=[1,2,3]; type(t)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Comparer l’effet de l’affectation dans une liste et dans un
vecteur ou une matrice sur votre logiciel (en Xcas, on peut utiliser
<code>=&lt;</code> au lieu de <code>:=</code> pour stocker par référence).

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">l:=[1,2,3]; l1:=l; l[1]:=5; l1
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Le programme ci-dessous calcule la base utilisée
pour représenter les flottants. 

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">
function Base()
local A,B;
A:=1.0; B:=1.0;
while evalf(evalf(A+1.0)-A)-1.0=0.0 do A:=2*A; od;
while evalf(evalf(A+B)-A)-B!=0 do B:=B+1; od;
return B;
ffunction:;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

Testez-le 
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">Base()
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
 et expliquez.</li><li class="li-enumerate">Déterminer le plus grand réel positif <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> de la forme 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>n</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>2^{&#x2d;n}</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> entier)
tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1.0</mn><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mn>1.0</mn></mrow><annotation encoding='application/x-tex'>(1.0+x)&#x2d;1.0</annotation></semantics></math> renvoie 0 sur PC avec la précision par
défaut puis avec <code>Digits:=30</code>.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">n:=30; x:=2^(-n):; (1.0+x)-1.0
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Calculer la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>:</mo><mo>=</mo><mi>exp</mi><mo stretchy="false">(</mo><mi>&pi;</mi><msqrt><mn>163</mn></msqrt><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>a:=\exp(\pi \sqrt{163})</annotation></semantics></math> avec 30 chiffres
significatifs, puis sa partie fractionnaire. Proposez une commande
permettant de décider si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> est un entier.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">a:=exp(pi*sqrt(163));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Déterminer la valeur et le signe de la fraction rationnelle 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1335</mn><mn>4</mn></mfrac><msup><mi>y</mi> <mn>6</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mn>11</mn><msup><mi>x</mi> <mn>2</mn></msup><msup><mi>y</mi> <mn>2</mn></msup><mo>&minus;</mo><msup><mi>y</mi> <mn>6</mn></msup><mo>&minus;</mo><mn>121</mn><msup><mi>y</mi> <mn>4</mn></msup><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mfrac><mn>11</mn><mn>2</mn></mfrac><msup><mi>y</mi> <mn>8</mn></msup><mo>+</mo><mfrac><mi>x</mi><mrow><mn>2</mn><mi>y</mi></mrow></mfrac></mrow><annotation encoding='application/x-tex'> F(x,y)= \frac{1335}{4} y^6 + x^2 (11x^2 y^2&#x2d;y^6 &#x2d;121y^4&#x2d;2) + 
\frac{11}{2} y^8 + \frac{x}{2y} </annotation></semantics></math>
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mn>77617</mn></mrow><annotation encoding='application/x-tex'>x=77617</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>33096</mn></mrow><annotation encoding='application/x-tex'>y=33096</annotation></semantics></math> en faisant deux calculs, l’un en mode approché et 
l’autre en mode exact. Que pensez-vous de ces résultats?
Combien de chiffres significatifs faut-il pour obtenir un résultat
raisonnable en mode approché?

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">F(x,y):=1335/4*y^6+x^2*(11x^2*y^2-y^6-121*y^4-2)+11/2*y^8+x/2/y;
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">F();
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Que se passe-t-il si on essaie d’appliquer l’algorithme de la
puissance rapide pour calculer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>(x+y+z+1)^{k}</annotation></semantics></math> par exemple pour
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>64</mn></mrow><annotation encoding='application/x-tex'>k=64</annotation></semantics></math> ? 
Calculer le nombre
de termes dans le développement de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>+</mo><mn>1</mn><msup><mo stretchy="false">)</mo> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>(x+y+z+1)^n</annotation></semantics></math> et expliquez.

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;height:40px;font-style:large">time(normal((x+y+z+1)^30)); a:=normal((x+y+z+1)^15):; time(normal(a*a));
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

</li><li class="li-enumerate">Programmation de la <span style="font-weight:bold">méthode de Horner</span><a id="hevea_default44"></a><br>
Il s’agit d’évaluer efficacement un polynôme 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi> <mi>n</mi></msub><msup><mi>X</mi> <mi>n</mi></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>a</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'> P(X) = a_n X^n + ... + a_0  </annotation></semantics></math>
en un point.
On pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mn>0</mn></msub><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>b_0=P(\alpha )</annotation></semantics></math> et on écrit :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>b</mi> <mn>0</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> P(X)&#x2d;b_0=(X&#x2d;\alpha )Q(X)  </annotation></semantics></math>
où :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>b</mi> <mi>n</mi></msub><msup><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><msub><mi>b</mi> <mn>2</mn></msub><mi>X</mi><mo>+</mo><msub><mi>b</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'> Q(X) = b_n X^{n&#x2d;1} + ... +b_2 X + b_1  </annotation></semantics></math>
On calcule alors par ordre décroissant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>b_n</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>b_{n&#x2d;1}</annotation></semantics></math>, ..., <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>b_0</annotation></semantics></math>.
<ol class="enumerate" type=a><li class="li-enumerate">
Donner <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>b_n</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>a_n</annotation></semantics></math> puis pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>i</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>i\leq n&#x2d;1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>b_i</annotation></semantics></math>
en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>a_i</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>b_{i+1}</annotation></semantics></math>. Indiquez le détail des calculs
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>X</mi> <mn>3</mn></msup><mo>&minus;</mo><mn>2</mn><mi>X</mi><mo>+</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>P(X)=X^3&#x2d;2X+5</annotation></semantics></math> et une valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha </annotation></semantics></math> non nulle.
</li><li class="li-enumerate">Écrire un fonction <code>horn</code> effectuant ce calcul:
on donnera en arguments le polynôme sous forme de la
liste de ces coefficients (dans l’exemple <code>[1,0,-2,5]</code>) et la
valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha </annotation></semantics></math> et le programme renverra <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(\alpha )</annotation></semantics></math>.
(On pourra aussi renvoyer les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>).
</li><li class="li-enumerate">En utilisant cette fonction, écrire une fonction qui calcule
le développement de Taylor complet d’un polynôme en un point.
</li></ol>
</li></ol>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Certains
systèmes de calcul formel (calculatrices par exemple) utilisent d’ailleurs des
méthodes spécifiques pour gérer le problème de la fragmentation de
la mémoire, appelés “garbage collector”. Ce type de méthode
est intégré dans des langages comme Lisp ou Java, en C/C++ on trouve
des libraries pour cela, par exemple GC de Boehm, incluse dans la
distribution de GCC.</div></dd><dt class="dt-thefootnotes"><a id="note2" href="#text2">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Les HP Prime utilisent Giac comme
noyau de calcul formel, les TI Nspire CAS utilisent sans doute une
version actualisée du système utilisé sur les TI 89, 92,
Voayge 200.</div></dd><dt class="dt-thefootnotes"><a id="note3" href="#text3">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">un quartet=un demi octet</div></dd><dt class="dt-thefootnotes"><a id="note4" href="#text4">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Plus précisément deux
piles, la pile de donnée et la pile gérant le flux d’exécution. Cette
dernière n’est pas visible par l’utilisateur</div></dd><dt class="dt-thefootnotes"><a id="note5" href="#text5">5</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Sauf si
on utilise comme dernier argument le nombre d’arguments de la fonction ou 
si on utilise (cf. infra) un tag de début de liste d’arguments</div></dd><dt class="dt-thefootnotes"><a id="note6" href="#text6">6</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Toutefois une adaptation du logiciel utilisant comme
quantum de base par exemple 32 bits porterait cette limite
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>65536</mn> <mn>65535</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>65536^{65535}&#x2d;1</annotation></semantics></math></div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec39" Les générateurs de nombres pseudo-aléatoires.-->
</html>
