<!DOCTYPE html>
<html >
<head>
<h1 id="sec163" class="chapter">Chapitre 18  Factorisation des polynômes.</h1><!--SEC END --><p> <a id="sec:factor"></a>
On présente ici quelques algorithmes utilisés pour factoriser un polynôme 
à coefficients entiers, pour la recherche de racines approchées
d’un polynôme, cf. la section <a href="#sec%3Aproot">21.6</a>.
Pour un polynôme en une variable,
cele se fait en plusieurs étapes : on commence
par se ramener à un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dont tous les facteurs sont de multiplicité
un, ensuite on factorise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> (par la méthode de Berlekamp
ou Cantor-Zassenhauss), puis on remonte à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>p</mi> <mi>k</mi></msup><mi>Z</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p^k Z</annotation></semantics></math>
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> suffisamment grand (en fonction de la borne de Landau sur les
facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>), et on recombine enfin les facteurs modulaires pour
trouver les facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à plusieurs variables, on utilise
une méthode analogue à celle permettant de trouver le pgcd de polynômes
à plusieurs variables. 
</p><p><span style="font-weight:bold">Rappel</span><br>
Le pgcd des coefficients d’un polynôme est appelé contenu de ce polynôme.
Un polynôme est dit primitif si son contenu est égal à 1.</p>
<!--TOC section id="sec164" Les facteurs multiples-->
<h2 id="sec164" class="section">18.1  Les facteurs multiples</h2><!--SEC END --><p><a id="hevea_default198"></a> <a id="hevea_default199"></a> <a id="hevea_default200"></a>
Étant donné un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à coefficients entiers, on cherche à 
écrire :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>=</mo><msubsup><mi>&Pi;</mi> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msubsup><mi>P</mi> <mi>k</mi> <mi>k</mi></msubsup></mrow><annotation encoding='application/x-tex'> P=\Pi_{k=1}^n P_k^k  </annotation></semantics></math>
où les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> n’ont pas de facteurs multiples et sont premiers entre
eux deux à deux. Comme on est en
caractéristique 0, cela revient à dire que pgcd<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>P</mi> <mi>k</mi></msub><mo>,</mo><msub><mi>P</mi> <mi>k</mi></msub><mo>&prime;</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>(P_k,P_k&apos;)=1</annotation></semantics></math>
et pgcd<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>P</mi> <mi>k</mi></msub><mo>,</mo><msub><mi>P</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>(P_k,P_j)=1</annotation></semantics></math>. Bien entendu
on va utiliser la dérivée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans l’algorithme de recherche des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mi>k</mi><msub><mi>P</mi> <mi>k</mi></msub><mo>&prime;</mo><msubsup><mi>P</mi> <mi>k</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msubsup><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi></mrow></msub><msubsup><mi>P</mi> <mi>j</mi> <mi>j</mi></msubsup></mrow><annotation encoding='application/x-tex'> P&apos;=\sum_{k=1}^n kP_k&apos; P_k^{k&#x2d;1} \Pi_{j\neq k} P_j^j  </annotation></semantics></math>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math>. On a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>G</mi><mo>=</mo><msubsup><mi>&Pi;</mi> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msubsup><mi>P</mi> <mi>k</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msubsup><mo>,</mo></mrow><annotation encoding='application/x-tex'> G=\Pi_{k=1}^n P_k^{k&#x2d;1},  </annotation></semantics></math>
en effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>W</mi> <mn>1</mn></msub><mo>=</mo><mfrac><mi>P</mi><mi>G</mi></mfrac><mo>=</mo><msubsup><mi>&Pi;</mi> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msub><mi>P</mi> <mi>k</mi></msub><mo>,</mo><mspace width="1em"/><msub><mi>Z</mi> <mn>1</mn></msub><mo>=</mo><mfrac><mrow><mi>P</mi><mo>&prime;</mo></mrow><mi>G</mi></mfrac><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mi>k</mi><msub><mi>P</mi> <mi>k</mi></msub><mo>&prime;</mo><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi></mrow></msub><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'> W_1=\frac{P}{G}=\Pi_{k=1}^n P_k, \quad 
Z_1=\frac{P&apos;}{G}=\sum_{k=1}^n kP_k&apos;\Pi_{j\neq k} P_j  </annotation></semantics></math>
il s’agit de vérifier que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>W</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>W_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Z</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Z_1</annotation></semantics></math> sont premiers entre eux. Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> un
facteur irréductible du pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>W</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>W_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Z</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Z_1</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> divise l’un des 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math>,
appelons <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>l</mi></msub></mrow><annotation encoding='application/x-tex'>P_l</annotation></semantics></math> ce facteur. Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi></mrow></msub><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\Pi_{j\neq k} P_j</annotation></semantics></math> si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&ne;</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'>k\neq l</annotation></semantics></math>,
on en déduit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> divise le dernier terme de la somme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Z</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Z_1</annotation></semantics></math>, c’est-à-dire
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><msub><mi>P</mi> <mi>l</mi></msub><mo>&prime;</mo><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&ne;</mo><mi>l</mi></mrow></msub><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>lP_l&apos;\Pi_{j\neq l} P_j</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>l</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P_l&apos;</annotation></semantics></math> puisque
les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> sont premiers entre eux. Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>l</mi></msub></mrow><annotation encoding='application/x-tex'>P_l</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>l</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P_l&apos;</annotation></semantics></math> ont un facteur
en commun, ce qui est contraire aux hypothèses.</p><p>On pose alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>Y</mi> <mn>1</mn></msub><mo>=</mo><msub><mi>Z</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>W</mi> <mn>1</mn></msub><mo>&prime;</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mi>&gt;</mi><mn>1</mn></mrow></munder><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>P</mi> <mi>k</mi></msub><mo>&prime;</mo><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi></mrow></msub><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'> Y_1=Z_1&#x2d;W_1&apos;=\sum_{k&amp;gt;1} (k&#x2d;1)P_k&apos; \Pi_{j\neq k} P_j  </annotation></semantics></math>
On définit alors par récurrence des suites de polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>W</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>W_n</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Y</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Y_n</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>G</mi> <mi>m</mi></msub></mrow><annotation encoding='application/x-tex'>G_m</annotation></semantics></math> par :
</p><ul class="itemize"><li class="li-itemize">
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>G</mi> <mi>m</mi></msub><mo>=</mo><mtext>pgcd</mtext><mo stretchy="false">(</mo><msub><mi>W</mi> <mi>m</mi></msub><mo>,</mo><msub><mi>Y</mi> <mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>G_m=\mbox{pgcd}(W_m,Y_m)</annotation></semantics></math>
</li><li class="li-itemize"><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>W</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>W</mi> <mi>m</mi></msub><mo stretchy="false">/</mo><msub><mi>G</mi> <mi>m</mi></msub></mrow><annotation encoding='application/x-tex'>W_{m+1}=W_m/G_m</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Y</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>Y</mi> <mi>m</mi></msub><mo stretchy="false">/</mo><msub><mi>G</mi> <mi>m</mi></msub><mo>&minus;</mo><msub><mi>W</mi> <mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>Y_{m+1}=Y_m/G_m&#x2d;W_{m+1}&apos;</annotation></semantics></math>
</li></ul><p>
On va montrer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>m</mi></msub><mo>=</mo><msub><mi>G</mi> <mi>m</mi></msub></mrow><annotation encoding='application/x-tex'>P_m=G_m</annotation></semantics></math>. Commençons au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n=1</annotation></semantics></math>, on voit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>P_1</annotation></semantics></math>
divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Y</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Y_1</annotation></semantics></math> (puisqu’il est commun à tous les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi></mrow></msub><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\Pi_{j\neq k} P_j</annotation></semantics></math> car
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>k&amp;gt;1</annotation></semantics></math>) et divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>W</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>W_1</annotation></semantics></math>. Et c’est le seul facteur commun, car tout autre
facteur irréductible serait un diviseur d’un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>l</mi></msub></mrow><annotation encoding='application/x-tex'>P_l</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>l&amp;gt;1</annotation></semantics></math>, donc diviserait
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>l</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><msub><mi>P</mi> <mi>l</mi></msub><mo>&prime;</mo><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&ne;</mo><mi>l</mi><mo>,</mo><mi>j</mi><mi>&gt;</mi><mn>1</mn></mrow></msub><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>(l&#x2d;1)P_l&apos;\Pi_{j\neq l,j&amp;gt;1} P_j</annotation></semantics></math>, donc diviserait <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>l</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P_l&apos;</annotation></semantics></math>.
Le raisonnement en un rang quelconque est identique, les polynômes sont
donnés par :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>G</mi> <mi>m</mi></msub><mo>=</mo><msub><mi>P</mi> <mi>m</mi></msub><mo>,</mo><mspace width="mediummathspace"/><msub><mi>W</mi> <mi>m</mi></msub><mo>=</mo><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mi>&gt;</mi><mo>=</mo><mi>m</mi></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mo>,</mo><mspace width="mediummathspace"/><msub><mi>Y</mi> <mi>m</mi></msub><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mi>&gt;</mi><mi>m</mi></mrow></munder><mo stretchy="false">(</mo><mi>k</mi><mo>&minus;</mo><mi>m</mi><mo stretchy="false">)</mo><msub><mi>P</mi> <mi>k</mi></msub><mo>&prime;</mo><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&geq;</mo><mi>m</mi><mo>,</mo><mi>j</mi><mo>&ne;</mo><mi>k</mi></mrow></msub><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'> G_m=P_m, \ W_{m}=\Pi_{k&amp;gt;=m} P_k, \ 
Y_{m}=\sum_{k&amp;gt;m} (k&#x2d;m)P_k&apos;\Pi_{j\geq m, j\neq k} P_j  </annotation></semantics></math></p><p>Lorsqu’on programme cet algorithme, le test d’arrêt est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>G</mi> <mi>m</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>G_m=1</annotation></semantics></math>.</p><p><span style="font-weight:bold">Square-free factorisation (Algorithme de Yun)</span><br>
Argument: un polynôme primitif <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à coefficients entiers (ou dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[i]</annotation></semantics></math>
ou dans un corps de caractéristique nulle).<br>
Valeur renvoyée: une liste de polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>m</mi></msub></mrow><annotation encoding='application/x-tex'>P_m</annotation></semantics></math> telle que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msubsup><mi>&Pi;</mi> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msubsup><mi>P</mi> <mi>k</mi> <mi>k</mi></msubsup></mrow><annotation encoding='application/x-tex'>P=\Pi_{k=1}^n P_k^k</annotation></semantics></math>.<br>
</p><ol class="enumerate" type=1><li class="li-enumerate">
Initialiser la liste résultat à liste vide.
</li><li class="li-enumerate">Initialiser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>W</mi></mrow><annotation encoding='application/x-tex'>W</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi></mrow><annotation encoding='application/x-tex'>Y</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math>. Calculer le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>W</mi></mrow><annotation encoding='application/x-tex'>W</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi></mrow><annotation encoding='application/x-tex'>Y</annotation></semantics></math>
et simplifier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>W</mi></mrow><annotation encoding='application/x-tex'>W</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi></mrow><annotation encoding='application/x-tex'>Y</annotation></semantics></math> par leur pgcd puis poser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi><mo>=</mo><mi>Y</mi><mo>&minus;</mo><mi>W</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>Y=Y&#x2d;W&apos;</annotation></semantics></math>.
</li><li class="li-enumerate">Boucle tant que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>Y\neq 0</annotation></semantics></math>.
</li><li class="li-enumerate">Calculer le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>W</mi></mrow><annotation encoding='application/x-tex'>W</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi></mrow><annotation encoding='application/x-tex'>Y</annotation></semantics></math>. Ajouter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> à la liste résultat.
</li><li class="li-enumerate">Simplifier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>W</mi></mrow><annotation encoding='application/x-tex'>W</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi></mrow><annotation encoding='application/x-tex'>Y</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>, puis poser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi><mo>=</mo><mi>Y</mi><mo>&minus;</mo><mi>W</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>Y=Y&#x2d;W&apos;</annotation></semantics></math> et passer à 
l’itération suivante.
</li></ol><p>Remarque : lorsqu’on veut factoriser un polynôme à coefficients modulaires,
il faut aussi se ramener à un polynôme sans facteurs multiples mais
on ne peut pas utiliser cet algorithme tel quel car la caractéristique
du corps n’est pas nulle.</p><p><span style="font-weight:bold">Exemple</span> :<br>
Factorisation sans facteurs multiples de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>3</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mn>2</mn><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><msup><mo stretchy="false">)</mo> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>P(X)=(X^3&#x2d;1)(X+2)^2(X^2+3)^3</annotation></semantics></math>.
En mode interactif avec un logiciel de calcul formel, effectuons l’étape
d’initialisation :
</p><pre class="verbatim">W:=normal((x^3-1)*(x+2)^2*(x^2+3)^3);
Y:=diff(W,x);
G:=gcd(W,Y);
        x^5+2*x^4+6*x^3+12*x^2+9*x+18
W:=normal(W/G); 
        x^6+2*x^5+3*x^4+5*x^3+-2*x^2+-3*x-6
Y:=normal(Y/G);
Y:=normal(Y-diff(W,x));
        5*x^5+8*x^4+3*x^3+-5*x^2+-8*x-3
</pre><p>
On vérifie bien que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>W</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>*</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>*</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>W=(x+2)*(x^3&#x2d;1)*(x^2+3)</annotation></semantics></math> est le produit 
des facteurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>P_i</annotation></semantics></math>. On entame maintenant la boucle :
</p><pre class="verbatim">G:=gcd(W,Y);
        x^3-1   -&gt; P1
Y:=normal(Y/G);
W:=normal(W/G);
Y:=normal(Y-diff(W,x));
        2*x^2+4*x
G:=gcd(W,Y);
        x+2     -&gt; P2
Y:=normal(Y/G);
W:=normal(W/G);
Y:=normal(Y-diff(W,x));
        0
G:=gcd(W,Y);
        x^2+3   -&gt;  P3
</pre><p>
puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>W</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>W=1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>Y=0</annotation></semantics></math> et le prochain <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> vaut 1, on a bien trouvé tous
les facteurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>P_i</annotation></semantics></math>.</p>
<!--TOC section id="sec165" Factorisation en une variable-->
<h2 id="sec165" class="section">18.2  Factorisation en une variable</h2><!--SEC END --><p>
On suppose maintenant qu’on veut factoriser un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> sans facteur
multiple (et primitif). En général on commence par simplifier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par
ses facteurs linéaires (détectés avec l’algorithme présenté dans le
premier article de cette série). On commence par chercher un nombre premier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>
tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> conserve le même degré et reste sans facteur 
multiple (donc pgcd<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo>,</mo><mi>P</mi><mo>&prime;</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(P,P&apos;)</annotation></semantics></math>=1 dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>), ce qui est toujours
possible (il suffit de prendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> plus grand que le plus grand entier 
apparaissant dans l’algorithme du sous-résultant pour calculer
le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>).</p><p><span style="font-weight:bold">Convention</span><br>
Tous les polynômes ayant leurs coefficients dans un corps fini sont
supposés avoir comme coefficient dominant 1 lorsque le choix
existe (par exemple les facteurs d’un polynôme modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>).</p>
<!--TOC subsection id="sec166" Factorisation dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X]</annotation></semantics></math>-->
<h3 id="sec166" class="subsection">18.2.1  Factorisation dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X]</annotation></semantics></math></h3><!--SEC END --><p>
On suppose qu’on a un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> sans
facteur multiple. Il s’agit de factoriser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X]</annotation></semantics></math>.
Il existe essentiellement deux stratégies, l’une commence par factoriser par
groupes de facteurs de même degré puis casse les facteurs et l’autre 
plus directe à base d’algèbre linéaire modulaire (méthode de Berlekamp). 
Dans les deux cas, on utilise le fait que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> est un polynôme, 
alors les polynômes à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>
modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> forment un anneau <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> qui est aussi un espace vectoriel 
sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> de dimension le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> 
(si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> est irréductible, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est un corps).
On s’intéresse alors aux propriétés de l’application 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo>:</mo><mi>x</mi><mo>&Element;</mo><mi>A</mi><mo>&map;</mo><msup><mi>x</mi> <mi>p</mi></msup></mrow><annotation encoding='application/x-tex'>\varphi: x \in A \mapsto x^p</annotation></semantics></math>.
On observe d’abord que cette application est une application <em>linéaire</em>.
Cela découle du petit théorème de Fermat pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo stretchy="false">(</mo><mi>&lambda;</mi><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>&lambda;</mi><mi>&#x03C6;</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\varphi(\lambda x)=\lambda
\varphi(x)</annotation></semantics></math> et de la formule de Newton et de la primalité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> pour
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>&#x03C6;</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>&#x03C6;</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\varphi(x+y)=\varphi(x)+\varphi(y)</annotation></semantics></math>.</p><p><span style="font-weight:bold">Calcul de </span><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi></mrow><annotation encoding='application/x-tex'>\varphi</annotation></semantics></math><br>
Pour mettre en oeuvre ces algorithmes, on commence par déterminer la matrice
de l’endomorphisme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo>:</mo><mi>x</mi><mo>&map;</mo><msup><mi>x</mi> <mi>p</mi></msup></mrow><annotation encoding='application/x-tex'>\varphi: x \mapsto x^p</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X] \pmod {P(X)}</annotation></semantics></math>
muni de sa base canonique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mi>X</mi><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>X</mi> <mrow><mtext>deg</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>\{ 1, X,...,X^{\mbox{deg}(P)&#x2d;1} \}</annotation></semantics></math>.</p>
<!--TOC subsection id="sec167" Distinct degree factorization-->
<h3 id="sec167" class="subsection">18.2.2  Distinct degree factorization</h3><!--SEC END --><p> <a id="hevea_default201"></a>
Cette méthode consiste à détecter les groupes de facteurs
ayant un degré donné (distinct degree factorization). Si nécessaire, 
on utilise ensuite un autre algorithme pour casser ces groupes.
On utilise ici les propriétés des itérées de l’application linéaire 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi></mrow><annotation encoding='application/x-tex'>\varphi</annotation></semantics></math> sur des espaces vectoriels de corps de base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>.
On va déterminer le produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> de tous les facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>
en calculant le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><mo stretchy="false">(</mo><msup><mi>p</mi> <mi>k</mi></msup><mo stretchy="false">)</mo></mrow></msup><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^{(p^k)}&#x2d;X</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X]</annotation></semantics></math>.</p><p>Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k=1</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mi>p</mi></msup><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^p&#x2d;X</annotation></semantics></math> est le produit des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>&minus;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>X&#x2d;k</annotation></semantics></math> pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>k\in \mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>
par le petit théorème de Fermat (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>k</mi> <mi>p</mi></msup><mo>=</mo><mi>k</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>k^p=k \pmod p</annotation></semantics></math>), donc le pgcd
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><mo stretchy="false">(</mo><msup><mi>p</mi> <mn>1</mn></msup><mo stretchy="false">)</mo></mrow></msup><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^{(p^1)}&#x2d;X</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X]</annotation></semantics></math> est le produit des facteurs
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré 1.</p><p>Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>k&amp;gt;1</annotation></semantics></math>, le raisonnement se généralise de la manière suivante : on
considère un facteur irréductible <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>F(X)</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> et le corps
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi><mo>=</mo><mo stretchy="false">(</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>K=(\mathbb{Z}/p\mathbb{Z})[Y] \pmod{F(Y)}</annotation></semantics></math>. Le corps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> est un corps fini, c’est
aussi un espace vectoriel sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> de dimension <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> possède
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>p^k</annotation></semantics></math> éléments et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>K</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>K^*</annotation></semantics></math> est un groupe multiplicatif à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>k</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^k&#x2d;1</annotation></semantics></math> éléments,
donc tout élément de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>K</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>K^*</annotation></semantics></math> vérifie l’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^{p^k&#x2d;1}=1</annotation></semantics></math> donc
tout élément de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> vérifie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mo stretchy="false">(</mo><msup><mi>p</mi> <mi>k</mi></msup><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x^{(p^k)}=x</annotation></semantics></math>. En particulier pour 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>Y</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x=Y \pmod {F(Y)}</annotation></semantics></math> 
on trouve que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>Y</mi> <mrow><mo stretchy="false">(</mo><msup><mi>p</mi> <mi>k</mi></msup><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mi>Y</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>Y^{(p^k)}=Y \pmod {F(Y)}</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>F(X)</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><mo stretchy="false">(</mo><msup><mi>p</mi> <mi>k</mi></msup><mo stretchy="false">)</mo></mrow></msup><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^{(p^k)}&#x2d;X</annotation></semantics></math>
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>.</p><p>Réciproquement, si on se donne un facteur irréductible <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> qui divise
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^{p^k}&#x2d;X</annotation></semantics></math>, soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> le corps correspondant à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math>, 
alors le noyau de l’application linéaire
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mi>K</mi><mo>&map;</mo><msup><mi>x</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mo>&minus;</mo><mi>x</mi><mo>&Element;</mo><mi>K</mi></mrow><annotation encoding='application/x-tex'> x \in K \mapsto x^{p^k}&#x2d;x \in K  </annotation></semantics></math>
est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> tout entier, car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi><mo>=</mo><msup><mi>Y</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>F</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>Y=Y^{p^k} \pmod F</annotation></semantics></math>
entraine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>Y</mi> <mn>2</mn></msup><msup><mo stretchy="false">)</mo> <mrow><mo stretchy="false">(</mo><msup><mi>p</mi> <mi>k</mi></msup><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><msup><mi>Y</mi> <mrow><mn>2</mn><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mo>=</mo><mo stretchy="false">(</mo><msup><mi>Y</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo>=</mo><msup><mi>Y</mi> <mn>2</mn></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>F</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>(Y^2)^{(p^k)}=Y^{2 p^k}=(Y^{p^k})^2=Y^2 \pmod F</annotation></semantics></math> et de même
pour les autres puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi></mrow><annotation encoding='application/x-tex'>Y</annotation></semantics></math> qui, avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>Y</mi> <mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>Y^0=1</annotation></semantics></math> également dans le
noyau, forment une base de l’espace vectoriel <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>. Donc le
nombre d’éléments de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> est inférieur ou égal au degré du polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^{p^k}&#x2d;X</annotation></semantics></math> (puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><mo stretchy="false">(</mo><msup><mi>p</mi> <mi>k</mi></msup><mo stretchy="false">)</mo></mrow></msup><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^{(p^k)}&#x2d;X</annotation></semantics></math> est divisible par
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>X&#x2d;x</annotation></semantics></math> pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mi>K</mi></mrow><annotation encoding='application/x-tex'>x\in K</annotation></semantics></math>),
donc le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> est inférieur ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>.
(En fait <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>, le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math>, doit diviser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, en effet
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> sont le quotient et le reste de la division de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>=</mo><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>F</mi><mo rspace="mediummathspace">)</mo></mrow><mo>=</mo><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mrow><mi>q</mi><mi>f</mi><mo>+</mo><mi>r</mi></mrow></msup></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>F</mi><mo rspace="mediummathspace">)</mo></mrow><mo>=</mo><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>r</mi></msup></mrow></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>F</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>X=X^{p^k} \pmod F =X^{p^{qf+r}} \pmod F=X^{p^r} \pmod F</annotation></semantics></math>
le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><msup><mi>p</mi> <mi>r</mi></msup></mrow></msup><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x^{p^r}&#x2d;x</annotation></semantics></math> admet alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>f</mi></msup></mrow><annotation encoding='application/x-tex'>p^f</annotation></semantics></math> racines dans le corps
ce qui n’est possible que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>r=0</annotation></semantics></math> car sinon son degré 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>r</mi></msup></mrow><annotation encoding='application/x-tex'>p^r</annotation></semantics></math> serait trop petit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>r</mi></msup><mi>&lt;</mi><msup><mi>p</mi> <mi>f</mi></msup></mrow><annotation encoding='application/x-tex'>p^r&amp;lt;p^f</annotation></semantics></math>).</p><p>Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> est égal au pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">/</mo><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mi>&lt;</mi><mi>k</mi></mrow></msub><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P/\Pi_{j&amp;lt;k} P_j</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^{p^k}&#x2d;X</annotation></semantics></math>.</p><p><span style="font-weight:bold">Algorithme distinct degree factorization</span><br>
Argument: un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à coefficients entiers 
sans facteur multiple et primitif.<br>
Valeur renvoyée: la liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> des produits des facteurs irréductibles et du
degré correspondant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> (ordonné par ordre croissant de degré).<br>
On commence par initialiser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> à vide et un polynôme auxiliaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math>
(il contiendra les valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mo>&minus;</mo><mi>X</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>P</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>X^{p^k}&#x2d;X \pmod P</annotation></semantics></math>), on fait une boucle
indéfinie sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> commençant à 1 et incrémenté de 1 à chaque itération
</p><ul class="itemize"><li class="li-itemize">
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est strictement plus grand que le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> divisé par 2,
on rajoute le couple (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>,degre(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>)) à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> et on renvoie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>
</li><li class="li-itemize">On remplace <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>Q</mi> <mi>p</mi></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>P</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>Q^p \pmod P</annotation></semantics></math> en utilisant le calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi></mrow><annotation encoding='application/x-tex'>\varphi</annotation></semantics></math>
modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
</li><li class="li-itemize">On calcule le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>Q&#x2d;X</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. 
</li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math> vaut 1, on passe à l’itération suivante
</li><li class="li-itemize">On rajoute le couple (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>,<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>) à la liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> et on remplace <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
par le quotient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>G</mi></mrow><annotation encoding='application/x-tex'>G</annotation></semantics></math>.
</li></ul><p><span style="font-weight:bold">Exemple</span> :<br>
Factorisation en degré distincts de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>3</mn></msup><mo>+</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>4</mn></msup><mo>&minus;</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(X^3+X+1)(X^4&#x2d;X+1)</annotation></semantics></math> dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>5</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/5\mathbb{Z}</annotation></semantics></math>. On regarde d’abord si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> reste sans facteur multiple après
réduction modulo 5.
</p><pre class="verbatim">P:=normal((x^3+x+1)*(x^4-x+1) mod 5);
gcd(P,diff(P,x));
    1 mod 5  -&gt; ok P est sans facteur multiple
P1:=gcd(P,(x^5-x)mod 5);
    (1 mod 5)*x -2 mod 5  -&gt; P1
P:=normal(P/P1);
P2:=gcd(P,(x^(5^2)-x)mod 5);
    1 mod 5  -&gt; pas de facteur de degre 2
P3:=gcd(P,(x^(5^3)-x)mod 5);
    (x^6+2*x^5+x^2+x+2) mod 5
</pre><p>
Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> admet 3 facteurs dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>5</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/5\mathbb{Z}</annotation></semantics></math>: un de degré 1 (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>x&#x2d;2</annotation></semantics></math>) et
deux de degré 3 (dont le produit est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>6</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>x^6+2x^5+x^2+x+2</annotation></semantics></math>).</p><p>Le même calcul dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>7</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/7\mathbb{Z}</annotation></semantics></math> donne
</p><pre class="verbatim">P:=normal((x^3+x+1)*(x^4-x+1) mod 7);
gcd(P,diff(P,x));
    1 mod 7  -&gt; ok P est sans facteur multiple
P1:=gcd(P,(x^7-x)mod 7);
    1 mod 7
P2:=gcd(P,(x^(7^2)-x)mod 7);
    1 mod 7
P3:=gcd(P,(x^(7^3)-x)mod 7);
    (x^3+x+1) mod 7
</pre><p>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> possède un facteur de degré 3 modulo 7, donc le facteur restant
de degré 4 est forcément irréductible.</p><p>On remarque sur cet exemple que 7 est plus intéressant que 5, car
la factorisation modulo 7 donne moins de facteurs (à recombiner pour
trouver la factorisation dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>) et la factorisation est
complète modulo 7 alors que modulo 5 il faut casser le facteur de
degré 6 en deux facteurs de degré 3. La plupart des algorithmes
de factorisation effectuent la factorisation en degré distinct
modulo plusieurs entiers (ce qui peut de plus être parallélisé)
et choisissent le meilleur.</p>
<!--TOC subsection id="sec168" La méthode de Cantor-Zassenhaus-->
<h3 id="sec168" class="subsection">18.2.3  La méthode de Cantor-Zassenhaus</h3><!--SEC END --><p>
<a id="hevea_default202"></a>
Cet algorithme sert à casser des groupes de facteurs de même degré,
c’est une méthode probabiliste. On suppose donc qu’on a un produit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
d’au moins deux facteurs irréductibles de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> à casser.
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> l’un des polynômes irréductibles de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> à coefficients
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>, et soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi><mo>=</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>K=\mathbb{Z}/p\mathbb{Z}[Y] \pmod {D(Y)}</annotation></semantics></math>, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow></msup><mo>&minus;</mo><mi>X</mi><mo>=</mo><msub><mi>&Pi;</mi> <mrow><mi>&alpha;</mi><mo>&Element;</mo><mi>K</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>X^{p^d}&#x2d;X=\Pi_{\alpha \in K }(X&#x2d;\alpha)  </annotation></semantics></math>
puisque le corps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> possède <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow><annotation encoding='application/x-tex'>p^d</annotation></semantics></math> éléments tous racines
de l’équation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow></msup><mo>=</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^{p^d}=X</annotation></semantics></math>.</p><p>On considère un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> non constant, et le polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow></msup><mo>&minus;</mo><mi>T</mi></mrow><annotation encoding='application/x-tex'>T^{p^d}&#x2d;T</annotation></semantics></math>. En remplaçant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> ci-dessus, on en déduit :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>T</mi> <mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow></msup><mo>&minus;</mo><mi>T</mi><mo>=</mo><msub><mi>&Pi;</mi> <mrow><mi>&alpha;</mi><mo>&Element;</mo><mi>K</mi></mrow></msub><mo stretchy="false">(</mo><mi>T</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T^{p^d}&#x2d;T=\Pi_{\alpha \in K }(T&#x2d;\alpha)  </annotation></semantics></math>
Donc pour tout élément <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi><mo>&Element;</mo><mi>K</mi><mo>=</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>\beta \in K=\mathbb{Z}/p\mathbb{Z}[Y] \pmod {D(Y)}</annotation></semantics></math>, on a
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>T</mi> <mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow></msup><mo>&minus;</mo><mi>T</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>&Pi;</mi> <mrow><mi>&alpha;</mi><mo>&Element;</mo><mi>K</mi></mrow></msub><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>(T^{p^d}&#x2d;T)(\beta)=\Pi_{\alpha \in K }(T(\beta)&#x2d;\alpha)=0 </annotation></semantics></math>
Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow></msup><mo>&minus;</mo><mi>T</mi></mrow><annotation encoding='application/x-tex'>T^{p^d}&#x2d;T</annotation></semantics></math> est divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow></msup><mo>&minus;</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X^{p^d}&#x2d;X</annotation></semantics></math> (puisque toutes les racines
du second sont racines du premier), donc est divisible par tout polynôme
irréductible de degré inférieur ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Z</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>Z/p\mathbb{Z}</annotation></semantics></math>.
Comme
<a id="eqref_18"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>T</mi> <mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow></msup><mo>&minus;</mo><mi>T</mi><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><msup><mi>T</mi> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>T</mi> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>18</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
T^{p^d}&#x2d;T=T(T^{\frac{p^d&#x2d;1}{2}}&#x2d;1)(T^{\frac{p^d&#x2d;1}{2}}+1)
\qquad (18) </annotation></semantics></math>
et que ces trois facteurs sont premiers entre eux, on en déduit que tout 
polynôme irréductible de degré inférieur ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> à coefficients dans 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Z</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>Z/p\mathbb{Z}</annotation></semantics></math> divise l’un des trois facteurs ci-dessus. Pour casser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, l’idée
consiste alors à calculer le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T^{\frac{p^d&#x2d;1}{2}}&#x2d;1</annotation></semantics></math>
pour un polynôme pris au hasard. On sait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> divise le produit des
3 termes de (<a href="#eqref_18">18</a>), et on espère que les facteurs irréductibles
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> ne diviseront pas tous le même terme.</p><p>On va montrer que si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> est un polynôme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&leq;</mo><mn>2</mn><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\leq 2d&#x2d;1</annotation></semantics></math> choisi au hasard,
la probabilité que deux facteurs irréductibles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> ne divisent pas 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mrow><msup><mi>p</mi> <mi>d</mi></msup></mrow></msup><mo>&minus;</mo><mi>T</mi></mrow><annotation encoding='application/x-tex'>T^{p^d}&#x2d;T</annotation></semantics></math> est proche de 0.5. Soient donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> deux facteurs
irréductibles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math>. D’après l’identité de Bézout, tout 
polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&leq;</mo><mn>2</mn><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\leq 2d&#x2d;1</annotation></semantics></math> s’écrit de manière unique sous la forme :
<a id="eqref_19"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>T</mi><mo>=</mo><mi>A</mi><mi>U</mi><mo>+</mo><mi>B</mi><mi>V</mi><mspace width="2em"/><mo stretchy="false">(</mo><mn>19</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>  
T = A U + B V 
\qquad (19) </annotation></semantics></math>
avec degre(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi><mo>&leq;</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>U \leq d&#x2d;1</annotation></semantics></math>) et degre(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi><mo>&leq;</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>V \leq d&#x2d;1</annotation></semantics></math>) et réciproquement 
une combinaison linéaire de cette forme est un polynôme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&leq;</mo><mn>2</mn><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\leq 2d&#x2d;1</annotation></semantics></math>.
Choisir <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> au hasard revient donc à choisir un couple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>U</mi><mo>,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(U,V)</annotation></semantics></math> de polynômes
à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> au hasard et
de manière indépendante. D’autre part, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> étant de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math>, on
sait que dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi><mo>=</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>Y</mi><mo stretchy="false">]</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>K=\mathbb{Z}/p\mathbb{Z}[Y] \pmod{D(Y)}</annotation></semantics></math> ces polynômes admettent <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> racines.
Soit donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> [respectivement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\beta</annotation></semantics></math>] une racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> [resp. <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>]
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math>. Alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T^{\frac{p^d&#x2d;1}{2}}&#x2d;1</annotation></semantics></math>
si et seulement si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T(\alpha )^{\frac{p^d&#x2d;1}{2}}=1</annotation></semantics></math> (et de même pour
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\beta</annotation></semantics></math>) car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T^{\frac{p^d&#x2d;1}{2}}&#x2d;1</annotation></semantics></math> a ses coefficients dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> (et non dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math>). 
En appliquant (<a href="#eqref_19">19</a>), <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T^{\frac{p^d&#x2d;1}{2}}&#x2d;1</annotation></semantics></math>
si et seulement si :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mi>V</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'> B(\alpha )^{\frac{p^d&#x2d;1}{2}}V(\alpha )^{\frac{p^d&#x2d;1}{2}}=1  </annotation></semantics></math>
Le premier terme de cette égalité est une constante égale à 1 ou -1, 
le second a une probabilité proche de 0.5 (égale à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><mn>2</mn><msup><mi>p</mi> <mi>d</mi></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'>\frac{p^d&#x2d;1}{2p^d}</annotation></semantics></math>)
de valoir 1 ou -1 car, comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est irréductible,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>V(\alpha)</annotation></semantics></math> décrit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math> décrit les 
polynômes de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&leq;</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\leq d&#x2d;1</annotation></semantics></math>.
De même, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> a une probabilité proche de 0.5 de diviser 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T^{\frac{p^d&#x2d;1}{2}}&#x2d;1</annotation></semantics></math>, et ces 2 probabilités sont indépendantes
puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math> le sont, donc la probabilité que soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> divise
divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mfrac><mrow><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mn>2</mn></mfrac></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T^{\frac{p^d&#x2d;1}{2}}&#x2d;1</annotation></semantics></math> est proche de 0.5.</p><p><span style="font-weight:bold">Algorithme de Cantor-Zassenhaus</span><br>
Argument: Un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>
dont tous les facteurs irréductibles sont de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math>.<br>
Valeur renvoyée: la liste des facteurs irréductibles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.<br>
</p><ul class="itemize"><li class="li-itemize">
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding='application/x-tex'>k=d</annotation></semantics></math> renvoyer une liste contenant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.
</li><li class="li-itemize">Déterminer un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> aléatoire de degré inférieur ou égal
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2d&#x2d;1</annotation></semantics></math> et de coefficient dominant 1. Calculer le pgcd <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mrow><mo stretchy="false">(</mo><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T^{(p^d&#x2d;1)/2}&#x2d;1</annotation></semantics></math>. Si le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> est égal à 0 ou à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> 
recommencer cette étape.
</li><li class="li-itemize">Appeler récursivement cet algorithme avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">/</mo><mi>T</mi></mrow><annotation encoding='application/x-tex'>P/T</annotation></semantics></math> et
renvoyer la liste réunion des deux listes renvoyées.
</li></ul><p><span style="font-weight:bold">Exemple</span> :<br>
Cassons le polynôme de degré 6 obtenu dans l’exemple précédent
(modulo 5). Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>:</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>6</mn></msup><mo>+</mo><mn>2</mn><mo>*</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>5</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P:=(x^6+2*x^5+x^2+x+2) \pmod 5</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>d=3</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>d</mi><mo>&minus;</mo><mn>1</mn><mo>=</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>2d&#x2d;1=5</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>p</mi> <mi>d</mi></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn><mo>=</mo><mn>62</mn></mrow><annotation encoding='application/x-tex'>(p^{d}&#x2d;1)/2=62</annotation></semantics></math>.
On choisit au hasard un polynôme de degré inférieur ou égal à 5, par exemple
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo>=</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T=x^4&#x2d;x^3+x+1</annotation></semantics></math>, puis on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mn>62</mn></msup></mrow><annotation encoding='application/x-tex'>T^{62}</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> ce qui donne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>5</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>(x^5+x^3+x^2+1) \pmod 5</annotation></semantics></math> puis le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mn>62</mn></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>T^{62}&#x2d;1</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
qui vaut <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>5</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>x^3+x+1 \pmod 5</annotation></semantics></math>, on a donc cassé <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> en deux. 
En prenant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi><mo>:</mo><mo>=</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>T:=x^4&#x2d;x^3+x+2</annotation></semantics></math>, on trouve <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>T</mi> <mn>62</mn></msup><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>P</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>T^{62}=1 \pmod P</annotation></semantics></math>, donc
ce <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>T</mi></mrow><annotation encoding='application/x-tex'>T</annotation></semantics></math> n’aurait pas permis de casser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.</p>
<!--TOC subsection id="sec169" La méthode de Berlekamp-->
<h3 id="sec169" class="subsection">18.2.4  La méthode de Berlekamp</h3><!--SEC END --><p><a id="hevea_default203"></a>
Cette méthode permet de factoriser un polynôme sans facteurs multiples,
elle peut aussi servir à casser des groupes de facteurs de même degré.
Ici on travaille dans l’anneau des polynômes à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>
modulo le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et on s’intéresse au noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo>&minus;</mo><mi>I</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>\varphi&#x2d;Id</annotation></semantics></math>
(où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo>:</mo><mi>x</mi><mo>&map;</mo><msup><mi>x</mi> <mi>p</mi></msup></mrow><annotation encoding='application/x-tex'>\varphi: x \mapsto x^p</annotation></semantics></math>). On
suppose que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msub><mi>F</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P=\Pi_{j=1}^n F_j</annotation></semantics></math> où les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>F_j</annotation></semantics></math> sont irréductibles et
premiers entre eux. On va montrer que le noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo>&minus;</mo><mi>I</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>\varphi&#x2d;Id</annotation></semantics></math> est
composé des polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> tels que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>Q \pmod {F_j}</annotation></semantics></math> est constant
(dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>) pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>.</p><p>Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><mo rspace="mediummathspace">)</mo></mrow><mo>=</mo><msub><mi>s</mi> <mi>j</mi></msub><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>Q \pmod {F_j}=s_j \in \mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>Q</mi> <mi>p</mi></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><mo rspace="mediummathspace">)</mo></mrow><mo>=</mo><msubsup><mi>s</mi> <mi>j</mi> <mi>p</mi></msubsup><mo>=</mo><msub><mi>s</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q^p \pmod {F_j}=s_j^p=s_j</annotation></semantics></math>, donc
par le théorème des restes chinois, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><msup><mi>Q</mi> <mi>p</mi></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>P</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>Q=Q^p \pmod P</annotation></semantics></math>. </p><p>Réciproquement, si
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>Q</mi> <mi>p</mi></msup><mo>&minus;</mo><mi>Q</mi><mo>=</mo><mn>0</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>P</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>Q^p&#x2d;Q=0 \pmod P</annotation></semantics></math>, en utilisant la factorisation :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>X</mi> <mi>p</mi></msup><mo>&minus;</mo><mi>X</mi><mo>=</mo><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> X^p&#x2d;X= \Pi_{j \in \mathbb{Z}/p\mathbb{Z} } (X&#x2d;j) </annotation></semantics></math>
on en tire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>Q</mi> <mi>p</mi></msup><mo>&minus;</mo><mi>Q</mi><mo>=</mo><msub><mi>&Pi;</mi> <mrow><mi>j</mi><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow></msub><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q^p&#x2d;Q=\Pi_{j \in \mathbb{Z}/p\mathbb{Z} } (Q(X)&#x2d;j)</annotation></semantics></math>,
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>F_j</annotation></semantics></math> divise l’un des facteurs et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><mo rspace="mediummathspace">)</mo></mrow><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>Q(X) \pmod {F_j} \in \mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>.
Le noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo>&minus;</mo><mi>I</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>\varphi &#x2d;Id</annotation></semantics></math>
est donc un espace vectoriel de dimension <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, le nombre
de facteurs irréductibles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et possède donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>p^n</annotation></semantics></math> éléments
(en effet pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> uplet de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>s</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>s_j</annotation></semantics></math>, on peut construire un polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> du noyau par le théorème des restes chinois en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><mo rspace="mediummathspace">)</mo></mrow><mo>=</mo><msub><mi>s</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q\pmod {F_j}=s_j</annotation></semantics></math>).</p><p>L’intérêt du noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo>&minus;</mo><mi>I</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>\varphi&#x2d;Id</annotation></semantics></math> est qu’on peut le calculer sans connaitre
les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>F_j</annotation></semantics></math>. Une fois ce calcul fait, voyons comment on peut remonter 
aux <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>F_j</annotation></semantics></math>. On connait déjà la dimension du noyau donc le nombre de facteurs
irréductibles. De plus, on remarque que le polynome constant 1 est un
élément du noyau qu’on appellera <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>T_1</annotation></semantics></math>, on note alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>2</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>T</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>T_2,...,T_n</annotation></semantics></math> les
autres polynômes unitaires d’une base du noyau. 
Ensuite, on calcule le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>2</mn></msub><mo>&minus;</mo><mi>j</mi><msub><mi>T</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>T_2&#x2d;jT_1</annotation></semantics></math>
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>j\in \mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>. On sait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>s</mi> <mrow><mn>2</mn><mo>,</mo><mi>k</mi></mrow></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msub><mi>F</mi> <mi>k</mi></msub></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>T_2=s_{2,k} \pmod {F_k}</annotation></semantics></math>, donc pgcd<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo>,</mo><msub><mi>T</mi> <mn>2</mn></msub><mo>&minus;</mo><mi>j</mi><msub><mi>T</mi> <mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(P,T_2&#x2d;jT_1)</annotation></semantics></math>
est égal au produit des facteurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>F</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>F_k</annotation></semantics></math> tels que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>s</mi> <mrow><mn>2</mn><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><mi>j</mi><msub><mi>T</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>s_{2,k}=jT_1</annotation></semantics></math>. L’un au moins
des pgcd calculés est non trivial car sinon <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>T</mi> <mn>1</mn></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msub><mi>F</mi> <mi>j</mi></msub></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>T_2=T_1 \pmod{F_j}</annotation></semantics></math> pour
tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>T</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>T_2=T_1</annotation></semantics></math>. Si on a de la chance tous les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>s</mi> <mrow><mn>2</mn><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding='application/x-tex'>s_{2,j}</annotation></semantics></math> seront
distincts et les pgcd non triviaux de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>2</mn></msub><mo>&minus;</mo><mi>j</mi><msub><mi>T</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>T_2&#x2d;jT_1</annotation></semantics></math> donneront les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>F</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>F_k</annotation></semantics></math>.
Sinon il faudra continuer avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>3</mn></msub><mo>&minus;</mo><mi>j</mi><msub><mi>T</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>T_3&#x2d;jT_1</annotation></semantics></math> etc.</p><p><span style="font-weight:bold">Exemple</span> :<br>
Revenons sur la factorisation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>:</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>6</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>5</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P:=(x^6+2x^5+x^2+x+2) \pmod 5</annotation></semantics></math>.
Commençons par calculer la matrice de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi></mrow><annotation encoding='application/x-tex'>\varphi</annotation></semantics></math> dans la base
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mi>x</mi><mo>,</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msup><mi>x</mi> <mn>5</mn></msup><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>\{ 1,x,x^2,...,x^5\}</annotation></semantics></math>. On a évidemment <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\varphi(1)=1</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>5</mn></msup></mrow><annotation encoding='application/x-tex'>\varphi(x)=x^5</annotation></semantics></math>, puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>10</mn></msup><mo>=</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>&minus;</mo><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>P</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>\varphi(x^2)=x^{10}=x^5+x^4&#x2d;2x^3+x \pmod P</annotation></semantics></math>,
puis en multipliant par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>5</mn></msup></mrow><annotation encoding='application/x-tex'>x^5</annotation></semantics></math> et en divisant par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>\varphi(x^3)=&#x2d;x^4+2x^3</annotation></semantics></math>, de la même manière on obtient 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>4</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\varphi(x^4)=&#x2d;x^5+2x^4+x^3&#x2d;x^2&#x2d;2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>5</mn></msup><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>\varphi(x^5)=x^3+x^2&#x2d;x</annotation></semantics></math>.
La matrice de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi></mrow><annotation encoding='application/x-tex'>\varphi</annotation></semantics></math> est donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center center"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>2</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr> <mtr><mtd/></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'> M=\left( 
\begin{array}{cccccc}
1&amp; 0&amp; 0 &amp;0 &amp;&#x2d;2&amp;0\\
0&amp; 0&amp; 1 &amp;0 &amp;0 &amp;&#x2d;1\\
0&amp; 0&amp; 0 &amp;0 &amp;&#x2d;1&amp;1\\
0&amp; 0&amp; &#x2d;2&amp;2 &amp; 1&amp;1\\
0&amp; 0&amp; 1 &amp;&#x2d;1&amp; 2&amp;0\\
0&amp; 1&amp; 1 &amp;0 &amp;&#x2d;1&amp;0\\
\end{array}
\right) </annotation></semantics></math>
On calcule ensuite le noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03C6;</mi><mo>&minus;</mo><mi>I</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>\varphi&#x2d;Id</annotation></semantics></math> (comme matrice à coefficients
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>5</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/5\mathbb{Z}</annotation></semantics></math>), on obtient une
base du noyau en prenant par exemple les vecteurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(&#x2d;1,0,0,0,0,0)</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(0,0,&#x2d;1,&#x2d;1,0,&#x2d;1)</annotation></semantics></math>. Donc le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> possède 2 facteurs dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>5</mn><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/5\mathbb{Z}[X]</annotation></semantics></math>. Pour déterminer les facteurs, on calcule le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
avec le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>2</mn></msub><mo>&minus;</mo><mi>s</mi></mrow><annotation encoding='application/x-tex'>T_2&#x2d;s</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mn>2</mn></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>T_2=&#x2d;x^5&#x2d;x^3&#x2d;x^2</annotation></semantics></math> correspond au 2ème
vecteur de la base du noyau. On obtient pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>s=0</annotation></semantics></math> un pcgd non trivial
(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^3+x+1</annotation></semantics></math>), ce qui permet de calculer les 2 facteurs. Si on avait
essayé d’autres valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi></mrow><annotation encoding='application/x-tex'>s</annotation></semantics></math>, pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>s=1</annotation></semantics></math> on obtient comme pgcd 1, pour
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>s=2</annotation></semantics></math> on trouve le 2ème facteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>x^3+2x^2&#x2d;x+2</annotation></semantics></math>.</p>
<!--TOC subsection id="sec170" Remontée (Hensel)-->
<h3 id="sec170" class="subsection">18.2.5  Remontée (Hensel)</h3><!--SEC END --><p> <a id="hevea_default204"></a>
Il s’agit de passer d’une factorisation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X]</annotation></semantics></math> à une
factorisation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>p</mi> <mi>k</mi></msup><mi>Z</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p^k Z[X]</annotation></semantics></math>, la méthode est analogue à celle
de l’algorithme EZGCD de calcul de pgcd de polynômes.</p><p>On suppose donc que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>=</mo><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msub><mi>P</mi> <mi>j</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> P=\Pi_{j=1}^n P_j \pmod p  </annotation></semantics></math>
où les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> sont premiers entre eux deux à deux dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>.
Il s’agit de trouver des polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>P</mi> <mi>j</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P_{j,k}=P_j \pmod p</annotation></semantics></math> tels que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>=</mo><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> P=\Pi_{j=1}^n P_{j,k} \pmod {p^k}  </annotation></semantics></math>
Commençons par le cas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>k=2</annotation></semantics></math>. On pose
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>P</mi> <mi>j</mi></msub><mo>+</mo><mi>p</mi><msub><mi>Q</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>P</mi> <mi>j</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> P_{j,2}=P_j+pQ_j=P_j \pmod p  </annotation></semantics></math>
On a alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>P</mi></mtd> <mtd><mo>=</mo></mtd> <mtd><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mn>2</mn></msup></mrow><mo rspace="mediummathspace">)</mo></mrow><mo>=</mo><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><mo stretchy="false">(</mo><msub><mi>P</mi> <mi>j</mi></msub><mo>+</mo><mi>p</mi><msub><mi>Q</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mn>2</mn></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msub><mi>P</mi> <mi>j</mi></msub><mo>+</mo><mi>p</mi><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>Q</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mn>2</mn></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 P&amp;=&amp;\Pi_{j=1}^n P_{j,2} \pmod {p^2} =\Pi_{j=1}^n (P_j+pQ_j) \pmod {p^2}\\
&amp;=&amp;\Pi_{j=1}^n P_j + p \sum_{j=1}^n Q_j \Pi_{k\neq j} P_k \pmod {p^2} 
 \end{matrix} </annotation></semantics></math>
Donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>Q</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mo>=</mo><mfrac><mrow><mi>P</mi><mo>&minus;</mo><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msub><mi>P</mi> <mi>j</mi></msub></mrow><mi>p</mi></mfrac><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \sum_{j=1}^n Q_j \Pi_{k\neq j} P_k= \frac{P&#x2d;\Pi_{j=1}^n P_j}{p} \pmod p  </annotation></semantics></math>
On est ramené à résoudre une identité de Bézout généralisée.
On montrera dans l’appendice le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 35</span>  <em> (Identité de Bézout généralisée)
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>P_1</annotation></semantics></math><em>, ..., </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math><em> (</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&geq;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n\geq 2</annotation></semantics></math><em>) des polynômes premiers entre eux deux 
à deux modulo </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math><em>. Alors pour tout polynôme </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math><em>, il existe des polynômes 
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1</annotation></semantics></math><em>, ..., </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Q_n</annotation></semantics></math><em> tels que :
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>Q</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mo>=</mo><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \sum_{j=1}^n Q_j \Pi_{k\neq j} P_k=Q \pmod p  </annotation></semantics></math><em>
</em></div><p>On a donc réussi à remonter l’égalité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>&Pi;</mi><msub><mi>P</mi> <mi>j</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P=\Pi P_j \pmod p</annotation></semantics></math> à 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>&Pi;</mi><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mn>2</mn></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P=\Pi P_{j,2} \pmod {p^2}</annotation></semantics></math>. Le passage de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>&Pi;</mi><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P=\Pi P_{j,l} \pmod {p^l}</annotation></semantics></math>
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>&Pi;</mi><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P=\Pi P_{j,l+1} \pmod {p^{l+1}}</annotation></semantics></math> est identique, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>+</mo><msup><mi>p</mi> <mi>l</mi></msup><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'> P_{j,l+1}=P_{j,l}+p^{l}Q_j  </annotation></semantics></math>
où les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q_j</annotation></semantics></math> sont les solutions de l’identité de Bézout généralisée avec :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>Q</mi><mo>=</mo><mfrac><mrow><mi>P</mi><mo>&minus;</mo><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub></mrow><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow></mfrac></mrow><annotation encoding='application/x-tex'> Q=\frac{P&#x2d;\Pi_{j=1}^n P_{j,l}}{p^l} </annotation></semantics></math></p><p>Lorsqu’on programme cet algorithme (cf. l’appendice), 
on calcule une fois pour toutes les
solutions de l’identité de Bézout pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>Q=1</annotation></semantics></math>, et on multiplie par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>.</p><p><span style="font-weight:bold">Algorithme de remontée de Hensel linéaire</span><br>
Arguments: Un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à coefficients entiers, la liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>P</mi> <mi>j</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding='application/x-tex'>L=\{ P_j \}</annotation></semantics></math> 
de ses facteurs dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X]</annotation></semantics></math><br>
Valeur renvoyée: la liste des facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>p</mi> <mi>l</mi></msup><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p^l \mathbb{Z}[X]</annotation></semantics></math><br>
On calcule la borne de Landau-Mignotte<sup><a id="text32" href="#note32">1</a></sup> 
pour les facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, on multiplie
par le coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow><annotation encoding='application/x-tex'>p^l</annotation></semantics></math> est
strictement plus grand que deux fois cette quantité. On calcule
aussi les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q_j</annotation></semantics></math> de l’identité de Bézout généralisée pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>Q=1</annotation></semantics></math><br>
Puis on fait une boucle pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> variant de 2 à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math>:
</p><ul class="itemize"><li class="li-itemize">
On détermine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&minus;</mo><msub><mi>&Pi;</mi> <mi>j</mi></msub><msub><mi>P</mi> <mi>j</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P&#x2d;\Pi_j P_j \pmod {p^{k}}</annotation></semantics></math>, on divise par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{k&#x2d;1}</annotation></semantics></math>
et on place le résultat dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>
</li><li class="li-itemize">On multiplie les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q_j</annotation></semantics></math> de l’identité de Bézout 
généralisée (correspondants au polynôme 1) par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>
et on détermine le reste de la division euclidienne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q Q_j</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math>,
on multiplie par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{k&#x2d;1}</annotation></semantics></math> et on ajoute le résultat à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math>.
</li></ul><p>Il existe une version quadratique de cette méthode. On passe alors de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>&Pi;</mi><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mi>l</mi></mrow></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P=\Pi P_{j,l} \pmod {p^l}</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>&Pi;</mi><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><mn>2</mn><mi>l</mi></mrow></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mrow><mn>2</mn><mi>l</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P=\Pi P_{j,2l} \pmod {p^{2l}}</annotation></semantics></math>. Pour
cela, il faut trouver les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q_j</annotation></semantics></math> solutions de l’équation :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>Q</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>=</mo><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \sum_{j=1}^n Q_j \Pi_{k\neq j} P_{k,l}=Q \pmod {p^l} </annotation></semantics></math>
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>l=1</annotation></semantics></math>, c’est l’identité de Bézout généralisée, mais ce n’est plus le
cas pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>l&amp;gt;1</annotation></semantics></math>. En fait, on résout cette égalité en remontant l’identité
de Bézout quadratiquement, plus précisément pour trouver les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>S_j</annotation></semantics></math>
solutions de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>S</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mrow><mi>k</mi><mo>,</mo><mn>2</mn><mi>l</mi></mrow></msub><mo>=</mo><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mrow><mn>2</mn><mi>l</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \sum_{j=1}^n S_j \Pi_{k\neq j} P_{k,2l}=Q \pmod {p^{2l}} </annotation></semantics></math>
on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>S</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>Q</mi> <mi>j</mi></msub><mo>+</mo><msup><mi>p</mi> <mi>l</mi></msup><msub><mi>R</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>S_j=Q_j+p^l R_j</annotation></semantics></math>, il s’agit donc de trouver les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>R_j</annotation></semantics></math> solutions de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>Q</mi> <mi>j</mi></msub><mo>+</mo><msup><mi>p</mi> <mi>l</mi></msup><msub><mi>R</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mrow><mi>k</mi><mo>,</mo><mn>2</mn><mi>l</mi></mrow></msub><mo>=</mo><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mrow><mn>2</mn><mi>l</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \sum_{j=1}^n (Q_j+p^l R_j) \Pi_{k\neq j} P_{k,2l}=Q \pmod {p^{2l}} </annotation></semantics></math>
soit :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>R</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>Q</mi><mo>&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>Q</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mrow><mi>k</mi><mo>,</mo><mi>l</mi></mrow></msub></mrow><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow></mfrac><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \sum_{j=1}^n R_j \Pi_{k\neq j} P_{k,l}
=\frac{Q&#x2d;\sum_{j=1}^n Q_j \Pi_{k\neq j} P_{k,l} }{p^l} \pmod {p^l} </annotation></semantics></math>
on en déduit les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>R_j</annotation></semantics></math>.</p><p><span style="font-weight:bold">Algorithme de remontée de Hensel quadratique</span><br>
Arguments et valeur renvoyée identiques à l’algorithme de remontée de Hensel
linéaire ci-dessus.<br>
On commence comme dans le cas linéaire par calculer les coefficients
de l’identité de Bézout généralisée pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>Q=1</annotation></semantics></math> et la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> telle
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mi>l</mi></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{2^l}</annotation></semantics></math> soit supérieur à deux fois la borne de Landau des facteurs
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> fois le coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.<br>
On fait une boucle sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> variant de 1 à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math>:
</p><ul class="itemize"><li class="li-itemize">
On calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&minus;</mo><msub><mi>&Pi;</mi> <mi>j</mi></msub><msub><mi>P</mi> <mi>j</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mi>k</mi></msup></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P&#x2d;\Pi_j P_j \pmod {p^{2^k}}</annotation></semantics></math>, on divise par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{2^{k&#x2d;1}}</annotation></semantics></math>
et on place le résultat dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>
</li><li class="li-itemize">On multiplie par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q_j</annotation></semantics></math> de l’identité de Bézout
généralisée (avec comme second membre le polynôme 1),
on calcule le reste euclidien du résultat par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> (modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{2^{k&#x2d;1}}</annotation></semantics></math>), 
on multiplie par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{2^{k&#x2d;1}}</annotation></semantics></math> et on ajoute à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> (avec les notations
précédentes, on passe ainsi des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><msup><mn>2</mn> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></msub></mrow><annotation encoding='application/x-tex'>P_{j,2^{k&#x2d;1}}</annotation></semantics></math> aux <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>j</mi><mo>,</mo><msup><mn>2</mn> <mi>k</mi></msup></mrow></msub></mrow><annotation encoding='application/x-tex'>P_{j,2^k}</annotation></semantics></math>)
</li><li class="li-itemize">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi></mrow><annotation encoding='application/x-tex'>k=l</annotation></semantics></math> on renvoie la liste des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math>
</li><li class="li-itemize">On calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo>&minus;</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>j</mi></msub><msub><mi>Q</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mi>k</mi></msup></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>1&#x2d;\sum_j Q_j \Pi_{k\neq j} P_k \pmod {p^{2^k}}</annotation></semantics></math>, on
divise par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{2^{k&#x2d;1}}</annotation></semantics></math> et on place le résultat dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math>
</li><li class="li-itemize">On multiplie par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q_j</annotation></semantics></math> de l’identité de Bézout,
généralisée et on calcule le reste euclidien du résultat par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> (modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{2^{k&#x2d;1}}</annotation></semantics></math>), on multiplie par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{2^{k&#x2d;1}}</annotation></semantics></math> et 
on ajoute à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q_j</annotation></semantics></math> (ce qui ajuste les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>Q_j</annotation></semantics></math> qui vérifient
maintenant l’identité de Bézout modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mrow><msup><mn>2</mn> <mi>k</mi></msup></mrow></msup></mrow><annotation encoding='application/x-tex'>p^{2^k}</annotation></semantics></math>)
</li></ul><p><span style="font-weight:bold">Remarque</span><br>
Pendant l’étape de remontée de Hensel, une optimisation classique
consiste à tester la divisibilité dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par le 
facteur lifté <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> (<sup><a id="text33" href="#note33">2</a></sup>)
lorsqu’il n’a pas subi de modification pendant 2 étapes successives
(autrement dit lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow><mo rspace="mediummathspace">)</mo></mrow><mo>=</mo><msub><mi>P</mi> <mi>j</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>P_j \pmod {p^l}=P_j \pmod {p^{l+1}}</annotation></semantics></math> (ou
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>p</mi> <mrow><mn>2</mn><mi>l</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>\pmod {p^{2l}}</annotation></semantics></math> pour le lift quadratique). Si la division
est exacte, on obtient un facteur irréductible de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>.
On recalcule alors la borne de Landau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">/</mo><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P/P_j</annotation></semantics></math> pour diminuer
le nombre d’itérations à effectuer dans cette étape.</p><p><span style="font-weight:bold">Exemple</span> :<br>
Reprenons le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>3</mn></msup><mo>+</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>X</mi> <mn>4</mn></msup><mo>&minus;</mo><mi>X</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(X)=(X^3+X+1)(X^4&#x2d;X+1)</annotation></semantics></math>
et supposons qu’on ait choisi de le factoriser modulo 5 puis 
de remonter. On a 3 facteurs
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mo>=</mo><mi>x</mi><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>a=x&#x2d;2</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>b=x^3+x+1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>c=x^3+2x^2&#x2d;x+2</annotation></semantics></math>. Si on développe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, on trouve 6
coefficients non nuls de valeur absolue 1, 
on peut calculer la borne de Landau-Mignotte correspondante
sur les coefficients d’un facteur entier : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>5</mn></msup><mo stretchy="false">(</mo><msqrt><mo stretchy="false">(</mo></msqrt><mn>6</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>2^{5} (\sqrt(6)+1)</annotation></semantics></math>
soit un peu plus de 110, il suffit donc d’effectuer 3 étapes de
remontée linéaire (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>5</mn> <mn>4</mn></msup><mo>=</mo><mn>625</mn><mi>&gt;</mi><mn>111</mn><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>5^4=625&amp;gt;111/2</annotation></semantics></math>).
On commence par trouver 3 polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> tels que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>A</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo></mtd> <mtd/> <mtd/></mtr> <mtr><mtd><mo lspace="verythinmathspace" rspace="0em">+</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>5</mn><mo rspace="mediummathspace">)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
A(x^3+x+1)(x^3+2x^2&#x2d;x+2)+B(x&#x2d;2)(x^3+2x^2&#x2d;x+2)+&amp; &amp; \\
+C(x&#x2d;2)(x^3+x+1)&amp;=&amp;1 \pmod 5
 \end{matrix} </annotation></semantics></math>
On commence par résoudre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>5</mn><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>D(x^3+2x^2&#x2d;x+2)+C(x&#x2d;2)(x^3+x+1)=1\pmod 5</annotation></semantics></math>,
on trouve <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi><mo>=</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>C=2x^2&#x2d;2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup><mo>&minus;</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>D=&#x2d;2x^3&#x2d;2x^2+2x+1</annotation></semantics></math>. Puis on calcule
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> en résolvant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>E(x^3+x+1)+F(x&#x2d;2)=1</annotation></semantics></math> qui donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>E=1</annotation></semantics></math> et 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding='application/x-tex'>F=&#x2d;x^2&#x2d;2x</annotation></semantics></math> qu’on multiplie par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi><mo>=</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'>A=D</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi><mo>=</mo><mn>2</mn><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup><mo>&minus;</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding='application/x-tex'>B=2x^5+x^4+2x^3&#x2d;2x</annotation></semantics></math>.
Ce qui donne l’identité de Bézout généralisée.</p><p>Passons aux calculs de remontée. On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mo>=</mo><msup><mi>x</mi> <mn>7</mn></msup><mo>&minus;</mo><mn>4</mn><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><mn>5</mn><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>9</mn><msup><mi>x</mi> <mn>3</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>abc=x^7&#x2d;4x^5+5x^4+&#x2d;9x^3&#x2d;x^2&#x2d;4</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msup><mi>x</mi> <mn>7</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P=x^7+x^5+x^3&#x2d;x^2+1</annotation></semantics></math>, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo>=</mo><mo stretchy="false">(</mo><mi>P</mi><mo>&minus;</mo><mi>a</mi><mi>b</mi><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>5</mn><mo>=</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>Q=(P&#x2d;abc)/5=x^5&#x2d;x^4+2x^3+1</annotation></semantics></math>. On pose
alors 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>a</mi> <mn>1</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>a</mi><mo>+</mo><mn>5</mn><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mi>Q</mi><mi>A</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>a</mi><mo rspace="mediummathspace">)</mo></mrow><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>25</mn><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo></mtd></mtr> <mtr><mtd><msub><mi>b</mi> <mn>1</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>b</mi><mo>+</mo><mn>5</mn><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mi>Q</mi><mi>B</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>b</mi><mo rspace="mediummathspace">)</mo></mrow><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>25</mn><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo></mtd></mtr> <mtr><mtd><msub><mi>c</mi> <mn>1</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>c</mi><mo>+</mo><mn>5</mn><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mi>Q</mi><mi>C</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>c</mi><mo rspace="mediummathspace">)</mo></mrow><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>25</mn><mo rspace="mediummathspace">)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} 
a_1&amp;=&amp;a+5 \ (QA \pmod a)\pmod{25}, \\
b_1&amp;=&amp;b+5 \ (QB \pmod b) \pmod{25}, \\
c_1&amp;=&amp;c+5 \ (QC \pmod c) \pmod{25} 
 \end{matrix} </annotation></semantics></math>
donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mn>1</mn></msub><mo>=</mo><mi>a</mi><mo>+</mo><mn>5</mn><mo>&times;</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>2</mn><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><msub><mi>b</mi> <mn>1</mn></msub><mo>=</mo><mi>b</mi><mo>+</mo><mn>5</mn><mo>&times;</mo><mn>0</mn><mo>,</mo><mspace width="1em"/><msub><mi>c</mi> <mn>1</mn></msub><mo>=</mo><mi>c</mi><mo>+</mo><mn>5</mn><mo>&times;</mo><mo stretchy="false">(</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> a_1= a+5 \times (&#x2d;2), \quad b_1=b+5 \times 0, 
\quad c_1=c+5 \times (2x^2&#x2d;x)  </annotation></semantics></math>
En principe, on continue encore 2 itérations de la même manière.
La 2ème itération donne : 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>Q</mi><mo>=</mo><mo stretchy="false">(</mo><mi>P</mi><mo>&minus;</mo><msub><mi>a</mi> <mn>1</mn></msub><msub><mi>b</mi> <mn>1</mn></msub><msub><mi>c</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>25</mn><mo>=</mo><mn>6</mn><msup><mi>x</mi> <mn>5</mn></msup><mo>&minus;</mo><mn>3</mn><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mn>7</mn><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>3</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'> Q=(P&#x2d;a_1 b_1 c_1)/25= 6x^5&#x2d;3x^4+7x^3+3x^2&#x2d;2x+1 </annotation></semantics></math> 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>a</mi> <mn>2</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>a</mi> <mn>1</mn></msub><mo>+</mo><mn>25</mn><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mi>Q</mi><mi>A</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>a</mi><mo rspace="mediummathspace">)</mo></mrow><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>125</mn><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo></mtd></mtr> <mtr><mtd><msub><mi>b</mi> <mn>2</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>b</mi> <mn>1</mn></msub><mo>+</mo><mn>25</mn><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mi>Q</mi><mi>B</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>b</mi><mo rspace="mediummathspace">)</mo></mrow><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>125</mn><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo></mtd></mtr> <mtr><mtd><msub><mi>c</mi> <mn>2</mn></msub></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>c</mi> <mn>1</mn></msub><mo>+</mo><mn>25</mn><mspace width="mediummathspace"/><mo stretchy="false">(</mo><mi>Q</mi><mi>C</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>c</mi><mo rspace="mediummathspace">)</mo></mrow><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mn>125</mn><mo rspace="mediummathspace">)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} 
a_2&amp;=&amp;a_1+25 \ (QA \pmod a) \pmod{125}, \\
b_2&amp;=&amp;b_1+25 \ (QB \pmod b) \pmod{125},\\
c_2&amp;=&amp;c_1+25 \ (QC \pmod c) \pmod{125}
 \end{matrix} </annotation></semantics></math>
donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>a</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>a</mi> <mn>1</mn></msub><mo>+</mo><mn>25</mn><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>&minus;</mo><mn>37</mn><mo>,</mo><mspace width="mediummathspace"/><msub><mi>b</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>b</mi> <mn>1</mn></msub><mo>=</mo><mi>b</mi><mo>,</mo><mspace width="mediummathspace"/><msub><mi>c</mi> <mn>2</mn></msub><mo>=</mo><msub><mi>c</mi> <mn>1</mn></msub><mo>+</mo><mn>25</mn><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>37</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>6</mn><mi>x</mi><mo>+</mo><mn>27</mn></mrow><annotation encoding='application/x-tex'> a_2=a_1 +25(&#x2d;1)=x&#x2d;37, \ b_2=b_1=b, \ c_2=c_1+25(x^2+1) 
=x^3+37x^2&#x2d;6x+27  </annotation></semantics></math></p><p>On peut aussi observer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mn>1</mn></msub><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>b_1=b</annotation></semantics></math>, ceci laisse à penser que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi></mrow><annotation encoding='application/x-tex'>b</annotation></semantics></math> est 
un facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> ce qu’on vérifie en effectuant la
division euclidienne de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>=</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>b=x^3+x+1</annotation></semantics></math>. Comme elle tombe
juste, on est ramené à factoriser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>4</mn></msup><mo>&minus;</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^4&#x2d;x+1</annotation></semantics></math> et donc à remonter
la factorisation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi><mi>c</mi></mrow><annotation encoding='application/x-tex'>ac</annotation></semantics></math>. La borne de Landau diminue à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>8</mn><mo stretchy="false">(</mo><msqrt><mn>3</mn></msqrt><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>8(\sqrt{3}+1)</annotation></semantics></math>
puisque le degré est 4 et la norme euclidienne du polynôme est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>3</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{3}</annotation></semantics></math>.
Il suffit alors de remonter dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>125</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/125 \mathbb{Z}</annotation></semantics></math> au lieu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>625</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/625 \mathbb{Z}</annotation></semantics></math>
(on gagne ainsi une itération).</p>
<!--TOC subsection id="sec171" Combinaison de facteurs-->
<h3 id="sec171" class="subsection">18.2.6  Combinaison de facteurs</h3><!--SEC END --><p>
Lorsqu’on a les facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>p</mi> <mi>k</mi></msup><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p^k\mathbb{Z}[X]</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>p^k</annotation></semantics></math> plus grand
que le produit du coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> multiplié par la borne
de Landau-Mignotte sur les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, on commence par
tester la divisibilité dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par chaque facteur trouvé
multiplié par le coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Si la division est
exacte, on a un facteur irréductible, mais si elle n’est pas exacte
il peut se produire qu’un facteur irréductible de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math> soit un
produit de deux, voir plusieurs, facteurs modulaires. Il faut
donc tester la divisibilité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math> par toutes les combinaisons 
possibles de produits de facteurs modulaires (toujours multiplié par
le coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>). Cette étape peut être exponentiellement
longue si le nombre de facteurs modulaires est grand et si par
exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est irréductible, bien que les cas soient très rares. </p><p><span style="font-weight:bold">Algorithme de recombinaison</span><br>
Arguments: un polynôme à coefficients entiers, primitif et sans facteur 
multiple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de coefficient dominant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>p_n</annotation></semantics></math>,
la liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> des facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>p</mi> <mi>l</mi></msup><mi>Z</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p^l Z[X]</annotation></semantics></math> pour 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> assez grand et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow><annotation encoding='application/x-tex'>p^l</annotation></semantics></math><br>
Valeur de retour: la liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> des facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>.<br>
Initialiser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> à vide, initialiser le nombre de facteurs à combine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> 
à 1, entamer une boucle infinie :
</p><ul class="itemize"><li class="li-itemize">
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> est strictement supérieur au cardinal de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> divisé par 2,
ajouter le quotient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par le produit des facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> 
et retourner <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math>
</li><li class="li-itemize">Initialiser un vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>v</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>v</mi> <mi>c</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v=(v_1,...,v_c)</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> composantes à
la valeur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>c</mi></mrow><annotation encoding='application/x-tex'>(1,...,c</annotation></semantics></math>)
</li><li class="li-itemize">Boucle indéfinie intérieure :
<ol class="enumerate" type=1><li class="li-enumerate">
Faire le produit des facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> d’indice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>, multiplier
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>p_n</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><msup><mi>p</mi> <mi>l</mi></msup><mi>Z</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p^l Z</annotation></semantics></math>, écrire le facteur en représentation symétrique,
le rendre primitif et tester si c’est un facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>.
</li><li class="li-enumerate">Si on a trouvé un facteur, le rajouter à la liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math> et supprimer les
indices de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> de la liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>, terminer cette boucle intérieure.
</li><li class="li-enumerate">Sinon, incrémenter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> de la manière suivante:<br>
On fait une boucle sur un index <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> initialisé à la taille de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>,
diminuant de 1 à chaque itération: on ajoute 1 à l’élement de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>
d’indice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math>, si l’élément obtenu est inférieur ou égal
au cardinal de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mo>+</mo><mi>m</mi><mo>&minus;</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>L+m&#x2d;n</annotation></semantics></math>, on arrête cette boucle, sinon on passe
à l’itération suivante. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>m=0</annotation></semantics></math> à la fin de la boucle, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math>
ne peut pas être incrémenté. 
</li><li class="li-enumerate">Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> ne peut être incrémenté, on incrémente <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> et on termine
la boucle intérieure.
</li><li class="li-enumerate">Sinon on fait une boucle à nouveau
sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> en partant de la valeur actuelle incrémentée de 1, et tant
que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>&leq;</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>m\leq n</annotation></semantics></math> on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>v</mi> <mi>m</mi></msub><mo>=</mo><msub><mi>v</mi> <mrow><mi>m</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>v_m=v_{m&#x2d;1}+1</annotation></semantics></math>. Puis on passe à l’itération
suivante de la boucle intérieure.
</li></ol>
</li></ul><p>Il existe différentes méthodes
qui améliorent la complexité de cette étape :
</p><ul class="itemize"><li class="li-itemize">
La recherche des degré possibles de facteurs fondée sur
la factorisation en degrés distincts pour différents nombres premiers 
permet d’éviter des tests de division si une combinaison de facteurs
est d’un degré exclu par la factorisation pour d’autres nombres premiers.
</li><li class="li-itemize">Le test de divisibilité du coefficient dominant ou du coefficient
constant permet aussi d’éviter des divisions complètes de polynômes.
</li></ul><p>
Mais ces astuces n’évitent pas l’énumération de toutes les combinaisons
possibles de facteurs et donc la complexité exponentielle. Lorsque
les combinaisons d’un petit nombre de facteurs (par exemple 3)
échouent, les systèmes récents utilisent
l’algorithme <span style="font-weight:bold">knapsack</span><a id="hevea_default205"></a> de Van Hoeij basé sur l’algorithme LLL
(recherche de base d’un réseau ayant des vecteurs de petite norme) 
qui permet d’eliminer complètement cette complexité exponentielle.</p><p><span style="font-weight:bold">Exemple</span> :<br>
Toujours le même exemple, il nous restait deux
facteurs dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>125</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/125 \mathbb{Z}</annotation></semantics></math>, le facteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^3+x+1</annotation></semantics></math> ayant été
détecté comme un facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msup><mi>x</mi> <mn>7</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>&minus;</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P=x^7+x^5+x^3&#x2d;x^2+1</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>.
On teste chacun des facteurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mn>2</mn></msub><mo>=</mo><mi>x</mi><mo>&minus;</mo><mn>37</mn></mrow><annotation encoding='application/x-tex'>a_2=x&#x2d;37</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>c</mi> <mn>2</mn></msub><mo>=</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>37</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>6</mn><mo>*</mo><mi>x</mi><mo>+</mo><mn>27</mn></mrow><annotation encoding='application/x-tex'>c_2=x^3+37x^2&#x2d;6*x+27</annotation></semantics></math>
séparément, sans succès. On les multiplie alors modulo 125,
ce qui donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>4</mn></msup><mo>&minus;</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^4&#x2d;x+1</annotation></semantics></math> en représentation symétrique qui est bien
un facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> (donc un facteur irréductible).</p>
<!--TOC section id="sec172" Factorisation à plusieurs variables-->
<h2 id="sec172" class="section">18.3  Factorisation à plusieurs variables</h2><!--SEC END --><p>
Comme pour le PGCD en plusieurs variables, on se ramène d’abord en
une variable, en général on évalue toutes les variables sauf celle
correspondant au degré partiel le plus faible. On factorise ensuite
en une variable puis on remonte. A chaque étape de remontée, il peut
être à nouveau nécessaire de combiner plusieurs facteurs. Différentes
stratégies existent, comme pour le PGCD : factorisarion heuristique
(avec reconstruction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>-adique), remontée variable par variable
ou toutes les variables en même temps comme dans EZGCD.
On va présenter ici plus en détails l’algorithme de factorisation heuristique.</p><p>Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> un polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_n</annotation></semantics></math> à coefficients entiers avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&amp;gt;1</annotation></semantics></math>,
on choisit une des variables par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>X_n</annotation></semantics></math>, qu’on notera <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math> dans la suite.
On considère <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> comme un polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1}</annotation></semantics></math> à coefficients dans 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math>. On suppose que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est primitif (quitte à extraire
son contenu qui est dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math>). On calcule ensuite
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(z)</annotation></semantics></math> pour un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> tel que<sup><a id="text34" href="#note34">3</a></sup> <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo>&geq;</mo><mn>2</mn><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>|z| \geq 2|P|+2</annotation></semantics></math>. On factorise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(z)</annotation></semantics></math>
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X_1,...,X_{n&#x2d;1}]</annotation></semantics></math> :
<a id="eqref_20"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></msubsup><msub><mi>p</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>20</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 P(z)(X_1,...,X_{n&#x2d;1})=c(z) \Pi_{j=1}^k p_j(X_1,...,X_{n&#x2d;1})
\qquad (20) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> est le contenu du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(z)</annotation></semantics></math> (comme polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> 
variables à coefficients entiers). Il s’agit de reconstruire les facteurs
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à partir des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>p_j</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math>. Deux problèmes se posent alors,
celui de la recombinaison possible de plusieurs facteurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>p_j</annotation></semantics></math> pour
obtenir un facteur irréductible de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, et l’existence d’un facteur entier du
contenu <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> à combiner avec un ou plusieurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>p_j</annotation></semantics></math> pour obtenir ce
facteur irréductible. Plus précisément, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> est un facteur 
irréductible de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, on a :
<a id="eqref_21"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mi>&Pi;</mi> <mrow><mtext>certains </mtext><mi>j</mi></mrow></msub><msub><mi>p</mi> <mi>j</mi></msub><mo>,</mo><mspace width="1em"/><mtext>où </mtext><mi>d</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mtext> divise </mtext><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>21</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 P_k(z)=d(z) \Pi_{\mbox{certains } j} p_j, \quad \mbox{où } 
d(z) \mbox{ divise } c(z)
\qquad (21) </annotation></semantics></math></p><p>On a le :
</p><div class="theorem"><span style="font-weight:bold">Théorème 36</span>  <em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(X_1,...,X_{n&#x2d;1},X)</annotation></semantics></math><em> un polynôme à coefficients 
entiers ayant au moins 2 variables. On suppose que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> est primitif
vu comme polynôme en les variables </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1}</annotation></semantics></math><em>
à coefficients dans </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Z</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>Z[X]</annotation></semantics></math><em>.
Il existe une majoration </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math><em> du contenu </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|c(z)|</annotation></semantics></math><em> de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> évalué en </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding='application/x-tex'>X=z</annotation></semantics></math><em>
(plus précisément on peut trouver un entier </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math><em> tel que </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c(z)</annotation></semantics></math><em> divise
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math><em>).<br>
Il existe un nombre fini de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math><em> tels que l’un des facteurs irréductibles
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math><em> de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><em> évalué en </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding='application/x-tex'>X=z</annotation></semantics></math><em> soit
réductible (c’est-à-dire tels que (</em><a href="#eqref_21">21</a><em>) admette 
plusieurs facteurs </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>p_j</annotation></semantics></math><em> distincts)
</em></div><p><span style="font-weight:bold">Preuve</span><br>
Pour déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math>, on remarque que les facteurs du contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(z)</annotation></semantics></math>
sont des facteurs communs des coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> évalués en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>
vu comme polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1}</annotation></semantics></math> à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math>.
Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c(z)</annotation></semantics></math> divise le générateur de l’idéal engendré par ces coefficients
(ce générateur est un polynôme de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math> qui est constant car on a supposé
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> primitif), on peut aussi dire que deux au moins des coefficients
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> sont premiers entre eux, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c(z)</annotation></semantics></math> divise le
coefficient de l’identité de Bézout de ces 2 coefficients vu
comme polynômes en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math>.</p><p>Considérons maintenant un facteur irréductible <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math>
par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math>. Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1}</annotation></semantics></math> fixés, on factorise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{C}</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>p</mi> <mi>k</mi></msub><msubsup><mi>&Pi;</mi> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>d</mi></msubsup><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> P_k(X)=p_k \Pi_{j=1}^d (X&#x2d;z_j)  </annotation></semantics></math>
On va maintenant se restreindre à un domaine des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1}</annotation></semantics></math> sur
lequel les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>z_j</annotation></semantics></math> ont une dépendance analytique par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1}</annotation></semantics></math>.
Pour cela on veut appliquer le théorème des fonctions implicites pour 
déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>z_j</annotation></semantics></math> au voisinage d’une solution donnée. On calcule donc
la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><msub><mo>&prime;</mo> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P&apos;_k</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math>. On sait que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> n’a pas
de facteurs multiples, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P_k&apos;</annotation></semantics></math> sont premiers entre
eux, donc d’après l’identité de Bézout, il existe un polynôme non nul <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math>
dépendant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1}</annotation></semantics></math> et deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>U</mi></mrow><annotation encoding='application/x-tex'>U</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math> dépendant
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1},X</annotation></semantics></math> tels que :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>U</mi><msub><mi>P</mi> <mi>k</mi></msub><mo>+</mo><mi>V</mi><msub><mi>P</mi> <mi>k</mi></msub><mo>&prime;</mo><mo>=</mo><mi>D</mi></mrow><annotation encoding='application/x-tex'> U P_k + V P_k&apos; = D  </annotation></semantics></math>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>D(X_1,...,X_{n&#x2d;1})</annotation></semantics></math> ne s’annule pas, on va pouvoir appliquer le théorème
des fonctions implicites. On se fixe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_1,..,x_{n&#x2d;1}</annotation></semantics></math>,
on calcule dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{C}</annotation></semantics></math> les racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>z_j</annotation></semantics></math> du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(x_1,..,x_{n&#x2d;1},X)</annotation></semantics></math>
pour une solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>z_j</annotation></semantics></math> telle que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P(x_1,..,x_{n&#x2d;1},z_j)=0</annotation></semantics></math>, 
comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> est non nul, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>&ne;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P&apos;(x_1,...,x_{n&#x2d;1},z_j)\neq 0</annotation></semantics></math>, donc on peut 
écrire au voisinage de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x_1,..,x_{n&#x2d;1})</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>z</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'> z_j=z_j(X_1,...,X_{n&#x2d;1}), \quad P(X_1,...,X_{n&#x2d;1},z_j)=0 </annotation></semantics></math> 
avec des fonctions <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>z_j</annotation></semantics></math> analytiques. 
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> est constant, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> ne s’annule pas, 
sinon quitte à permuter les variables, on peut supposer que
le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>X_1</annotation></semantics></math> est non nul.
On peut alors se restreindre à une zone <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mi>&gt;</mi><mi>&gt;</mi><msub><mi>X</mi> <mn>2</mn></msub><mi>&gt;</mi><mi>&gt;</mi><mo>.</mo><mo>.</mo><mi>&gt;</mi><mi>&gt;</mi><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>&gt;</mi><mi>&gt;</mi><mn>1</mn></mrow><annotation encoding='application/x-tex'>X_1 &amp;gt;&amp;gt; X_2 &amp;gt;&amp;gt; .. &amp;gt;&amp;gt; X_{n&#x2d;1} &amp;gt;&amp;gt; 1</annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>D</mi></mrow><annotation encoding='application/x-tex'>D</annotation></semantics></math> sera non nul ce qui permet de suivre analytiquement les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>z_j</annotation></semantics></math>.</p><p>Supposons maintenant qu’il existe un nombre infini de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> tels <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_k(z)</annotation></semantics></math> 
soit réductible. Alors il existe un ensemble infini <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Z</mi></mrow><annotation encoding='application/x-tex'>Z</annotation></semantics></math>
de ces valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> pour lesquels l’un des facteurs à coefficients
entiers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>f</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>f_j</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_k(z)</annotation></semantics></math> correspond à un même
sous-ensemble <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> des racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>z</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>z_j</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> et à un même contenu
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> (puisqu’il y a un nombre fini de combinaisons possibles des
racines en facteur et un nombre fini de diviseurs possibles
du contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math>). Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi><mo>&Element;</mo><mi>Z</mi></mrow><annotation encoding='application/x-tex'>z \in Z</annotation></semantics></math>, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>f</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mi>n</mi></msub><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><msub><mi>&Pi;</mi> <mrow><mi>l</mi><mo>&Element;</mo><mi>R</mi></mrow></msub><mo stretchy="false">(</mo><mi>z</mi><mo>&minus;</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">)</mo><mo>,</mo><mspace width="1em"/><msub><mi>f</mi> <mi>j</mi></msub><mo>&Element;</mo><mi>&Zopf;</mi><mo stretchy="false">[</mo><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'> f_j(X_1,...,X_n,z)=c \Pi_{l \in R} (z&#x2d;z_j), \quad 
f_j \in \mathbb{Z}[X_1,...,X_{n&#x2d;1}]  </annotation></semantics></math>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>L(X)</annotation></semantics></math> le polynôme obtenu par interpolation de Lagrange 
en cardinal<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>(R)+1</annotation></semantics></math> points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Z</mi></mrow><annotation encoding='application/x-tex'>Z</annotation></semantics></math>, égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>f</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>f_j</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding='application/x-tex'>X=z</annotation></semantics></math>.
Pour des raisons de degré, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>L</mi><mo>=</mo><mi>c</mi><msub><mi>&Pi;</mi> <mrow><mi>l</mi><mo>&Element;</mo><mi>R</mi></mrow></msub><mo stretchy="false">(</mo><mi>X</mi><mo>&minus;</mo><msub><mi>z</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> L=c \Pi_{l \in R} (X&#x2d;z_j)  </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> est un facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.
De plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> est un polynôme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>X</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>X</mi></mrow><annotation encoding='application/x-tex'>X_1,...,X_{n&#x2d;1},X</annotation></semantics></math> à coefficients
rationnels (par construction). Ceci vient en contradiction avec l’hypothèse 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> irréductible, car on a construit un facteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> à coefficients
rationnels <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> de degré strictement inférieur.</p><p><span style="font-weight:bold">Corollaire</span><br>
Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> assez grand, la reconstruction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>-adique de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mi>p</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c(z) p_j(z)</annotation></semantics></math> est
un polynôme dont la partie primitive est un facteur irréductible de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.</p><p><span style="font-weight:bold">Preuve du corollaire</span><br>
On prend <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> assez grand pour que tous les facteurs irréductibles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>
évalués en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> aient un seul facteur polynomial (i.e. soient de la forme 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mi>p</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>d(z)p_j(z)</annotation></semantics></math>). Quitte à augmenter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>, on peut supposer que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mi>&gt;</mi><mn>2</mn><mi>C</mi><mi>L</mi></mrow><annotation encoding='application/x-tex'>|z|&amp;gt; 2 C L </annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> est la majoration de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|c(z)|</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> est la borne 
de Landau sur les facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Alors la reconstruction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>-adique
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mi>p</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c(z)p_j(z)</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>d</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>c(z)/d(z)P_j</annotation></semantics></math>, donc sa partie primitive est un
facteur irréductible de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.</p><p><span style="font-weight:bold">Algorithme de factorisation heuristique à plusieurs variables</span><br>
Argument: un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> primitif en au moins 2 variables.<br>
Valeur renvoyée: les facteurs irréductibles de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math><br>
Choisir la variable <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math> par rapport à laquelle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est de plus bas degré puis
factoriser le contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> vu comme polynôme à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}[X]</annotation></semantics></math>.
Initialiser un entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>2|P|+2</annotation></semantics></math> (où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|P|</annotation></semantics></math> est le plus grand coefficient 
entier de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> en valeur absolue) et une liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> à la factorisation de
du contenu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.<br>
Boucle indéfinie :
</p><ul class="itemize"><li class="li-itemize">
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P=1</annotation></semantics></math> renvoyer la liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math> des facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.
</li><li class="li-itemize">Tant que pgcd<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>,</mo><mi>P</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>(P(z),P&apos;(z))=0</annotation></semantics></math> incrémenter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> de 1.
</li><li class="li-itemize">Factoriser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mi>&Pi;</mi><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P(z)=c(z)\Pi p_j</annotation></semantics></math>
</li><li class="li-itemize">Pour tous les facteurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>p</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>p_j</annotation></semantics></math>, déterminer le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> tel que 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mi>p</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>P</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c(z)p_j=P_j(z)</annotation></semantics></math> par remontée
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>-adique (avec les coefficients de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> écrit en représentation
symétrique, de valeur absolue plus petite que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>z</mi><mo stretchy="false">&vert;</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>|z|/2</annotation></semantics></math>). Tester si
la partie primitive de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Si oui, rajouter un facteur
irréductible à la liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>, et diviser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par ce facteur.
</li><li class="li-itemize">Augmenter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math>, par exemple remplacer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>z</mi></mrow><annotation encoding='application/x-tex'>z</annotation></semantics></math> par la partie entière de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt><mi>z</mi></mrow><annotation encoding='application/x-tex'>\sqrt{2}z</annotation></semantics></math>.
</li></ul>
<!--TOC section id="sec173" Preuve de l’identité de Bézout généralisée-->
<h2 id="sec173" class="section">18.4  Preuve de l’identité de Bézout généralisée</h2><!--SEC END --><p>
Elle se fait par récurrence. Pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n=2</annotation></semantics></math>, c’est l’identité de Bézout usuelle. 
Pour passer
du rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> au rang <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, on isole <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> dans l’identité à résoudre :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mo>(</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>Q</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><msub><mi>&Pi;</mi> <mrow><mn>1</mn><mo>&leq;</mo><mi>k</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mo stretchy="false">)</mo><mo>)</mo></mrow><msub><mi>P</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>Q</mi> <mi>n</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mo>=</mo><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \left( 
\sum_{j=1}^{n&#x2d;1} Q_j (\Pi_{1 \leq k \leq n&#x2d;1,k\neq j} P_k) \right) P_n + 
Q_n \Pi_{k\leq n&#x2d;1} P_k =Q \pmod p </annotation></semantics></math>
Comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> est premier avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\Pi_{k\leq n&#x2d;1} P_k</annotation></semantics></math>, en appliquant Bézout,
on trouve deux polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Q_n</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>R_n</annotation></semantics></math> tels que :
<a id="eqref_22"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>R</mi> <mi>n</mi></msub><msub><mi>P</mi> <mi>n</mi></msub><mo>+</mo><msub><mi>Q</mi> <mi>n</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mo>=</mo><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow><mspace width="2em"/><mo stretchy="false">(</mo><mn>22</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 R_n P_n + Q_n \Pi_{k\leq n&#x2d;1} P_k =Q \pmod p 
\qquad (22) </annotation></semantics></math>
Il reste à résoudre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><msub><mi>Q</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mn>1</mn><mo>&leq;</mo><mi>k</mi><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo>,</mo><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mo>=</mo><msub><mi>R</mi> <mi>n</mi></msub><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \sum_{j=1}^{n&#x2d;1} Q_j \Pi_{1 \leq k \leq n&#x2d;1,k\neq j} P_k=R_n \pmod p </annotation></semantics></math>
ce que l’on peut faire par hypothèse de récurrence.</p>
<!--TOC section id="sec174" Algorithme de Bézout généralisé-->
<h2 id="sec174" class="section">18.5  Algorithme de Bézout généralisé</h2><!--SEC END --><p><a id="hevea_default206"></a>
Arguments: une liste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_1,...,P_n</annotation></semantics></math> de polynômes premiers entre eux 2 à 2 
et un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math><br>
Valeur renvoyée: la liste de polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>Q</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Q_1,...,Q_n</annotation></semantics></math> tels que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><msub><mi>Q</mi> <mi>j</mi></msub><msub><mi>&Pi;</mi> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><msub><mi>P</mi> <mi>k</mi></msub><mo>=</mo><mi>Q</mi><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> \sum_{j=1}^n Q_j \Pi_{k\neq j} P_k=Q \pmod p  </annotation></semantics></math>
On peut commencer par calculer le produit de tous les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> puis faire une 
boucle sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> pour calculer les produits des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>P_k</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow><annotation encoding='application/x-tex'>k\neq j</annotation></semantics></math> en divisant
le produit complet par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> (on fait ainsi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math> multiplications et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> divisions au lieu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>n(n&#x2d;1)</annotation></semantics></math> multiplications).<br>
Boucle indéfinie sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> décrémenté de 1 par itération :
</p><ul class="itemize"><li class="li-itemize">
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n=2</annotation></semantics></math>, on rajoute à la liste résultat les polynômes 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>Q_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>Q_2</annotation></semantics></math> de l’algorithme de Bézout usuel et on renvoie la liste
</li><li class="li-itemize">Sinon, on calcule les polynômes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>R_n</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Q_n</annotation></semantics></math> vérifiant (<a href="#eqref_22">22</a>),
on rajoute <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>Q_n</annotation></semantics></math> en début de liste, on remplace <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>R</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>R_n</annotation></semantics></math>.
</li></ul><p>
Remarquons que lorsque nous utiliserons cet algorithme, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> sera la différence
entre deux polynômes de même degré (le degré de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>) et de même coefficient
dominant 1, on peut donc
remplacer les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>Q_i</annotation></semantics></math> par le reste euclidien de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>Q</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>Q_i</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>P_i</annotation></semantics></math> sans
changer l’égalité.</p>
<!--TOC section id="sec175" Factorisation rationnelle et sur une extension-->
<h2 id="sec175" class="section">18.6  Factorisation rationnelle et sur une extension</h2><!--SEC END --><p>
<a id="sec:factorisation_extension"></a>
<a id="hevea_default207"></a> <a id="hevea_default208"></a><a id="hevea_default209"></a> 
Pour factoriser des polynômes ayant des coefficients dans des
extensions algébriques, il existe un algorithme assez simple, 
l’algorithme de Trager, qui n’est pas forcément le plus performant 
(la recherche est encore active dans ce domaine), cf. le livre de 
Henri Cohen pp. 142-144. Cet algorithme est utilisé lorsqu’on
met l’extension algébrique en deuxième argument de <code>factor</code>
dans Xcas. Pour trouver l’extension algébrique qui permet de
factoriser, on peut dans les cas simples essayer <code>solve</code>. Si
le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> à factoriser est irréductible sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Q}</annotation></semantics></math>, 
on peut essayer <code>factor(P,rootof(P))</code>. Mais en général
cela ne permettra d’extraire qu’un seul facteur de degré 1. Pour
obtenir une décomposition complète si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est de petit
degré, on peut essayer de construire une extension en
formant une expression non symétrique à partir des racines approchées,
puis en appliquant toutes les permutations de racines à cette
expression et en construisant le polynôme ayant ces racines,
si on a suffisamment de précision sur les racines, on peut arrondir
le polynôme obtenu, le factoriser sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Q}</annotation></semantics></math>, et prendre un des
facteurs irréductibles de degré suffisant comme argument de
<code>rootof</code>.</p><p>Par exemple soit à factoriser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P=x^4+3x+1</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>&Qopf;</mi><mo>&#x000AF;</mo></mover></mrow><annotation encoding='application/x-tex'>\overline{\mathbb{Q}}</annotation></semantics></math>.
On entre la fonction suivante :
</p><pre class="verbatim">f(P):={
  local k,l,p,r,j;
  l:=proot(P);
  if (dim(l)!=4) return "erreur";
  k:=max(abs(l));
  k:=floor(24*log10(1+4*k))+4; // 4 chiffres de precision en plus
  l:=proot(P,k);
  p:=[0,1,2,3];
  r:=[];
  for j from 0 to 23 do
    k:=l[p[0]]-l[p[1]]+2*l[p[2]];
    r:=append(r,k);
    p:=nextperm(p);
  od;
  retourne r;
}:;
</pre><p>
puis <code>q:=pcoef(f(x^4+3x+1))</code>, on voit que les
coefficients sont presque entiers, on fait donc
<code>factor(x^4+3x+1,rootof(round(q)))</code>
qui décompose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^4+3x+1</annotation></semantics></math> en 4 facteurs de degré 1. Le polynôme
obtenu est de degré 24 (cas générique), si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est de degré
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, on s’attend à un degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>!</mo></mrow><annotation encoding='application/x-tex'>n!</annotation></semantics></math>, au-delà de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>n=5</annotation></semantics></math>, cette
méthode est trop couteuse! Attention aussi, même pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>n=4</annotation></semantics></math>, il peut être
nécessaire de calculer les racines en multi-précision, 
par exemple ci-dessus les éléments
de <code>r</code> sont majorés par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>4</mn><mi>R</mi></mrow><annotation encoding='application/x-tex'>4R</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> est un majorant du module 
des racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, donc
les coefficients de <code>q</code> sont majorés par exemple par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>4</mn><mi>R</mi><msup><mo stretchy="false">)</mo> <mn>24</mn></msup><mo>&approx;</mo><mn>2</mn><mi>e</mi><mn>20</mn></mrow><annotation encoding='application/x-tex'>(1+4R)^{24}
\approx 2e20</annotation></semantics></math> donc on prend 24 chiffres.</p><p>Autre méthode utilisant la représentation rationnelle
univariée (section <a href="#sec%3Arur">9.8</a>) : 
on écrit le système vérifié par les relations
racines-coefficients, ici<br>
<code>P:=x^4+3x+1;eq:=lcoeff(P)*pcoef([a,b,c,d])-symb2poly(P)</code><br>
on vérifie qu’on obtient les 24 permutations de racines par<br>
<code>cfsolve(eq,[a,b,c,d])</code><br>
Le polynôme permettant de factoriser complètement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> se lit dans<br>
<code>G:=gbasis(eq,[a,b,c,d],rur);</code><br>
on obtient la factorisation complète par :<br>
<code>factor(x^4+3x+1,rootof(G[2]))</code><br>
On peut aussi la déduire de l’expressions des racines<br>
<code>Q:=product(x-rootof(G[k],G[2])/rootof(G[3],G[2]),</code><br>
<code>   k,4,size(G)-1);normal(Q)</code><br>
Pour un polynome quelconque, on peut utiliser le script suivant<br>
</p><pre class="verbatim">extension(p):={
local l,s,g;
 l:=seq(expr("x"+j),j,1,degree(p));
 s:=lcoeff(p)*pcoeff(l)-symb2poly(p);
 g:=gbasis(s,l,rur);
 return g[2];
}
</pre><p>
mais les calculs deviennent très vite monstrueux!</p><p>Pour les polynômes à plusieurs variables, Giac commence par donner
la valeur 0 à toutes les variables sauf celle correspondant à la variable de
degré partiel minimum. Si le polynôme obtenu est square-free, alors Giac
reconstruit par remontée de Hensel les facteurs, en augmentant
au fur et à mesure le degré des facteurs par rapport aux autres
variables. En cas d’échec, l’algorithme de Trager est utilisé,
ce qui est en général beaucoup plus lent (à commencer par le
calcul de la “norme” du polynôme à factoriser par un résultant).</p>
<!--TOC section id="sec176" Factorisation absolue-->
<h2 id="sec176" class="section">18.7  Factorisation absolue</h2><!--SEC END --><p><a id="hevea_default210"></a> <a id="sec:factorisation_absolue"></a>
On peut aussi se demander pour un polynôme à coefficients
rationnels (squarefree) quelle extension<a id="hevea_default211"></a><a id="hevea_default212"></a> 
permet la factorisation la plus
complète. Par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><msup><mi>y</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>x^2+y^2</annotation></semantics></math> est irréductible sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi><mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Q}[x,y]</annotation></semantics></math>
mais pas sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Q}[i][x,y]</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><msup><mi>y</mi> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>x^4+y^4</annotation></semantics></math> est irréductible sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi><mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Q}[x,y]</annotation></semantics></math>
mais pas sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Qopf;</mi><mo stretchy="false">[</mo><msqrt><mn>2</mn></msqrt><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Q}[\sqrt{2}][x,y]</annotation></semantics></math>. Ceci amène à la notion
de <em>factorisation absolue</em> d’un polynôme. Une méthode simple
(mais pas forcément très efficace) pour déterminer une telle
extension algébrique consiste à évaluer toutes les variables
sauf une “au hasard" jusqu’à obtenir un polynôme irréductible <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>.
On factorise alors sur le corps correspondant à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>. Mais cela
peut être très long, par exemple pour 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>y</mi> <mn>10</mn></msup><mo>&minus;</mo><mn>2</mn><msup><mi>x</mi> <mn>2</mn></msup><msup><mi>y</mi> <mn>4</mn></msup><mo>+</mo><mn>4</mn><msup><mi>x</mi> <mn>6</mn></msup><msup><mi>y</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>2</mn><msup><mi>x</mi> <mn>10</mn></msup></mrow><annotation encoding='application/x-tex'> P(x,y)=y^{10}&#x2d;2x^2y^4+4x^6y^2&#x2d;2x^{10} </annotation></semantics></math>
on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(x,1)</annotation></semantics></math> irréductible, on obtient donc la factorisation
absolue par les commande<br>
<code>p(x,y):=y^10-2x^2*y^4+4x^6*y^2-2x^10;</code><br>
<code>p1:=p(1,y); factor(p1);</code> (vérification)<br>
<code>factor(p(x,y),rootof(p1));</code><br>
mais c’est beaucoup plus long que de faire <code>factor(p1,sqrt(2))</code>.</p><p>Pour un polynôme à 2 variables (on peut toujours s’y ramener) de
degrés partiels <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>m,n</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><annotation encoding='application/x-tex'>x,y</annotation></semantics></math>,
on remarque que le degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mo>&geq;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>q \geq 2</annotation></semantics></math> de l’extension nécessaire est
égal au nombre de facteurs (chaque facteur étant conjugué d’un
facteur donné par échange des racines), qui sont donc tous de même
bi-degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo stretchy="false">/</mo><mi>q</mi><mo>,</mo><mi>n</mi><mo stretchy="false">/</mo><mi>q</mi></mrow><annotation encoding='application/x-tex'>m/q,n/q</annotation></semantics></math>, en particulier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> divise le PGCD de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
qui doit être non trivial. Ainsi par exemple pour 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>Y</mi> <mn>4</mn></msup><mo>+</mo><mn>2</mn><msup><mi>Y</mi> <mn>2</mn></msup><mo>*</mo><mi>X</mi><mo>+</mo><mn>14</mn><msup><mi>Y</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>7</mn><mo>*</mo><msup><mi>X</mi> <mn>2</mn></msup><mo>+</mo><mn>6</mn><mi>X</mi><mo>+</mo><mn>47</mn></mrow><annotation encoding='application/x-tex'>P(X,Y)=Y^4 +2Y^2*X+14Y^2 &#x2d;7*X^2 +6X+47 </annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>m=2</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> ne peut être égal qu’à 2, en faisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>Y=0</annotation></semantics></math> on
obtient que la seule extension possible est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msqrt><mn>2</mn></msqrt></mrow><annotation encoding='application/x-tex'>\sqrt{2}</annotation></semantics></math>.</p><p>Voir aussi la session <code>afactor.xws</code> du menu Exemple, poly de Xcas.</p>
<!--TOC section id="sec177" Compléments-->
<h2 id="sec177" class="section">18.8  Compléments</h2><!--SEC END --><p>
Pour factoriser sur des corps finis, on peut consulter la thèse
de Bernardin disponible sur le web (<code>http://www.bernardin.lu</code>).</p><p>L’algorithme récursif qui suit permet d’écrire un <span style="font-weight:bold">polynôme
symétrique</span><a id="hevea_default213"></a><a id="hevea_default214"></a>
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> variables (noté <code>s</code> dans le programme)
en fonction des polynômes symétriques élémentaires. L’idée
est de remplacer la dernière variable <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math> par 0, le polynôme
obtenu <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> est symétrique en les autres variables, on appelle
récursivement la procédure (avec une variable de moins),
elle renvoie un polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math>. On crée dans <code>S</code> les polynômes symétriques
élémentaires avec la fonction <code>pcoeff</code>, on les utilise
pour substituer
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math> par les polynômes symétriques élémentaires sauf
le dernier, ce qui donne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>V</mi> <mi>s</mi></msub></mrow><annotation encoding='application/x-tex'>V_s</annotation></semantics></math> symétrisé de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>V</mi></mrow><annotation encoding='application/x-tex'>V</annotation></semantics></math> par rapport aux
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> variables, puis on retranche <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>V</mi> <mi>s</mi></msub></mrow><annotation encoding='application/x-tex'>V_s</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Par construction on doit 
obtenir un polynôme divisible par le produit des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math>&gt;: en effet
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&minus;</mo><mi>Q</mi></mrow><annotation encoding='application/x-tex'>P&#x2d;Q</annotation></semantics></math> est divisible par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math> donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&minus;</mo><msub><mi>V</mi> <mi>s</mi></msub></mrow><annotation encoding='application/x-tex'>P&#x2d;V_s</annotation></semantics></math> aussi donc par symétrie
il est divisible par le produit des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math>. C’est le polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi></mrow><annotation encoding='application/x-tex'>q</annotation></semantics></math> ci-dessous, auquel on applique récursivement l’algorithme
(le degré a été dimuné de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>).

</p><pre class="verbatim">restart;
sym(P,X):={ // P polynome symetrique, X liste des variables
  local k,s,xs,Q,V,W,S,q,r;
  s:=size(X);
  si s&lt;=1 alors return P; fsi;
  xs:=X[s-1];
  si !contains(lname(P),xs) alors return P; fsi; // polynome constant
  Q:=normal(subst(P,xs=0)); // Q est symetrique en X[0..s-2]
  V:=sym(Q,X[0..s-2]); // appel recursif
  S:=pcoeff(X[0..s-1]); // polynomes symetriques en les X
  pour k de 0 jusque size(S)-1 faire S[k]:=(-1)^k*S[k]; fpour;
  q,r:=quorem((P-subst(V,X[0..s-2],S[1..s-1])),S[s],xs); // reste nul
  si r!=0 alors throw("non symetrique"); fsi;
  W:=sym(q,X);
  retourne V+W*xs;
}:;
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>


Par exemple
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">p:=sym(x^3+y^3+z^3,[x,y,z]) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

exprime <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><msup><mi>y</mi> <mn>3</mn></msup><mo>+</mo><msup><mi>z</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>x^3+y^3+z^3</annotation></semantics></math> en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo>,</mo><mi>x</mi><mi>y</mi><mo>+</mo><mi>x</mi><mi>z</mi><mo>+</mo><mi>y</mi><mi>z</mi><mo>,</mo><mi>x</mi><mi>y</mi><mi>z</mi></mrow><annotation encoding='application/x-tex'>x+y+z,xy+xz+yz,xyz</annotation></semantics></math>,
on vérifie 
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">normal(subst(p,[x,y,z],[x+y+z,x*y+x*z+y*z,x*y*z])) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

</p>
<!--TOC section id="sec178" Exercices (factorisation des polynômes)-->
<h2 id="sec178" class="section">18.9  Exercices (factorisation des polynômes)</h2><!--SEC END --><ol class="enumerate" type=1><li class="li-enumerate">
Soit le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>&minus;</mo><mn>5</mn><msup><mi>x</mi> <mn>3</mn></msup><mo>&minus;</mo><mn>5</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>6</mn><mi>x</mi><mo>+</mo><mn>6</mn></mrow><annotation encoding='application/x-tex'>P(x)=x^{5}+x^{4}&#x2d;5x^{3}&#x2d;5x^{2}+6x+6</annotation></semantics></math>.
On veut déterminer des intervalles d’isolation des racines réelles
positives de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.
<ol class="enumerate" type=a><li class="li-enumerate"> 
Implémenter la règle de Descartes sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]0,+\infty[</annotation></semantics></math>
(nombre de racines <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&leq;</mo></mrow><annotation encoding='application/x-tex'>\leq</annotation></semantics></math> au nombre de changements de signe des
coefficients).
</li><li class="li-enumerate">Pour faire de même sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]0,1[</annotation></semantics></math>, on fait d’abord
le changement de variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&rightarrow;</mo><mn>1</mn><mo stretchy="false">/</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x\rightarrow 1/x</annotation></semantics></math> 
(<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>P</mi><mo stretchy="false">&tilde;</mo></mover><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>5</mn></msup><mi>P</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\tilde{P}(x)=x^5P(1/x)</annotation></semantics></math>) qui permet
de se ramener à des racines dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>1</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]1,+\infty[</annotation></semantics></math> puis 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&rightarrow;</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x \rightarrow x+1</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mover><mi>P</mi><mo stretchy="false">&tilde;</mo></mover><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\tilde{P}(x)=P(x+1)</annotation></semantics></math>) sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">+</mo><mn>&infin;</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]0,+\infty[</annotation></semantics></math>.
</li><li class="li-enumerate">Déterminer une majoration <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> des racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> en module.
</li><li class="li-enumerate">Déterminer le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> tel que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>M</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>Q(x)=P(Mx)</annotation></semantics></math>. 
Les racines positives de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> correspondent
à des racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]0,1[</annotation></semantics></math> pour lesquelles on peut
appliquer la règle de Descartes adaptée.
</li><li class="li-enumerate">S’il y a 2 changements de signe ou plus de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]0,1[</annotation></semantics></math>,
rechercher les racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]0,1/2[</annotation></semantics></math> en se ramenant
aux racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]0,1[</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Q</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>R(x)=Q(x/2)</annotation></semantics></math>
puis les racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">]</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>]1/2,1[</annotation></semantics></math> en posant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Q</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>S(x)=Q((x+1)/2)</annotation></semantics></math>.
</li><li class="li-enumerate">Discuter la complexité des changements de variables
qui apparaissent dans cette méthode, en particulier en utilisant
une représentation des polynômes par une liste de coefficients.
</li></ol>
</li><li class="li-enumerate">Déterminer le nombre de racines de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msup><mi>x</mi> <mn>7</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mn>12</mn><mi>x</mi><mo>&minus;</mo><mn>5</mn></mrow><annotation encoding='application/x-tex'>&#x2d;x^7+x^4+12x&#x2d;5</annotation></semantics></math> comprises
entre 0 et 6 (en utilisant les suites de Sturm, on donnera les
détails des calculs). Déterminer le nombre de racines réelles
de ce polynôme en utilisant une majoration du module des racines.
</li><li class="li-enumerate">Écrire un programme calculant la suite de Sturm d’un polynôme
supposé squarefree (on peut tester avec <code>sqrfree</code>), en utilisant
l’algorithme d’Euclide, on renverra <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>&prime;</mo></mrow><annotation encoding='application/x-tex'>P&apos;</annotation></semantics></math> et la liste des quotients.
Écrire un programme calculant le nombre de changements de signe
de la suite de Sturm en un réel (indication : utiliser 
l’algorithme de Horner pour évaluer, 
et <code>remove</code> pour éliminer les 0 d’une liste)
</li><li class="li-enumerate">Prendre un polynôme de degré 100 à coefficients
aléatoires (<code>randpoly</code>), le factoriser numériquement
(<code>proot</code>) puis donner pour les premières racines
approchées renvoyées des intervalles ou disques où
on peut certifier qu’il existe une racine.
</li><li class="li-enumerate">Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P(x)=x^5+3x+1</annotation></semantics></math>. Déterminer des valeurs approchées
des racines complexes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. En déduire des boules dans le
plan complexe contenant exactement une racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et
de rayon plus petit que <code>1e-12</code>. En utilisant la méthode
de Newton avec du calcul exact, déterminer des valeurs approchées
certifiées à <code>1e-40</code> près des racines complexes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.
</li><li class="li-enumerate">Localiser les parties réelles et imaginaires des racines
complexes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>z</mi> <mn>5</mn></msup><mo>+</mo><mn>3</mn><mi>z</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P(z)=z^5+3z+1</annotation></semantics></math> en utilisant les suites de Sturm
et le résultant de la partie réelle et imaginaire de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P(x+iy)</annotation></semantics></math>. Comparer cette méthode avec celle de l’exercice
précédent (en particulier que se passe-t-il pour un polynôme
de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>).
</li><li class="li-enumerate">Calculer avec un logiciel les valeurs numériques des racines
complexes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P(x)=x^5+x+1</annotation></semantics></math>. Trouver les combinaisons de racines
dont la somme est entière (aux arrondis près). En déduire la factorisation
en facteurs irréductibles sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>.
</li><li class="li-enumerate">Factorisation numérique sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Copf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{C}</annotation></semantics></math>. Écrire un programme
qui calcule une racine d’un polynôme à coefficients complexes
en utilisant une méthode itérative de type méthode de Newton 
(avec éventuellement un préfacteur lorsqu’on débute la recherche).
Les polynômes seront représentés par la liste de leurs coefficients
et l’évaluation faite par la méthode de Horner.
Trouver ensuite toutes les racines du polynôme en éliminant la
racine trouvée (toujours avec Horner). Trouver les combinaisons
de racines correspondant à un facteur à coefficients entiers.
</li><li class="li-enumerate">Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> un entier premier et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> un polynôme à
coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>. On a la relation
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mtext>gcd</mtext><mo stretchy="false">(</mo><msup><mi>X</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mo>&minus;</mo><mi>X</mi><mo>,</mo><mi>P</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>f</mi><mo stretchy="false">&vert;</mo><mi>P</mi><mo>,</mo><mtext>\small deg</mtext><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mi>k</mi></mrow></munder><mi>f</mi><mo>,</mo><mspace width="1em"/><mi>f</mi><mtext> irréductible</mtext></mrow><annotation encoding='application/x-tex'> \mbox{gcd}(X^{p^k}&#x2d;X,P) = \prod_{ f | P, \mbox{\small deg}(f) | k} f, 
\quad f \mbox{ irréductible}  </annotation></semantics></math>
En utilisant cette relation, 
déterminer les degrés des facteurs de 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> (x^3+x+1)(x^4+x+1)  </annotation></semantics></math>
modulo 5 et 7 (sans utiliser la commande factor). 
Peut-on en déduire que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^3+x+1</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^4+x+1</annotation></semantics></math> sont irréductibles sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>?
</li><li class="li-enumerate">Utiliser les options “verbose” de votre logiciel de calcul formel
pour factoriser <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>202</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>101</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^{202}+x^{101}+1</annotation></semantics></math> et vérifiez que vous avez compris
la méthode utilisée.
</li><li class="li-enumerate">Trouver les facteurs de degré 1 s’ils existent de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>3</mn><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><mn>25</mn><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><mn>67</mn><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>77</mn><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mn>55</mn><mi>x</mi><mo>+</mo><mn>13</mn></mrow><annotation encoding='application/x-tex'>3x^5+25x^4+67x^3+77x^2+55x+13</annotation></semantics></math> en remontant ses racines
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>Z</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/pZ[X]</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> premier bien choisi.
</li><li class="li-enumerate">Factoriser le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>5</mn></msup><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^5+x+1</annotation></semantics></math> par la méthode 
de Berlekamp.
</li><li class="li-enumerate">Montrer que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>x</mi><mo>+</mo><msup><mi>x</mi> <mn>2</mn></msup><mi>y</mi><mo>+</mo><msup><mi>x</mi> <mn>3</mn></msup><mo>+</mo><mn>2</mn><msup><mi>x</mi> <mn>4</mn></msup><mo>+</mo><msup><mi>y</mi> <mn>3</mn></msup><mo>+</mo><msup><mi>x</mi> <mn>5</mn></msup></mrow><annotation encoding='application/x-tex'>2x+x^2y+x^3+2x^4+y^3+x^5</annotation></semantics></math> est irréductible sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}</annotation></semantics></math>
sans utiliser l’instruction factor à 2 variables (on pourra factoriser 
pour quelques valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> ou de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi></mrow><annotation encoding='application/x-tex'>y</annotation></semantics></math>)</li><li class="li-enumerate">Que se passe-t-il lorsqu’on exécute l’algorithme de Yun
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>n</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/n\mathbb{Z}</annotation></semantics></math>?</li><li class="li-enumerate">Recherche des facteurs de degré 2 d’un polynôme à coefficients
réels sans racines réelles en utilisant la méthode de Bairstow décrite
ci-dessous.<br>
On cherche un facteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>+</mo><mi>s</mi><mi>x</mi><mo>+</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>F=x^2+sx+p</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>, on calcule le quotient et le reste
de la division <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo>=</mo><mi>F</mi><mi>Q</mi><mo>+</mo><mi>R</mi></mrow><annotation encoding='application/x-tex'>P=FQ+R</annotation></semantics></math> par une méthode de type Horner, il s’agit de 
rendre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> (vu comme un vecteur à 2 composantes) nul. On calcule
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo>&PartialD;</mo> <mrow><mi>s</mi><mo>,</mo><mi>p</mi></mrow></msub><mi>R</mi></mrow><annotation encoding='application/x-tex'>\partial_{s,p} R</annotation></semantics></math> (en cherchant le quotient et le reste
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>Q</mi></mrow><annotation encoding='application/x-tex'>xQ</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>Q</mi></mrow><annotation encoding='application/x-tex'>Q</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>F</mi></mrow><annotation encoding='application/x-tex'>F</annotation></semantics></math>, pourquoi?) et on pose :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>p</mi><msub><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>p</mi><msub><mo stretchy="false">)</mo> <mi>n</mi></msub><mo>&minus;</mo><mi>&lambda;</mi><mo stretchy="false">(</mo><msub><mo>&PartialD;</mo> <mrow><mi>s</mi><mo>,</mo><mi>p</mi></mrow></msub><mi>R</mi><msup><mo stretchy="false">)</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow></msup><mi>R</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>p</mi><msub><mo stretchy="false">)</mo> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>(s,p)_{n+1}=(s,p)_n&#x2d; \lambda (\partial_{s,p} R)^{&#x2d;1} R (s,p)_n </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lambda;</mi></mrow><annotation encoding='application/x-tex'>\lambda</annotation></semantics></math> est un préfacteur compris entre 0 et 1 et ajusté à 1 
lorsqu’on est proche du facteur.</li></ol>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note32" href="#text32">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Rappelons qu’il s’agit d’une
majoration sur la valeur absolue des coefficients des facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math></div></dd><dt class="dt-thefootnotes"><a id="note33" href="#text33">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Plus exactement, on multiplie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>P_j</annotation></semantics></math> par le
coefficient dominant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>l</mi></msup></mrow><annotation encoding='application/x-tex'>p^l</annotation></semantics></math></div></dd><dt class="dt-thefootnotes"><a id="note34" href="#text34">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Ici <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>P</mi><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|P|</annotation></semantics></math> désigne le plus grand
coefficient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> en valeur absolue</div></dd></dl>
<!--END NOTES-->
<!--TOC chapter id="sec179" Intégration formelle.-->
</html>
