<!DOCTYPE html>
<html >
<head>
<h1 id="sec137" class="chapter">Chapitre 16  Corps finis.</h1><!--SEC END --><p> <a id="sec:gf"></a><a id="hevea_default164"></a><a id="hevea_default165"></a>
</p>
<!--TOC section id="sec138" Rappels-->
<h2 id="sec138" class="section">16.1  Rappels</h2><!--SEC END --><p>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> un corps fini. Le plus petit entier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> tel que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mn>.1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>p.1=0</annotation></semantics></math> est la caractéristique du corps, c’est un nombre premier
(car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mi>y</mi><mo>=</mo><mn>0</mn><mo>&Rightarrow;</mo><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>xy=0 \Rightarrow x=0</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>y=0</annotation></semantics></math>), et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> est un <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>
espace vectoriel de dimension finie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, donc son cardinal est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>p^n</annotation></semantics></math>.</p><p>Les inversibles pour la multiplication forment un groupe de cardinal
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^n&#x2d;1</annotation></semantics></math> et ce groupe est cyclique (sinon on construit un élément
d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> le PPCM des ordres des éléments de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>K</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>K^*</annotation></semantics></math>, cet ordre
est donc un diviseur strict de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^n&#x2d;1</annotation></semantics></math>, mais c’est impossible car
le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mi>d</mi></msup><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x^d&#x2d;x</annotation></semantics></math> a alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn><mi>&gt;</mi><mi>d</mi></mrow><annotation encoding='application/x-tex'>p^n&#x2d;1&amp;gt;d</annotation></semantics></math> racines).</p><p>L’application <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03D5;</mi><mo>:</mo><mi>x</mi><mo>&rightarrow;</mo><msup><mi>x</mi> <mi>p</mi></msup></mrow><annotation encoding='application/x-tex'>\phi:x \rightarrow x^p</annotation></semantics></math> est une application linéaire
et le noyau de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03D5;</mi></mrow><annotation encoding='application/x-tex'>\phi</annotation></semantics></math>-id est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>. Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est un polynôme 
irréductible à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> de degré divisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, alors
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> se décompose en produit de facteurs de degré 1 et on passe
d’une racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> à une autre en appliquant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&#x03D5;</mi></mrow><annotation encoding='application/x-tex'>\phi</annotation></semantics></math>
(en effet <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><msup><mi>p</mi> <mi>n</mi></msup></mrow></msup><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x^{p^n}&#x2d;x</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><msup><mi>p</mi> <mi>n</mi></msup></mrow></msup><mo>&minus;</mo><mi>x</mi><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>&alpha;</mi><mo>&Element;</mo><mi>K</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x^{p^n}&#x2d;x=\prod_{\alpha \in K} (x&#x2d;\alpha)</annotation></semantics></math>).
Exemple : faire <code>GF(3,5)</code> pour créer le corps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math>
de cardinal <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>3</mn> <mn>5</mn></msup></mrow><annotation encoding='application/x-tex'>3^5</annotation></semantics></math>, puis 
<code>P:=randpoly(5) % 3; factor(P)</code>
et exécuter à niveau la commande jusqu’à ce que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> soit
irréductible, puis tester <code>factor(P,g)</code>.
Evidemment, ce résultat n’est plus vrai si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> a des coefficients
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> au lieu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math> (essayer avec <code>P:=randpoly(5,g)</code>).</p>
<!--TOC section id="sec139" Représentation des corps non premiers.-->
<h2 id="sec139" class="section">16.2  Représentation des corps non premiers.</h2><!--SEC END -->
<!--TOC subsection id="sec140" Cas général.-->
<h3 id="sec140" class="subsection">16.2.1  Cas général.</h3><!--SEC END --><p>
Pour représenter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math>, on utilise généralement la
représentation dite additive, c’est-à-dire que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math>
est isomorphe à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo stretchy="false">/</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X]/P(X)</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> un polynôme
irréductible de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}[X]</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. Si la classe de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math>
est d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^n&#x2d;1</annotation></semantics></math> dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>K</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>K^*</annotation></semantics></math> on dit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> est <span style="font-weight:bold">primitif</span><a id="hevea_default166"></a>.
Dans Xcas, c’est cette représentation qui est utilisée,
l’instruction <code>GF(p,n)</code> génère aléatoirement
un polynôme irréductible de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>,
puis cherche un élément cyclique, calcule son polynôme
minimal (qui est donc primitif), et affiche le nom d’un
générateur (par défaut <code>g</code>), 
il suffit alors d’écrire n’importe quelle
expression symbolique polynomiale en ce générateur
pour créer un élément de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math>. En interne, Xcas stocke
les éléments de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> comme des polynômes-listes
à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>, et les affiche comme polynôme
symbolique en fonction du générateur. On peut aussi
utiliser un entier entre 0 et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^n&#x2d;1</annotation></semantics></math> dont l’écriture en base
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> représente les coefficients du polynôme.</p><p>Pour générer un polynôme <span style="font-weight:bold">irréductible</span><a id="hevea_default167"></a>, on utilise
un génerateur aléatoire d’entiers dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>p</mi><mo stretchy="false">[</mo></mrow><annotation encoding='application/x-tex'>[0,p[</annotation></semantics></math>,
on crée un polynôme unitaire de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, et
on teste son irréductibilité en calculant le PGCD
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> avec les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x^{p^k}&#x2d;x</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> de 1 jusque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n/2</annotation></semantics></math>.
En pratique, on calcule les <code>powmod(x,p^k,p,P)</code>
(en prenant la puissance modulaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>-ième
du précédent), on retire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> et on calcule le pgcd avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>,
si on trouve un résultat différent de 1, on passe au polynôme
suivant (généré aléatoirement).
On peut calculer la probabilité de réussir en dénombrant
les polynômes irréductibles de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> à l’aide
de la formule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><msup><mi>p</mi> <mi>n</mi></msup></mrow></msup><mo>&minus;</mo><mi>x</mi><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>P</mi><mtext> irréductible unitaire </mtext><mo stretchy="false">/</mo><mtext>deg</mtext><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo><mtext> divise </mtext><mi>n</mi></mrow></msub><mi>P</mi></mrow><annotation encoding='application/x-tex'>x^{p^n}&#x2d;x=\prod_{P \mbox{ irréductible unitaire }/ \mbox{deg}(P)\mbox{ divise } n} P</annotation></semantics></math>.</p><p>Trouver un élément <span style="font-weight:bold">cyclique</span><a id="hevea_default168"></a> se fait aussi au hasard
(<code>rand(g)</code> en Xcas si <code>g</code> est le générateur
d’un corps fini), la
probabilité se calcule à l’aide de l’indicatrice d’Euler de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^n&#x2d;1</annotation></semantics></math>. Déterminer le polynome minimal d’un élément
est alors un problème d’algèbre linéaire, il se résoud
en calculant le noyau de la matrice dont les colonnes sont
les coefficients des puissances de l’élément (instruction
<code>pmin</code> en Xcas).</p><p>La représentation additive est pratique pour additionner
ou soustraire des éléments de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math>, multiplier
nécessite de faire une division euclidienne par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> et prendre
le reste, inverser nécessite de faire une identité de Bézout
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math>. Il existe une représentation alternative, dite
multiplicative, on représente alors un élément <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>g</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>g^k</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>K</mi> <mo>*</mo></msup></mrow><annotation encoding='application/x-tex'>K^*</annotation></semantics></math>
par la puissance <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mi>p</mi> <mo>&minus;</mo></msup><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>k \in [0,p^&#x2d;2]</annotation></semantics></math> du générateur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>, et on
représente <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mn>0</mn> <mi>K</mi></msub></mrow><annotation encoding='application/x-tex'>0_K</annotation></semantics></math> par -1 ou par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^n&#x2d;1</annotation></semantics></math>. Mais l’addition
est alors difficile sauf si on dispose d’une table passant
de la représentation additive à la représentation
multiplicative.</p>
<!--TOC subsection id="sec141" Corps de petit cardinal, cas de la caractéristique 2-->
<h3 id="sec141" class="subsection">16.2.2  Corps de petit cardinal, cas de la caractéristique 2</h3><!--SEC END --><p>
Si le cardinal du corps n’est pas trop grand (par exemple
moins que quelques milliers), il est intéressant de construire
une table de passage entre représentation additive et
multiplicative, c’est-à-dire une permutation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,p^n&#x2d;1]</annotation></semantics></math>
si on utilise des entiers pour la représentation additive.
On calcule donc une fois pour toutes la représentation additive
de toutes les puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> ce qui fournit la table de passage
multiplicatif vers additif, puis la permutation inverse, on peut alors
effectuer toutes les opérations sur le corps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> très
rapidement : la multiplication devient un test si l’un
des éléments vaut <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^n&#x2d;1</annotation></semantics></math> suivi d’une addition modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>p^n&#x2d;1</annotation></semantics></math> si
ce n’est pas le cas, l’addition une écriture en base <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
additions dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>.</p><p>En caractéristique 2, l’addition est encore plus simple, il s’agit
d’un ou exclusif bit à bit (sur un type entier court 8 ou 16 ou 32 bits). 
De plus le calcul de la permutation
de passage est très rapide, pour trouver <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>g</mi> <mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>g^{k+1}</annotation></semantics></math> en fonction
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>g</mi> <mi>k</mi></msup></mrow><annotation encoding='application/x-tex'>g^k</annotation></semantics></math> il faut multiplier par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> ce qui est un décalage
de bit vers la gauche, tester si l’entier est supérieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>2^n</annotation></semantics></math>
et si oui faire un ou exclusif avec l’entier représentant le
polynôme minimal de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>. Si le cardinal du corps est assez petit
(par exemple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>8</mn></msup></mrow><annotation encoding='application/x-tex'>2^8</annotation></semantics></math>, ou disons moins que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>13</mn></msup></mrow><annotation encoding='application/x-tex'>2^{13}</annotation></semantics></math>),
la permutation et son inverse tiennent dans le cache du
microprocesseur et les opérations sur le corps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> se font
en une dizaine de cycles du microprocesseur.</p>
<!--TOC section id="sec142" Exercices-->
<h2 id="sec142" class="section">16.3  Exercices</h2><!--SEC END --><p>
Dans Xcas, pour travailler dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mi>p</mi><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/p\mathbb{Z}</annotation></semantics></math>, on utilise l’opérateur <code>%</code>.
Attention à bien laisser un espace avant ou/et après <code>%</code> si vous 
utilisez des noms de variables. Par exemple <code>p:=7; 3 % p</code> représente
la classe de 3 dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>7</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/7\mathbb{Z}</annotation></semantics></math>.
Pour travailler dans un corps fini non premier de caractéristique <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>
et de cardinal <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>p</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>p^n</annotation></semantics></math>,
on crée le corps avec la commande <code>GF(p,n)</code> ou une variante.
Les variantes permettent de préciser le nom de variable pour 
générer les éléments du corps comme polynômes en cette variable, 
ou pour préciser le polynôme minimal ou pour indiquer si on ne souhaite
pas que le polynôme minimal soit primitif (i.e. que les puissances
de la variable engendre le corps moins 0). Par exemple
</p><ul class="itemize"><li class="li-itemize">
<code>GF(2,8,r)</code> utilisera <code>r</code> comme variable
</li><li class="li-itemize"><code>GF(2,128,0)</code> utilisera un polynôme minimal pas forcément 
primitif
</li><li class="li-itemize"><code>GF(2,128,r,0)</code> combine les deux
</li><li class="li-itemize"><code>GF(2,w^8+w^7+w^5+w+1)</code> utilise <code>w</code> comme variable
et le polynôme minimal <code>w^8+w^7+w^5+w+1</code> qui n’est pas forcément
primitif.
</li></ul><p>Exercices :
</p><ol class="enumerate" type=1><li class="li-enumerate">
Construire un corps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> à 81 éléments avec la commande <code>GF</code>.
Chercher un polynôme irréductible de degré 4 sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="0em" rspace="thinmathspace">Z</mo><mo stretchy="false">/</mo><mn>3</mn><mo lspace="0em" rspace="thinmathspace">Z</mo></mrow><annotation encoding='application/x-tex'>\Z/3\Z</annotation></semantics></math>,
puis le factoriser sur le corps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math>.
</li><li class="li-enumerate">Trouver un polynôme irréductible <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré 5 sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>7</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/7\mathbb{Z}</annotation></semantics></math>.
En déduire une représentation de <code>GF(7,5)</code>. Factoriser 
le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> sur votre représentation de <code>GF(7,5)</code> (on pourra utiliser
l’application <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>&rightarrow;</mo><msup><mi>x</mi> <mn>7</mn></msup></mrow><annotation encoding='application/x-tex'>x \rightarrow x^7</annotation></semantics></math>).
</li><li class="li-enumerate">Déterminer le polynôme minimal de quelques éléments
de <code>GF(7,5)</code> en utilisant votre représentation ou celle de Xcas.
Même question mais en degré 4 avec la représentation de Xcas.
</li><li class="li-enumerate">Factoriser avec Xcas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mn>16</mn></msup><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x^{16}&#x2d;x</annotation></semantics></math> modulo 2 (on pourra utiliser
<code>factors()</code>, <code>% 2</code> et <code>% 0</code>). 
En déduire les polynômes irréductibles de degré 4 sur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>2</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/2\mathbb{Z}</annotation></semantics></math>, déterminez les polynômes irréductibles
primitif de degré 4, pour l’un d’entre eux construire une table 
entre représentation
multiplicative et additive de <code>GF(2,4)</code>.
</li><li class="li-enumerate">Écrire une fonction permettant de déterminer si un
polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est irréductible modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>, en utilisant le
PGCD avec les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><msup><mi>p</mi> <mi>k</mi></msup></mrow></msup><mo>&minus;</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>x^{p^k}&#x2d;x</annotation></semantics></math> modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math>. 
Quelle est sa complexité si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> est irréductible de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi></mrow><annotation encoding='application/x-tex'>d</annotation></semantics></math> ?
</li><li class="li-enumerate">Créer une matrice carrée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> d’ordre 3 à coefficients
dans un corps de cardinal 25, déterminer son polynome
minimal et son ordre. Quels sont les ordres possibles ?
</li></ol>
<!--TOC section id="sec143" Rappels de quelques complexités de base-->
<h2 id="sec143" class="section">16.4  Rappels de quelques complexités de base</h2><!--SEC END --><p>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> désigne un majorant commun de la taille des arguments, ou bien
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>n_1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>n</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>n_2</annotation></semantics></math> désignent la taille des 2 arguments.</p>
<!--TOC subsection id="sec144" Polynomes denses et entiers-->
<h3 id="sec144" class="subsection">16.4.1  Polynomes denses et entiers</h3><!--SEC END --><p>
Pour un polynôme en une variable
à coefficients dans un corps fini, la taille est
le degré du polynôme, on prend comme convention que
la somme et le produit des coefficients se fait en temps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(1)</annotation></semantics></math>.</p><p>Pour un entier, la taille est le nombre de chiffres dans l’écriture
dans une base quelconque, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est donc un majorant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>log</mi> <mi>b</mi></msub><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\log_b(N)</annotation></semantics></math>.
</p><ul class="itemize"><li class="li-itemize">
Addition, soustraction : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n)</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo></mrow><annotation encoding='application/x-tex'>O(</annotation></semantics></math>max<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>n</mi> <mn>1</mn></msub><mo>,</mo><msub><mi>n</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(n_1,n_2))</annotation></semantics></math>
</li><li class="li-itemize">Multiplication naïve : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^2)</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mi>n</mi> <mn>1</mn></msub><msub><mi>n</mi> <mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n_1n_2)</annotation></semantics></math>
</li><li class="li-itemize">Division naïve : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^2)</annotation></semantics></math> ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mi>n</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>n</mi> <mn>1</mn></msub><mo>&minus;</mo><msub><mi>n</mi> <mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n_2(n_1&#x2d;n_2))</annotation></semantics></math>.
</li><li class="li-itemize">Multiplication rapide : Karatsuba <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mrow><mi>log</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>log</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^{\log(3)/\log(2)})</annotation></semantics></math>, ..., FFT
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>ln</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n\ln(n))</annotation></semantics></math> pour des polynômes
</li><li class="li-itemize">PGCD, Bézout : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^2)</annotation></semantics></math>
</li><li class="li-itemize">calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mi>N</mi></msup><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mi>p</mi><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'>a^N \pmod p</annotation></semantics></math> ou cout d’un test de Miller-Rabin : 
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(\ln(N))</annotation></semantics></math> étapes, donc en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>p</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(\ln(N)\ln(p)^2)</annotation></semantics></math>
</li></ul><p><span style="font-weight:bold">Remarques</span>
</p><ul class="itemize"><li class="li-itemize">
Attention, le cout est plus important si les coefficients sont entiers
ou rationnels. 
</li><li class="li-itemize">Si on tient compte du cout des opérations sur le corps fini
de cardinal <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math>. Il faut multiplier les couts par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(\ln(c))</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">+</mo><mo>,</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo></mrow><annotation encoding='application/x-tex'>+,&#x2d;</annotation></semantics></math>
et par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>ln</mi><mo stretchy="false">(</mo><mi>c</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(\ln(c)^2)</annotation></semantics></math> pour les autres opérations.
</li><li class="li-itemize">Pour des polynômes creux, les couts sont
estimés en fonction du nombre de coefficients non nuls.
</li></ul>
<!--TOC subsection id="sec145" Algèbre linéaire dense-->
<h3 id="sec145" class="subsection">16.4.2  Algèbre linéaire dense</h3><!--SEC END --><p>
Pour une matrice carrée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>n,n</annotation></semantics></math> à coefficients dans un corps fini où
les opérations se font en temps <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(1)</annotation></semantics></math>.
</p><ul class="itemize"><li class="li-itemize">
Addition, soustraction, multiplication par un scalaire,
multiplication par un vecteur : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^2)</annotation></semantics></math>
</li><li class="li-itemize">Multiplication de 2 matrices, pivot de Gauss
(décomposition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi><mi>U</mi></mrow><annotation encoding='application/x-tex'>LU</annotation></semantics></math>, inverse, déterminant...) : <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^3)</annotation></semantics></math>
</li><li class="li-itemize">Multiplication rapide par blocs (Strassen) en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi> <mrow><mi>log</mi><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>log</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>O(n^{\log(7)/\log(2)})</annotation></semantics></math>,
que l’on peut généraliser au pivot de Gauss
</li></ul><p><span style="font-weight:bold">Remarques</span>
</p><ul class="itemize"><li class="li-itemize">
Attention, le cout est plus important si les coefficients sont entiers
ou rationnels.
</li><li class="li-itemize">Pour des matrices creuses, les couts sont estimés en fonction du nombre
de coefficients non nuls.
</li></ul>
<!--TOC section id="sec146" Codes linéaires et polynomiaux.-->
<h2 id="sec146" class="section">16.5  Codes linéaires et polynomiaux.</h2><!--SEC END --><p>
<a id="hevea_default169"></a> <a id="hevea_default170"></a>
<a id="hevea_default171"></a>
Les corps finis premiers servent dans tous les algorithmes modulaires,
on en a vu par exemple l’intérêt pour le PGCD, la factorisation...</p><p>Les corps finis premiers et non premiers servent aussi dans le
domaine de la cryptographie et des codes correcteurs d’erreurs, 
on présente ici ce dernier point.</p><p>Références : Demazure, G. Zémor, wikipedia (pour les codes de
Hamming binaires).</p><p>On appellera symbole d’information l’unité de base transmise, qu’on
supposera appartenir à un corps fini <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math>, par
exemple pour un bit un élément de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi><mo>=</mo><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>2</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>K=\mathbb{Z}/2\mathbb{Z}</annotation></semantics></math>, ou pour un octet 
un élément du corps à 256 éléments <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi><mo>=</mo><msub><mi>F</mi> <mn>256</mn></msub><mo>=</mo><msub><mi>F</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>K=F_{256}=F_d</annotation></semantics></math>.</p><p>On veut coder un message de longueur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> avec des possibilités
de détection et de correction d’erreurs, pour cela on rajoute
des symboles calculés à partir des précédents, 
on envoie un élément d’un code ayant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> symboles.</p>
<!--TOC subsection id="sec147" Le bit de parité.-->
<h3 id="sec147" class="subsection">16.5.1  Le bit de parité.</h3><!--SEC END --><p><a id="hevea_default172"></a>
On prend <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>7</mn></mrow><annotation encoding='application/x-tex'>k=7</annotation></semantics></math> bits et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding='application/x-tex'>n=8</annotation></semantics></math> bits. On compte
le nombre de 1 parmi les 7 bits envoyés, si ce nombre est pair, 
on envoie 0 comme 8ième bit, sinon 1. 
Au final le nombre de bits à 1 de l’octet (1 octet=8 bits)
est pair. On peut ainsi détecter une erreur de transmission si
à la réception le nombre de bits d’un octet est impair, mais on
ne peut pas corriger d’erreurs.
On peut aussi dire que l’octet
représente un polynôme à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>2</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/2\mathbb{Z}</annotation></semantics></math> divisible
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>X+1</annotation></semantics></math>.</p><p><span style="font-weight:bold">Exercice</span> :
Écrire un programme Xcas permettant de rajouter un bit de parité
à une liste composée de 7 bits. Puis un programme de vérification
qui accepte ou non un octet selon sa parité. Vous représenterez
l’octet par une liste de bits, avec le délimiteur <code>poly1[</code>
pour pouvoir effectuer des opérations arithmétiques polynomiales,
et vous effectuerez la vérification de deux manières, en comptant
le nombre de 1 ou avec l’instruction <code>rem</code>.</p>
<!--TOC subsection id="sec148" Codes linéaires-->
<h3 id="sec148" class="subsection">16.5.2  Codes linéaires</h3><!--SEC END --><p>
<a id="hevea_default173"></a><a id="hevea_default174"></a>
<span style="font-weight:bold">Définition</span> :
On multiplie le vecteur des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> symboles par
une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi></mrow><annotation encoding='application/x-tex'>K</annotation></semantics></math> de taille <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&times;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>n \times k</annotation></semantics></math>
et on transmet l’image.
Pour assurer qu’on peut identifier un antécédent
unique à partir d’une image, il faut que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> corresponde 
à une application linéaire injective, ce qui entraine <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&geq;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>n\geq k</annotation></semantics></math>. 
On dit qu’un vecteur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> symboles est un mot du code 
s’il est dans l’image de l’application linéaire.</p><p>Pour assurer l’injectivité tout en facilitant le décodage, 
on utilise souvent une matrice identité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>k,k</annotation></semantics></math> comme sous-bloc
de la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>n,k</annotation></semantics></math>, par exemple on prend l’identité pour
les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> premières lignes de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>, on ajoute ensuite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>n&#x2d;k</annotation></semantics></math> lignes.</p><p>Pour savoir si un vecteur est un mot de code, il faut vérifier
qu’il est dans l’image de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>. On peut par exemple vérifier
qu’en ajoutant la colonne de ses coordonnées à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math>, on ne change
pas le rang de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> (qui doit être <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>) mais c’est assez couteux.
On préfère utiliser une matrice de controle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi></mrow><annotation encoding='application/x-tex'>H</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>x</mi><mo>&Element;</mo><mtext>Im</mtext><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>&Leftrightarrow;</mo><mi>H</mi><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>x \in \mbox{Im}(M) \Leftrightarrow Hx=0 </annotation></semantics></math>
Si la matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> est composée de l’identité <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>I</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>I_{k}</annotation></semantics></math>
et d’une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> sur ses <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>n&#x2d;k</annotation></semantics></math> dernières lignes, 
alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>C</mi><mo>,</mo><msub><mi>I</mi> <mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>H=(&#x2d;C,I_{n&#x2d;k})</annotation></semantics></math>.</p><p><span style="font-weight:bold">Exercice</span> : créez une matrice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi></mrow><annotation encoding='application/x-tex'>M</annotation></semantics></math> de taille 7,4 injective. Puis
un programme qui teste si un vecteur est un mot de code et en
extrait alors la partie avant codage. Vérifiez votre programme
avec un vecteur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>M</mi><mi>v</mi></mrow><annotation encoding='application/x-tex'>Mv</annotation></semantics></math>, on doit obtenir un mot de code.<br>
Instructions utiles : <code>idn</code> (matrice identité)
<code>ker</code> (noyau d’une application linéaire), <code>rank</code> (rang),
<code>tran</code> (tranposée), ... Pour créer une matrice, on peut coller
les lignes de 2 matrices <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>A</mi></mrow><annotation encoding='application/x-tex'>A</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>B</mi></mrow><annotation encoding='application/x-tex'>B</annotation></semantics></math> par <code>[op(A),op(B)]</code> ou avec
<code>blockmatrix</code>.</p>
<!--TOC subsection id="sec149" Codes polynomiaux-->
<h3 id="sec149" class="subsection">16.5.3  Codes polynomiaux</h3><!--SEC END --><p>
<a id="hevea_default175"></a><a id="hevea_default176"></a>
<span style="font-weight:bold">Définition</span> :
Il s’agit d’un cas particulier de codes linéaires.
On se donne un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>g(x)</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>n&#x2d;k</annotation></semantics></math>,
On représente le message de longueur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> à coder par un polynôme 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k&#x2d;1</annotation></semantics></math>.
On multiplie <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>x^{n&#x2d;k}</annotation></semantics></math>, on calcule le reste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math> de la division
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><msup><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>P x^{n&#x2d;k}</annotation></semantics></math> par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>. On émet alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><msup><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow></msup><mo>&minus;</mo><mi>R</mi></mrow><annotation encoding='application/x-tex'>P x^{n&#x2d;k}&#x2d;R</annotation></semantics></math> qui est divisible
par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>. Les mots de code sont les polynômes divisibles par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>.</p><p><span style="font-weight:bold">Exercice</span> : écrire de cette façon le codage du bit de parité. Puis
une procédure Xcas de codage utilisant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo>=</mo><msup><mi>X</mi> <mn>7</mn></msup><mo>+</mo><msup><mi>X</mi> <mn>3</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>g=X^7+X^3+1</annotation></semantics></math> 
(ce polynôme était utilisé par le Minitel).
N.B. on obtient le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>X</mi> <mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>X^{n&#x2d;k}</annotation></semantics></math> sous forme
de polynome-liste dans Xcas par <span style="font-family:monospace">poly1[1,0&#36;(n-k)]</span>.</p>
<!--TOC subsection id="sec150" Détection et correction d’erreur-->
<h3 id="sec150" class="subsection">16.5.4  Détection et correction d’erreur</h3><!--SEC END --><p>
<a id="hevea_default177"></a> <a id="hevea_default178"></a>
Si le mot recu n’est pas dans l’image de l’application
linéaire il y a eu erreur de transmission. Sinon, il n’y
a pas eu d’erreur <em>détectable</em> (il pourrait y avoir eu plusieurs
erreurs qui se “compensent”).</p><p>Plutôt que de demander la réémission du mot mal transmis
(ce qui serait par exemple impossible en temps réel 
depuis un robot en orbite autour de Mars),
on essaie d’ajouter suffisamment d’information pour 
pouvoir corriger des erreurs en supposant
que leur nombre est majoré par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math>. 
Si les erreurs de
transmissions sont indépendantes, la probabilité d’avoir
au moins <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>N+1</annotation></semantics></math> erreurs dans un message de longueur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>L</mi></mrow><annotation encoding='application/x-tex'>L</annotation></semantics></math>
est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mi>N</mi><mo>+</mo><mn>1</mn></mrow> <mi>L</mi></msubsup><mrow><mo>(</mo><msup><mo/><mi>L</mi></msup><msub><mo/><mi>k</mi></msub><mo>)</mo></mrow><msup><mi>&epsi;</mi> <mi>k</mi></msup><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><mi>&epsi;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>L</mi><mo>&minus;</mo><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>\sum_{k=N+1}^L \left( ^L_{k} \right) \epsilon^{k} (1&#x2d;\epsilon)^{L&#x2d;k}</annotation></semantics></math>, 
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>\epsilon</annotation></semantics></math> est la probabilité d’une erreur
de transmission, c’est aussi <code>1-binomial_cdf(L,epsilon,N)</code>. 
Par exemple, pour un message de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>10</mn> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>10^3</annotation></semantics></math> caractères,
chacun ayant une probabilité d’erreur de transmission de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>10</mn> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>3</mn></mrow></msup></mrow><annotation encoding='application/x-tex'>10^{&#x2d;3}</annotation></semantics></math>,
si on prend <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>N=3</annotation></semantics></math>, alors la probabilité d’avoir au moins 4 erreurs
est de 0.019 (arrondi par excès) :<br>
<code>P(N,eps,L):=sum(comb(L,k)*eps^k*(1-eps)^(L-k),k,N+1,L):;</code><br>
<code>P(3,1e-3,10^3)</code><br>
ou directement <code>1-binomial_cdf(1000,1e-3,3)</code>.</p><p><span style="font-weight:bold">Exemple</span> : On ne peut pas corriger d’erreur avec le bit de parité.</p>
<!--TOC subsection id="sec151" Distances-->
<h3 id="sec151" class="subsection">16.5.5  Distances</h3><!--SEC END --><p> <a id="hevea_default179"></a>
La <span style="font-weight:bold">distance de Hamming</span><a id="hevea_default180"></a> 
de 2 mots est le nombre de symboles qui diffèrent.
(il s’agit bien d’une distance au sens mathématique, 
elle vérifie l’inégalité triangulaire). </p><p>Exercice : écrire une procédure de calcul de la distance de Hamming
de 2 mots. En Xcas, la fonction s’appelle <span style="font-family:monospace">hamdist</span>.</p><p>La distance d’un code est la distance de Hamming minimale
de 2 mots différents du code.
Pour un code linéaire, la distance est aussi le nombre minimal
de coefficients non nuls d’un vecteur non nul de l’image.
Pour un code polynomial, la distance du code
est le nombre minimal de coefficients non nuls d’un multiple
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> de degré inférieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>.</p><p>Exercice : quelle est la distance du code linéaire que
vous avez créé plus haut ?</p><p><span style="font-weight:bold">Majoration de la distance du code:</span><br>
<a id="hevea_default181"></a>
La distance minimale d’un code linéaire est inférieure ou 
égale à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;k+1</annotation></semantics></math> : en effet on écrit en ligne les coordonnées
des images de la base canonique (ce qui revient à transposer la
matrice) et on réduit par le pivot de Gauss,
comme l’application linéaire est injective, le rang de la matrice
est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, donc la réduction de Gauss crée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k&#x2d;1</annotation></semantics></math>
zéros dans chaque ligne, donc le nombre de coefficients non nuls
de ces <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> lignes (qui sont toujours des mots de code) est 
au plus de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;k+1</annotation></semantics></math>.</p><p>Exercice : si votre code linéaire n’est pas de distance 3, modifiez
les 3 dernières lignes pour réaliser un code de distance 3. On
ne peut pas obtenir une distance <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;k+1=4</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>7</mn></mrow><annotation encoding='application/x-tex'>n=7</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>k=4</annotation></semantics></math> 
dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>2</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/2\mathbb{Z}</annotation></semantics></math>, essayez! Essayez sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>3</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/3\mathbb{Z}</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>5</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/5\mathbb{Z}</annotation></semantics></math>.</p><p>N.B. : Pour les codes non
polynomiaux, par exemple convolutifs, la distance n’est pas
forcément le
paramètre le mieux adapté à la correction d’erreurs.</p>
<!--TOC subsection id="sec152" Correction au mot le plus proche-->
<h3 id="sec152" class="subsection">16.5.6  Correction au mot le plus proche</h3><!--SEC END --><p>
Une stratégie de correction basée sur la distance consiste à
trouver le mot de code le plus proche d’un mot donné.
Si la distance d’un code est supérieure ou égale
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2t+1</annotation></semantics></math>, et s’il existe un mot de code de distance inférieure
à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> au mot donné, alors ce mot de code est unique.
On corrige alors le mot transmis en le remplaçant par le mot de code
le plus proche.</p><p>Exercice : écrivez un programme permettant de corriger une erreur
dans un mot dans votre code linéaire.</p><p>On dit qu’un code <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>-correcteur est 
<span style="font-weight:bold">parfait</span><a id="hevea_default182"></a> si la réunion des boules
de centre un mot de code et de rayon <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> (pour la distance de Hamming)
est disjointe et recouvre l’ensemble des mots (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>K</mi> <mi>n</mi></msup></mrow><annotation encoding='application/x-tex'>K^n</annotation></semantics></math>).</p><p>Exercice : votre code linéaire sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>2</mn><mi>&Zopf;</mi></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/2\mathbb{Z}</annotation></semantics></math> (celui de distance 3) 
est-il un code 1-correcteur parfait ?</p>
<!--TOC subsection id="sec153" Codes de Hamming-->
<h3 id="sec153" class="subsection">16.5.7  Codes de Hamming</h3><!--SEC END --><p>
Soit un code de longueur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, de dimension <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>, le nombre
d’informations supplémentaires est noté <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><mi>n</mi><mo>&minus;</mo><mi>k</mi></mrow><annotation encoding='application/x-tex'>m=n&#x2d;k</annotation></semantics></math>. Un code
de Hamming<a id="hevea_default183"></a><a id="hevea_default184"></a> 
permet une correction, donc la distance du code
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&delta;</mi></mrow><annotation encoding='application/x-tex'>\delta</annotation></semantics></math> est (au moins) 3. Si le code est parfait sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>K</mi><mo>=</mo><msub><mi>F</mi> <mi>d</mi></msub></mrow><annotation encoding='application/x-tex'>K=F_d</annotation></semantics></math>, on a 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><msup><mi>d</mi> <mi>k</mi></msup><mo>=</mo><msup><mi>d</mi> <mi>n</mi></msup><mo>&Rightarrow;</mo><mi>n</mi><mo>=</mo><mfrac><mrow><msup><mi>d</mi> <mi>m</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><mi>d</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding='application/x-tex'>(1+n(d&#x2d;1))d^k=d^{n} \Rightarrow n=\frac{d^m&#x2d;1}{d&#x2d;1} </annotation></semantics></math></p><p>Par exemple si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>d=2</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding='application/x-tex'>m=4</annotation></semantics></math> alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>15</mn></mrow><annotation encoding='application/x-tex'>n=15</annotation></semantics></math>. 
Il n’y a qu’une matrice de controle possible de taille
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>15</mn><mo>,</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(15,4)</annotation></semantics></math> telle que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>Hx</annotation></semantics></math> donne la position de l’erreur (en base 2),
elle est obtenue en écrivant les entiers de 1 à 15 en base 2
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>H</mi><mo>=</mo><mrow><mo>(</mo><mtable displaystyle="false" rowspacing="0.5ex" columnalign="center center center center center center center center center center center center center center center"><mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>1</mn></mtd></mtr> <mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd> <mtd><mn>1</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>H=\left( \begin{array}{ccccccccccccccc}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1
 \end{array} \right) </annotation></semantics></math>
on déplace les colonnes de la matrice identité 
(colonnes 1, 2, 4, 8)
en fin pour écrire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mo>=</mo><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mi>C</mi><mo>,</mo><msub><mi>I</mi> <mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>H=(&#x2d;C,I_4)</annotation></semantics></math>, le code correspondant est
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mrow><mo>(</mo><msup><mo/><mrow><msub><mi>I</mi> <mn>11</mn></msub></mrow></msup><msub><mo/><mi>C</mi></msub><mo>)</mo></mrow></mrow><annotation encoding='application/x-tex'>\left( ^{I_{11}} _C \right)</annotation></semantics></math>, il permet de corriger une erreur,
on calcule <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>Hx</annotation></semantics></math> et si le résultat est non nul, on change le
bit d’indice <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>H</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>Hx</annotation></semantics></math> en tenant compte du déplacement des colonnes
1, 2, 4 et 8. En fait, il est plus simple de ne pas faire ce
déplacement de colonnes.</p><p>Code systématique : 
</p><ol class="enumerate" type=1><li class="li-enumerate">
On repère les indices de bit en commençant
à 1
</li><li class="li-enumerate">On écrit les indices de bit en base 2
</li><li class="li-enumerate">Les bits dont les indices sont des puissance de 2
sont des bits de parité
</li><li class="li-enumerate">Les autres bits sont des bits de donnée
</li><li class="li-enumerate">Les bits de parité sont calculés pour avoir parité
paire selon les bits d’indice respectifs 1 mod 2 pour le bit de
parité p1, selon les bits d’indice divisé par 2 valant 1 mod 2 pour le bit de parité p2, etc.
</li><li class="li-enumerate">Pour corriger une erreur, on corrige le bit dont la position
écrite en base 2 a des 1 là où la parité est fausse.
</li></ol><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >Indice</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >3</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >4</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >5</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >6</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >7</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >9</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >10</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >11</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >12</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >13</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >14</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >15 </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >p1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >p2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >p4</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >p8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >x </td></tr>
<tr><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >p1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >p2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >p4</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d3</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d4</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >p8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d5</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d6</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d7</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d8</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d9</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d10</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >d11 </td></tr>
</table><p>Autre exemple : le minitel utilisait <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo>=</mo><mn>2</mn><mo>,</mo><mi>m</mi><mo>=</mo><mn>7</mn><mo>,</mo><mi>n</mi><mo>=</mo><msup><mn>2</mn> <mi>m</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>d=2, m=7, n=2^m&#x2d;1</annotation></semantics></math>.</p>
<!--TOC section id="sec154" Les codes de Reed-Solomon-->
<h2 id="sec154" class="section">16.6  Les codes de Reed-Solomon</h2><!--SEC END --><p><a id="hevea_default185"></a>
Il s’agit de codes polynomiaux qui réalisent la distance maximale
possible <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;k+1</annotation></semantics></math>. De plus la recherche du mot de code le plus
proche peut se faire par un algorithme de Bézout avec arrêt 
prématuré.</p>
<!--TOC subsection id="sec155" Théorie-->
<h3 id="sec155" class="subsection">16.6.1  Théorie</h3><!--SEC END --><p>
On se donne un générateur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> 
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>F</mi> <mi>q</mi> <mo>*</mo></msubsup></mrow><annotation encoding='application/x-tex'>F_q^*</annotation></semantics></math> et le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msup><mi>a</mi> <mrow><mn>2</mn><mi>t</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>g(x)=(x&#x2d;a)...(x&#x2d;a^{2t})</annotation></semantics></math> (donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mi>k</mi><mo>=</mo><mn>2</mn><mi>t</mi></mrow><annotation encoding='application/x-tex'>n&#x2d;k=2t</annotation></semantics></math>). 
Typiquement <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>q</mi><mo>=</mo><msup><mn>2</mn> <mi>m</mi></msup></mrow><annotation encoding='application/x-tex'>q=2^m</annotation></semantics></math> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding='application/x-tex'>m=8</annotation></semantics></math>, 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> est une racine d’un polynôme irréductible
de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math> à coefficients dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&Zopf;</mi><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>\mathbb{Z}/2</annotation></semantics></math> 
qui ne divise pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mi>l</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x^l&#x2d;1</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> diviseur
strict de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mi>m</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2^m&#x2d;1</annotation></semantics></math> (pour en construire,
cf. le chapitre corps finis <a href="#sec%3Agf">16</a>).</p><p><span style="font-weight:bold">Distance du code</span><br>
Si la longueur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> d’un mot vérifie
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&leq;</mo><msup><mn>2</mn> <mi>m</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n \leq 2^m&#x2d;1</annotation></semantics></math>, alors la distance entre 2 mots du code est au moins
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2t+1</annotation></semantics></math>.
En effet, si un polynome <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><mi>n</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;n</annotation></semantics></math> est un multiple de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math>
ayant moins de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2t+1</annotation></semantics></math> coefficients non nuls,
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mn>2</mn><mi>t</mi></mrow></munderover><msub><mi>p</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msub><msup><mi>x</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo>,</mo><mspace width="1em"/><msub><mi>i</mi> <mi>k</mi></msub><mi>&lt;</mi><mi>n</mi></mrow><annotation encoding='application/x-tex'> P(x)=\sum_{k=1}^{2t} p_{i_k} x^{i_k}, \quad i_k&amp;lt;n  </annotation></semantics></math>
en écrivant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><mn>2</mn><mi>t</mi></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P(a)=...=P(a^{2t})=0</annotation></semantics></math>, on obtient
un déterminant de Van der Monde, on prouve qu’il est non nul en
utilisant la condition <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>i</mi> <mi>k</mi></msub><mi>&lt;</mi><mi>n</mi></mrow><annotation encoding='application/x-tex'>i_k&amp;lt;n</annotation></semantics></math> et le fait que la première puissance
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>a</mi></mrow><annotation encoding='application/x-tex'>a</annotation></semantics></math> telle que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>a</mi> <mi>x</mi></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>a^x=1</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><msup><mn>2</mn> <mi>m</mi></msup><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>x=2^m&#x2d;1</annotation></semantics></math>.</p><p><span style="font-weight:bold">Correction des erreurs</span><br>
Soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>c(x)</annotation></semantics></math> le polynome envoyé, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>d(x)</annotation></semantics></math>
le polynôme recu, on suppose qu’il y a moins de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> erreurs
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>&nu;</mi></munderover><msub><mi>&alpha;</mi> <mi>k</mi></msub><msup><mi>x</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo>,</mo><mspace width="1em"/><mi>&nu;</mi><mo>&leq;</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>d(x)&#x2d;c(x)=e(x)= \sum_{k=1}^\nu \alpha_k x^{i_k}, \quad \nu \leq t </annotation></semantics></math>
On calcule le polynome syndrome :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mi>d</mi><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><msup><mi>x</mi> <mi>i</mi></msup><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mi>e</mi><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">)</mo><msup><mi>x</mi> <mi>i</mi></msup></mrow><annotation encoding='application/x-tex'> s(x)= \sum_{i=0}^{2t&#x2d;1}d(a^{i+1}) x^i= \sum_{i=0}^{2t&#x2d;1}e(a^{i+1}) x^i  </annotation></semantics></math>
on a donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>&nu;</mi></munderover><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><msup><mi>x</mi> <mi>i</mi></msup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>&nu;</mi></munderover><msub><mi>&alpha;</mi> <mi>k</mi></msub><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><msup><mo stretchy="false">)</mo> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><msup><mi>x</mi> <mi>i</mi></msup></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>&nu;</mi></munderover><msub><mi>&alpha;</mi> <mi>k</mi></msub><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mfrac><mrow><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mn>2</mn><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn></mrow><mrow><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mi>x</mi><mo>&minus;</mo><mn>1</mn></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} 
s(x) &amp;= &amp;\sum_{i=0}^{2t&#x2d;1}\sum_{k=1}^\nu \alpha_k (a^{i+1})^{i_k} x^i \\
&amp;=&amp; \sum_{k=1}^\nu \alpha_k \sum_{i=0}^{2t&#x2d;1}(a^{i+1})^{i_k} x^i\\
&amp;=&amp; \sum_{k=1}^\nu \alpha_k a^{i_k} \frac{(a^{i_k}x)^{2t}&#x2d;1}{a^{i_k}x&#x2d;1}
 \end{matrix} </annotation></semantics></math>
On pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>l(x)</annotation></semantics></math> le produit des dénominateurs (que l’on appelle polynôme
localisateur, car ses racines permettent de trouver la position
des symboles à corriger), on a alors
<a id="eqref_16"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>&nu;</mi></munderover><msub><mi>&alpha;</mi> <mi>k</mi></msub><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo stretchy="false">(</mo><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mn>2</mn><mi>t</mi></mrow></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi><mo>,</mo><mi>j</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>&nu;</mi><mo stretchy="false">]</mo></mrow></munder><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>j</mi></msub></mrow></msup><mi>x</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>16</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
 l(x) s(x) = \sum_{k=1}^\nu \alpha_k a^{i_k} ( (a^{i_k}x)^{2t} &#x2d;1 )
\prod_{j\neq k, j \in [1,\nu]} (a^{i_j}x &#x2d;1) 
\qquad (16) </annotation></semantics></math>
Modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>x^{2t}</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>l(x)s(x)</annotation></semantics></math> est donc un polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi></mrow><annotation encoding='application/x-tex'>w</annotation></semantics></math> de degré inférieur
ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&nu;</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\nu &#x2d;1</annotation></semantics></math>, donc strictement inférieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>.
Pour le calculer, on applique l’algorithme de Bézout à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>s(x)</annotation></semantics></math>
et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>x^{2t}</annotation></semantics></math> (dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>F</mi> <mi>q</mi></msub></mrow><annotation encoding='application/x-tex'>F_q</annotation></semantics></math>), en s’arrêtant au premier reste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>w(x)</annotation></semantics></math>
dont le degré est strictement inférieur à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> (au lieu
d’aller jusqu’au calcul du PGCD de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>s(x)</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>x^{2t}</annotation></semantics></math>).
Les relations sur les degrés (cf. approximants de Padé et
la preuve ci-dessous) donnent
alors en coefficient de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>s(x)</annotation></semantics></math> le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>l(x)</annotation></semantics></math> de degré inférieur ou
égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math>. On en calcule les racines (en testant tous les éléments
du corps avec Horner), donc la place des symboles erronés.</p><p>Pour calculer les valeurs <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>\alpha_k</annotation></semantics></math>, on reprend la définition de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi></mrow><annotation encoding='application/x-tex'>w</annotation></semantics></math>,
c’est le terme de droite de l’équation (<a href="#eqref_16">16</a>) modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>x^{2t}</annotation></semantics></math>,
donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>&nu;</mi></munderover><msub><mi>&alpha;</mi> <mi>k</mi></msub><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo stretchy="false">(</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi><mo>,</mo><mi>j</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>&nu;</mi><mo stretchy="false">]</mo></mrow></munder><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>j</mi></msub></mrow></msup><mi>x</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> w(x)=\sum_{k=1}^\nu \alpha_k a^{i_k} (&#x2d;1)
\prod_{j\neq k, j \in [1,\nu]} (a^{i_j}x&#x2d;1)  </annotation></semantics></math>
Donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>&alpha;</mi> <mi>k</mi></msub><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi><mo>,</mo><mi>j</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>&nu;</mi><mo stretchy="false">]</mo></mrow></munder><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>j</mi></msub></mrow></msup><msup><mi>a</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> w(a^{&#x2d;i_k}) = &#x2d; \alpha_k a^{i_k}  
\prod_{j\neq k, j \in [1,\nu]} (a^{i_j} a^{&#x2d;i_k} &#x2d;1)  </annotation></semantics></math>
Comme :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mi>x</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi><mo>,</mo><mi>j</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>&nu;</mi><mo stretchy="false">]</mo></mrow></munder><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>j</mi></msub></mrow></msup><mi>x</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> l(x)=(a^{i_k}x&#x2d;1)\prod_{j\neq k, j \in [1,\nu]} (a^{i_j}x&#x2d;1)  </annotation></semantics></math>
on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>l</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><munder><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi><mo>,</mo><mi>j</mi><mo>&Element;</mo><mo stretchy="false">[</mo><mn>1</mn><mo>,</mo><mi>&nu;</mi><mo stretchy="false">]</mo></mrow></munder><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><msub><mi>i</mi> <mi>j</mi></msub></mrow></msup><msup><mi>a</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> l&apos;(a^{&#x2d;i_k})=a^{i_k}\prod_{j\neq k, j \in [1,\nu]} (a^{i_j}a^{&#x2d;i_k}&#x2d;1)  </annotation></semantics></math>
Finalement :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&alpha;</mi> <mi>k</mi></msub><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mfrac><mrow><mi>w</mi><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo stretchy="false">)</mo></mrow><mrow><mi>l</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msup><mi>a</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><msub><mi>i</mi> <mi>k</mi></msub></mrow></msup><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'> \alpha_k = &#x2d;\frac{w(a^{&#x2d;i_k})}{l&apos;(a^{&#x2d;i_k})}  </annotation></semantics></math></p>
<!--TOC subsection id="sec156" Preuve du calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math>-->
<h3 id="sec156" class="subsection">16.6.2  Preuve du calcul de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math></h3><!--SEC END --><p>
On avait <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>s(x)</annotation></semantics></math> avec deg<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mo>=</mo><mn>2</mn><mi>t</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>(s)&amp;lt;=2t&#x2d;1</annotation></semantics></math>,
il s’agissait de voir comment la solution <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>r</mi></mrow><annotation encoding='application/x-tex'>u,v,r</annotation></semantics></math> calculee par Bezout
<a id="eqref_17"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>u</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi></mrow></msup><mo>+</mo><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>17</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>   
 u(x)  x^{2t}+ v(x) s(x) = r(x) 
\qquad (17) </annotation></semantics></math>
avec arrêt prématuré au 1er reste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>r(x)</annotation></semantics></math> de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><mo>=</mo><mi>t</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>&amp;lt;=t&#x2d;1</annotation></semantics></math> 
correspondait à l’équation
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>m</mi><mi>o</mi><mi>d</mi><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>   l(x) s(x) = w(x) mod x^{2t}  </annotation></semantics></math>
avec deg<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mo>=</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>(l)&amp;lt;=t</annotation></semantics></math> et deg<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mo>=</mo><mi>t</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>(w)&amp;lt;=t&#x2d;1</annotation></semantics></math></p><p>On a vu que deg<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mo>=</mo><mi>t</mi></mrow><annotation encoding='application/x-tex'>(v)&amp;lt;=t</annotation></semantics></math>.
On commence par factoriser la puissance de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> de degré maximal <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> dans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v(x)</annotation></semantics></math>, et on simplifie (<a href="#eqref_17">17</a>) par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mi>p</mi></msup></mrow><annotation encoding='application/x-tex'>x^p</annotation></semantics></math>. 
Quitte à changer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math>, on se
ramene donc à:
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>u</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow></msup><mo>+</mo><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>   u(x)  x^{2t&#x2d;p}+ v(x) s(x) = r(x)  </annotation></semantics></math>
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v(x)</annotation></semantics></math> premier avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>, deg<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mo>=</mo><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>(v)&amp;lt;= t&#x2d;p</annotation></semantics></math> et deg<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mo>=</mo><mi>t</mi><mo>&minus;</mo><mn>1</mn><mo>&minus;</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>(r)&amp;lt;= t&#x2d;1&#x2d;p</annotation></semantics></math>.
On simplifie ensuite par le pgcd de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v(x)</annotation></semantics></math> et de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>r(x)</annotation></semantics></math>
(qui divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>u(x)</annotation></semantics></math> car premier avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> puisqu’on a déjà traité les
puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>).
On a donc, quitte à changer de notation <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>u</mi><mo>,</mo><mi>v</mi><mo>,</mo><mi>r</mi></mrow><annotation encoding='application/x-tex'>u,v,r</annotation></semantics></math> tels que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>u</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow></msup><mo>+</mo><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>  u(x)  x^{2t&#x2d;p}+ v(x) s(x) = r(x)  </annotation></semantics></math>
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> premiers entre eux, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> premier avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>,
deg<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mo>=</mo><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>(v)&amp;lt;=t&#x2d;p</annotation></semantics></math> et deg<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mi>&lt;</mi><mo>=</mo><mi>t</mi><mo>&minus;</mo><mn>1</mn><mo>&minus;</mo><mi>p</mi></mrow><annotation encoding='application/x-tex'>(r)&amp;lt;=t&#x2d;1&#x2d;p</annotation></semantics></math> (N.B.: <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>p=0</annotation></semantics></math> en general)</p><p>On observe que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>l(x)</annotation></semantics></math> est premier avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn></mrow><annotation encoding='application/x-tex'>0</annotation></semantics></math> n’est pas racine de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math>).
On raisonne modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>x^{2t&#x2d;p}</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> sont inversibles modulo <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>x^{2t&#x2d;p}</annotation></semantics></math>,
donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>*</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow><mo>,</mo><mspace width="1em"/><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>*</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> s(x) = w(x)*inv(l) \pmod{ x^{2t&#x2d;p}},
\quad s(x) = r(x)*inv(v) \pmod {x^{2t&#x2d;p}}  </annotation></semantics></math>
donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>*</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>*</mo><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow><mspace width="1em"/><mo>&Rightarrow;</mo><mspace width="1em"/><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>*</mo><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>*</mo><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mrow><mo lspace="mediummathspace">(</mo><mo rspace="thinmathspace">mod</mo><mrow><msup><mi>x</mi> <mrow><mn>2</mn><mi>t</mi><mo>&minus;</mo><mi>p</mi></mrow></msup></mrow><mo rspace="mediummathspace">)</mo></mrow></mrow><annotation encoding='application/x-tex'> w(x)*inv(l)=r(x)*inv(v) \pmod{x^{2t&#x2d;p}} 
\quad \Rightarrow \quad w(x)*v(x)=r(x)*l(x) \pmod {x^{2t&#x2d;p}}  </annotation></semantics></math>
donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>*</mo><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>*</mo><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>w(x)*v(x)=r(x)*l(x)</annotation></semantics></math> à cause des majorations de degres</p><p>D’autre part par construction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>w(x)</annotation></semantics></math> est premier avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>l(x)</annotation></semantics></math> (car chacun
des facteurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>l(x)</annotation></semantics></math> divise tous les éléments de la somme définissant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>w(x)</annotation></semantics></math> sauf un), donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>l(x)</annotation></semantics></math> divise <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v(x)</annotation></semantics></math>, et comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v(x)</annotation></semantics></math> est premier
avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>r(x)</annotation></semantics></math>, on en déduit que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mi>l</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v(x)=C l(x)</annotation></semantics></math> où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> est une constante non
nulle, puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>r(x) = C w(x)</annotation></semantics></math>.</p><p>Bezout donne donc (après simplifications du couple <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>v(x), r(x)</annotation></semantics></math> par
son pgcd) le polynome localisateur à une constante près (donc les
racines et les positions des erreurs), et on peut calculer
les valeurs des erreurs avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>v</mi></mrow><annotation encoding='application/x-tex'>v</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>r</mi></mrow><annotation encoding='application/x-tex'>r</annotation></semantics></math> car la constante <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>C</mi></mrow><annotation encoding='application/x-tex'>C</annotation></semantics></math> se simplifie.</p>
<!--TOC subsection id="sec157" Avec Xcas-->
<h3 id="sec157" class="subsection">16.6.3  Avec Xcas</h3><!--SEC END --><p>
Ouvrir la session <code>Aide-&gt;Exemples-&gt;crypto-&gt;reed_s</code></p>
<!--TOC chapter id="sec158" Factorisation des entiers et primalité.-->
</html>
