<!DOCTYPE html>
<html >
<head>
<h1 id="sec193" class="chapter">Chapitre 20  Intégration numérique</h1><!--SEC END --><p> <a id="sec:intnum"></a><a id="hevea_default220"></a> <a id="hevea_default221"></a>
Les fractions rationnelles admettent une primitive que l’on calcule
en décomposant la fraction avec Bézout comme expliqué précédemment.
Mais elles font figure d’exceptions,
la plupart des fonctions n’admettent pas de primitives qui s’expriment
à l’aide des fonctions usuelles. Pour calculer une intégrale, on
revient donc à la définition d’aire sous la courbe, aire que
l’on approche, en utilisant par exemple un polynome de Lagrange.</p><p>Le principe est donc le suivant : on découpe l’intervalle d’intégration
en subdivisions <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo>+</mo><mi>h</mi><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">[</mo><mi>a</mi><mo>+</mo><mi>h</mi><mo>,</mo><mi>a</mi><mo>+</mo><mn>2</mn><mi>h</mi><mo stretchy="false">]</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">[</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mi>h</mi><mo>,</mo><mi>a</mi><mo>+</mo><mi>n</mi><mi>h</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding='application/x-tex'>[a,b]=[a,a+h] + [a+h,a+2h]+...[a+(n&#x2d;1)h,a+nh=b</annotation></semantics></math>, où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>h=(b&#x2d;a)/n</annotation></semantics></math> est le pas de la subdivision, et
sur chaque subdivision, on approche l’aire sous la courbe.</p>
<!--TOC section id="sec194" Les rectangles et les trapèzes-->
<h2 id="sec194" class="section">20.1  Les rectangles et les trapèzes</h2><!--SEC END --><p>
Sur une subdivision <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\alpha,\beta]</annotation></semantics></math>, on approche la fonction par un segment.
Pour les rectangles, il s’agit d’une horizontale : on peut prendre 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(\alpha)</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(\beta)</annotation></semantics></math> (rectangle à droite et gauche)
ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f((\alpha+\beta)/2)</annotation></semantics></math> (point milieu), pour les trapèzes on utilise
le segment reliant <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\alpha,f(\alpha)]</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&beta;</mi><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\beta,f(\beta)]</annotation></semantics></math>.</p><p>Exemple : calcul de la valeur approchée de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><msup><mi>t</mi> <mn>3</mn></msup><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int_0^1 t^3 dt</annotation></semantics></math>
(on en connait la valeur exacte <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>1</mn><mo stretchy="false">/</mo><mn>4</mn><mo>=</mo><mn>0.25</mn></mrow><annotation encoding='application/x-tex'>1/4=0.25</annotation></semantics></math>) par ces méthodes en subdivisant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,1]</annotation></semantics></math> en 10 subdivisions (pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>h=1/10</annotation></semantics></math>), donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>=</mo><mi>j</mi><mo stretchy="false">/</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>\alpha=j/10</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi><mo>=</mo><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>\beta=(j+1)/10</annotation></semantics></math>
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math> variant de 0 à 9.
Pour les rectangles à gauche, on obtient sur une subdivision
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">/</mo><mn>10</mn><msup><mo stretchy="false">)</mo> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>f(\alpha)=(j/10)^3 </annotation></semantics></math> que l’on multiplie par la longueur de la subdivision 
soit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mn>10</mn></mrow><annotation encoding='application/x-tex'>h=1/10</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mn>10</mn></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mn>9</mn></munderover><mo stretchy="false">(</mo><mfrac><mi>j</mi><mn>10</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>3</mn></msup><mo>=</mo><mfrac><mn>81</mn><mn>400</mn></mfrac><mo>=</mo><mn>0.2025</mn></mrow><annotation encoding='application/x-tex'> \frac{1}{10} \sum_{j=0}^9 (\frac{j}{10})^3  = \frac{81}{400} = 0.2025 </annotation></semantics></math>
Pour les rectangles à droite, on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mn>10</mn></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mn>10</mn></munderover><mo stretchy="false">(</mo><mfrac><mi>j</mi><mn>10</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>3</mn></msup><mo>=</mo><mfrac><mn>121</mn><mn>400</mn></mfrac><mo>=</mo><mn>0.3025</mn></mrow><annotation encoding='application/x-tex'> \frac{1}{10} \sum_{j=1}^{10} (\frac{j}{10})^3  = \frac{121}{400} = 0.3025 </annotation></semantics></math>
Pour le point milieu <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">/</mo><mn>10</mn><mo>+</mo><mo stretchy="false">(</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>10</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">/</mo><mn>10</mn><mo>+</mo><mn>1</mn><mo stretchy="false">/</mo><mn>20</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f((\alpha+\beta)/2)=f((j/10+(j+1)/10)/2)=f(j/10+1/20)</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mn>10</mn></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mn>9</mn></munderover><mo stretchy="false">(</mo><mfrac><mi>j</mi><mn>10</mn></mfrac><mo>+</mo><mfrac><mn>1</mn><mn>20</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>3</mn></msup><mo>=</mo><mn>199</mn><mo stretchy="false">/</mo><mn>800</mn><mo>=</mo><mn>0.24875</mn></mrow><annotation encoding='application/x-tex'> \frac{1}{10} \sum_{j=0}^9 (\frac{j}{10}+\frac{1}{20})^3  = 199/800 = 0.24875 </annotation></semantics></math>
Enfin pour les trapèzes, l’aire du trapèze délimité par l’axe des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math>,
les verticales <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>y=\alpha</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>y</mi><mo>=</mo><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>y=\beta</annotation></semantics></math> et les points sur ces verticales
d’ordonnées respectives <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(\alpha)</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(\beta)</annotation></semantics></math> vaut
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>h</mi><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> h \frac{f(\alpha)+f(\beta)}{2} </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mn>10</mn></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mn>9</mn></munderover><mrow><mo>(</mo><mo stretchy="false">(</mo><mfrac><mi>j</mi><mn>10</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>3</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><mn>10</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>3</mn></msup><mo>)</mo></mrow><mo>=</mo><mfrac><mn>101</mn><mn>400</mn></mfrac><mo>=</mo><mn>0.2525</mn></mrow><annotation encoding='application/x-tex'> \frac{1}{10} \sum_{j=0}^9 \left( (\frac{j}{10})^3 +(\frac{j+1}{10})^3
\right) = 
\frac{101}{400} = 0.2525  </annotation></semantics></math>
Dans la somme des trapèzes, on voit que chaque terme apparait deux fois
sauf le premier et le dernier.</p><p>Plus généralement, les formules sont donc les suivantes :
<a id="hevea_default222"></a> <a id="hevea_default223"></a> <a id="hevea_default224"></a>
<a id="eqref_31"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mtext>rectangle gauche</mtext></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>h</mi><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>j</mi><mi>h</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mtext>rectangle droit</mtext></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>h</mi><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>j</mi><mi>h</mi><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mtext>point milieu</mtext></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>h</mi><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>j</mi><mi>h</mi><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mtext> trapezes </mtext></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>h</mi><mrow><mo>(</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>j</mi><mi>h</mi><mo stretchy="false">)</mo><mo>)</mo></mrow></mtd></mtr></mtable></mrow><mspace width="2em"/><mo stretchy="false">(</mo><mn>31</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \begin{matrix}
\mbox{rectangle gauche} &amp; = &amp; h \sum_{j=0}^{n&#x2d;1} f(a+jh) \\
\mbox{rectangle droit} &amp; = &amp; h \sum_{j=1}^{n} f(a+jh) \\
\mbox{point milieu} &amp; = &amp; h \sum_{j=0}^{n&#x2d;1} f(a+jh+\frac{h}{2}) 
\\
\mbox{ trapezes } &amp; = &amp; 
h \left(\frac{f(a)+f(b)}{2}+\sum_{j=1}^{n&#x2d;1} f(a+jh) \right) 

\end{matrix} \qquad (31) </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>h=(b&#x2d;a)/n</annotation></semantics></math> est le pas de la subdivision, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> le nombre de subdivisions.<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">f(x):=ln(1+x^2); a:=0; b:=1.0; n:=100.0; h:=(b-a)/n;int(f(x),x,a,b) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">h*sum(f(a+j*h),j,0,n-1); h*sum(f(a+j*h),j,1,n); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">h*sum(f(a+h/2+j*h),j,0,n-1); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">h*(f(a)/2+f(b)/2+sum(f(a+j*h),j,1,n-1)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

On observe sur l’exemple que le point milieu et les trapèzes donnent
une bien meilleure précision que les rectangles. Plus généralement,
la précision de l’approximation n’est pas la même selon le choix
de méthode.
Ainsi pour les rectangles à gauche (le résultat est le même
à droite), si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est continument dérivable, de dérivée majorée
par une constante <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>M_1</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math>, en faisant un
développement de Taylor de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>, on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mi>t</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>M</mi> <mn>1</mn></msub><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mo>=</mo><msub><mi>M</mi> <mn>1</mn></msub><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'> |\int_{\alpha}^{\beta} f(t) dt &#x2d; \int_{\alpha}^{\beta} f(\alpha) dt |
= | \int_{\alpha}^{\beta} f&apos;(\theta_t)(t&#x2d;\alpha) dt |
\leq M_1 \int_{\alpha}^{\beta} (t&#x2d;\alpha) dt = M_1\frac{(\beta&#x2d;\alpha)^2}{2}
 </annotation></semantics></math>
Ainsi dans l’exemple, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>1</mn></msub><mo>=</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>M_1=3</annotation></semantics></math>, l’erreur est donc majorée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0.015</mn></mrow><annotation encoding='application/x-tex'>0.015</annotation></semantics></math>
sur une subdivision, donc par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0.15</mn></mrow><annotation encoding='application/x-tex'>0.15</annotation></semantics></math> sur les 10 subdivisions.</p><p>Pour le point milieu, on fait le développement en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>(\alpha+\beta)/2</annotation></semantics></math> à l’ordre
2, en supposant que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est deux fois continument dérivable :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd/> <mtd><mo lspace="verythinmathspace" rspace="0em">+</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mfrac><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mi>t</mi></msub><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo stretchy="false">&vert;</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>&leq;</mo></mtd> <mtd><mfrac><mrow><msub><mi>M</mi> <mn>2</mn></msub></mrow><mn>2</mn></mfrac><mn>2</mn><msubsup><mo>&Integral;</mo> <mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac> <mi>&beta;</mi></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mi>d</mi><mi>t</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>&leq;</mo></mtd> <mtd><msub><mi>M</mi> <mn>2</mn></msub><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mn>3</mn></msup></mrow><mn>24</mn></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 |\int_{\alpha}^{\beta} f(t)  &#x2d; \int_{\alpha}^{\beta} f(\frac{\alpha+\beta}{2})  |
&amp;= &amp;| \int_{\alpha}^{\beta} f&apos;(\frac{\alpha+\beta}{2})(t&#x2d;\frac{\alpha+\beta}{2}) dt
\\
&amp; &amp;
+  \int_{\alpha}^{\beta} \frac{f&apos;{&apos;}(\theta_t)}{2}(t&#x2d;\frac{\alpha+\beta}{2})^2 |
\\
&amp;\leq &amp; \frac{M_2}{2} 2 \int_{\frac{\alpha+\beta}{2}}^{\beta}
(t&#x2d;\frac{\alpha+\beta}{2})^2 dt  \\
&amp; \leq &amp; M_2\frac{(\beta&#x2d;\alpha)^3}{24}
 \end{matrix} </annotation></semantics></math>
Dans l’exemple, on a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>2</mn></msub><mo>=</mo><mn>6</mn></mrow><annotation encoding='application/x-tex'>M_2=6</annotation></semantics></math>, donc l’erreur sur une subdivision est
majorée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0.25</mn><mi>e</mi><mo>&minus;</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>0.25e&#x2d;3</annotation></semantics></math>, donc sur 10 subdivisions par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0.25</mn><mi>e</mi><mo>&minus;</mo><mn>2</mn><mo>=</mo><mn>0.0025</mn></mrow><annotation encoding='application/x-tex'>0.25e&#x2d;2=0.0025</annotation></semantics></math>.</p><p>Pour les trapèzes, la fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> dont le graphe est le segment reliant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\alpha,f(\alpha)]</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&beta;</mi><mo>,</mo><mi>f</mi><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\beta,f(\beta)]</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(\alpha)+(t&#x2d;\alpha)/(\beta&#x2d;\alpha)f(\beta)</annotation></semantics></math>,
c’est en fait un polynome de Lagrange, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est deux fois continument
dérivable, on peut donc majorer la différence
entre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math> en utilisant (<a href="#eqref_49">49</a>), on intègre la valeur
absolue ce qui donne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>g</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">&vert;</mo><mfrac><mrow><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>&xi;</mi> <mi>x</mi></msub><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>M</mi> <mn>2</mn></msub><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mn>3</mn></msup></mrow><mn>12</mn></mfrac></mrow><annotation encoding='application/x-tex'> |\int_{\alpha}^{\beta} f(t) dt &#x2d; \int_{\alpha}^{\beta} g(t) dt |
\leq \int_{\alpha}^{\beta} |\frac{f&apos;{&apos;}(\xi_x)}{2} (x&#x2d;\alpha)(x&#x2d;\beta)|
\leq M_2 \frac{(\beta&#x2d;\alpha)^3}{12}  </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>2</mn></msub></mrow><annotation encoding='application/x-tex'>M_2</annotation></semantics></math> est un majorant de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">&vert;</mo></mrow><annotation encoding='application/x-tex'>|f&apos;{&apos;}|</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math>.</p><p>Lorsqu’on calcule l’intégrale sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math> par une de ces méthodes,
on fait la somme sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>h</mi></mrow><annotation encoding='application/x-tex'>n=(b&#x2d;a)/h</annotation></semantics></math> subdivisions de longueur 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><mo>=</mo><mi>h</mi></mrow><annotation encoding='application/x-tex'>\beta&#x2d;\alpha=h</annotation></semantics></math>, on obtient
donc une majoration de l’erreur commise sur l’intégrale :
</p><ul class="itemize"><li class="li-itemize">
pour les rectangles à droite ou gauche <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><msub><mi>M</mi> <mn>1</mn></msub><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">/</mo><mn>2</mn><mo>=</mo><msub><mi>M</mi> <mn>1</mn></msub><mi>h</mi><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>nM_1h^2/2=M_1 h (b&#x2d;a)/2</annotation></semantics></math>
</li><li class="li-itemize">pour le point milieu <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>2</mn></msub><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>24</mn></mrow><annotation encoding='application/x-tex'>M_2 h^2 (b&#x2d;a)/24</annotation></semantics></math>
</li><li class="li-itemize">pour les trapèzes <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>2</mn></msub><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>12</mn></mrow><annotation encoding='application/x-tex'>M_2h^2 (b&#x2d;a)/12</annotation></semantics></math>.
</li></ul><p>
Lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> tend vers 0, l’erreur tend vers 0, mais pas à la même vitesse,
plus rapidement pour les trapèzes et le point milieu
que pour les rectangles. Plus on
approche précisément la fonction sur une subdivision, plus la
puissance de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> va être grande, plus la convergence sera rapide
lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> sera petit, avec toutefois une contrainte fixée par la
valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>M_k</annotation></semantics></math>, borne sur la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> (plus
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math> est grand, plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>M_k</annotation></semantics></math> est grand en général). Nous allons voir dans la suite
comment se comporte cette puissance de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> en fonction de la facon
dont on approche <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>.</p>
<!--TOC section id="sec195" Ordre d’une méthode-->
<h2 id="sec195" class="section">20.2  Ordre d’une méthode</h2><!--SEC END --><p> <a id="hevea_default225"></a>
On appelle méthode d’intégration l’écriture d’une approximation
de l’intégrale sur une subdivision sous la forme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mo>&approx;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><msub><mi>w</mi> <mi>j</mi></msub><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \int_{\alpha}^{\beta} f(t) dt \approx I(f)=\sum_{j=1}^k w_j f(x_j)  </annotation></semantics></math>
où les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> sont dans l’intervalle <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\alpha,\beta]</annotation></semantics></math>, par exemple équirépartis
sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\alpha,\beta]</annotation></semantics></math>. On utilise aussi la définition :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi><mo>&approx;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><msub><mover><mi>w</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi></msub><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> \int_{\alpha}^{\beta} f(t) dt \approx I(f)=
(\beta&#x2d;\alpha)\sum_{j=1}^k \tilde{w}_j f(x_j)  </annotation></semantics></math>
On prend toujours <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>j</mi></msub><msub><mi>w</mi> <mi>j</mi></msub><mo>=</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\sum_j w_j=\beta&#x2d;\alpha</annotation></semantics></math> (ou <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mi>j</mi></msub><msub><mover><mi>w</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>\sum_j \tilde{w}_j=1</annotation></semantics></math>) pour
que la méthode donne le résultat exact si la fonction est constante.</p><p>On dit qu’une méthode d’intégration est d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> si il y a égalité
ci-dessus pour tous les polynômes de degré inférieur ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
et non égalité pour un polynôme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>.
Par exemple, les rectangles à droite et gauche sont d’ordre 0, 
le point milieu et les trapèzes sont d’ordre 1. Plus
généralement, si on approche <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> par son polynôme
d’interpolation de Lagrange en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> points (donc par un polynôme
de degré inférieur ou égal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>), on obtient une méthode
d’intégration d’ordre au moins <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>.</p><p>Si une méthode est d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> avec des <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>j</mi></msub><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>w_j\geq 0</annotation></semantics></math> et 
si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> fois continument dérivable,
alors sur une subdivision, on a :
<a id="eqref_32"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>M</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo stretchy="false">(</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></mfrac><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>32</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
|\int_{\alpha}^{\beta} f&#x2d;I(f)| \leq M_{n+1} \frac{(\beta&#x2d;\alpha)^{n+2}}{(n+1)!}
(\frac{1}{n+2}+1)
\qquad (32) </annotation></semantics></math></p><p>En effet, on fait le développement de Taylor de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> par exemple
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math> à l’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>+</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mi>t</mi></msub><mo stretchy="false">)</mo><mo>,</mo></mtd></mtr> <mtr><mtd><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mi>n</mi></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 f(t)&amp;=&amp;T_{n}(f)+\frac{(t&#x2d;\alpha)^{n+1}}{(n+1)!} f^{[n+1]}(\theta_t),\\
 T_{n}(f)&amp;=&amp;f(\alpha)+(t&#x2d;\alpha)f&apos;(\alpha)+...+ 
\frac{(t&#x2d;\alpha)^{n}}{n!} f^{[n]}(\alpha)
 \end{matrix} </annotation></semantics></math>
Donc 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo stretchy="false">&vert;</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mi>t</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msubsup><mrow><mo>[</mo><msub><mi>M</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo>]</mo></mrow> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup></mrow><annotation encoding='application/x-tex'> |\int_{\alpha}^{\beta} f&#x2d; \int_{\alpha}^{\beta} T_{n}(f)|
\leq \int_{\alpha}^{\beta} \frac{(t&#x2d;\alpha)^{n+1}}{(n+1)!} |f^{[n+1]}(\theta_t)| 
\leq \left[ M_{n+1} \frac{(t&#x2d;\alpha)^{n+2}}{(n+2)!} \right]_\alpha^\beta
 </annotation></semantics></math>
De plus, 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mo stretchy="false">&vert;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>=</mo><mo stretchy="false">&vert;</mo><mi>I</mi><mrow><mo>(</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&theta;</mi> <mi>t</mi></msub><mo stretchy="false">)</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo>)</mo></mrow><mo stretchy="false">&vert;</mo></mtd> <mtd><mo>&leq;</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>M</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mtd></mtr> <mtr><mtd/> <mtd><mo>&leq;</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>M</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 |I(f) &#x2d;I(T_n(f))| =|I\left( f^{[n+1]}(\theta_t)
  \frac{(t&#x2d;\alpha)^{n+1}}{(n+1)!} \right)|
&amp; \leq &amp;  \sum_{j=1}^k |w_j| M_{n+1} \frac{(x_j&#x2d;\alpha)^{n+1}}{(n+1)!} 
\\
&amp; \leq &amp; \sum_{j=1}^k |w_j| M_{n+1} \frac{(\beta&#x2d;\alpha)^{n+1}}{(n+1)!}
 \end{matrix} </annotation></semantics></math>
Donc comme la méthode est exacte pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_n(f)</annotation></semantics></math>, on en déduit que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>+</mo><mi>I</mi><mo stretchy="false">(</mo><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>&leq;</mo></mtd> <mtd><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>+</mo><mo stretchy="false">&vert;</mo><mi>I</mi><mo stretchy="false">(</mo><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>&leq;</mo></mtd> <mtd><msub><mi>M</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo>+</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><msub><mi>M</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
|\int_{\alpha}^{\beta} f&#x2d;I(f)|
&amp;= &amp;|\int_{\alpha}^{\beta} f&#x2d;\int_{\alpha}^{\beta} T_n(f)+I(T_n(f))&#x2d; I(f)| \\
&amp;\leq&amp; |\int_{\alpha}^{\beta} f&#x2d;\int_{\alpha}^{\beta} T_n(f)|+|I(T_n(f))&#x2d; I(f)|\\
&amp;\leq &amp; M_{n+1}  \frac{(\beta&#x2d;\alpha)^{n+2}}{(n+2)!} +  
\sum_{j=1}^k |w_j| M_{n+1} \frac{(\beta&#x2d;\alpha)^{n+1}}{(n+1)!} 
 \end{matrix} </annotation></semantics></math>
Si les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>j</mi></msub><mo>&geq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>w_j\geq 0</annotation></semantics></math>, alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></msubsup><mo stretchy="false">&vert;</mo><msub><mi>w</mi> <mi>j</mi></msub><mo stretchy="false">&vert;</mo><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></msubsup><msub><mi>w</mi> <mi>j</mi></msub><mo>=</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\sum_{j=1}^k |w_j|=\sum_{j=1}^k w_j=\beta&#x2d;\alpha</annotation></semantics></math>
et on obtient finalement (<a href="#eqref_32">32</a>)</p><p>On remarque qu’on peut améliorer la valeur de la constante 
en faisant tous les développement de Taylor
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>(\alpha+\beta)/2</annotation></semantics></math> au lieu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi></mrow><annotation encoding='application/x-tex'>\alpha</annotation></semantics></math>, 
Après sommation sur les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> subdivisions, on obtient que :
</p><div class="theorem"><span style="font-weight:bold">Théorème 39</span>  <em>
Pour une méthode d’ordre </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math><em> à coefficients positifs et une fonction </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><em>
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math><em> fois continument dérivable 
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><mi>f</mi><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>M</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mfrac><mrow><msup><mi>h</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><msup><mn>2</mn> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mfrac><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>|\int_{a}^{b} f&#x2d;I(f)| \leq M_{n+1} \frac{h^{n+1}}{2^{n+1}(n+1)!}  (b&#x2d;a) 
(\frac{1}{(n+2)}+1) </annotation></semantics></math><em>
</em></div><p>On observe que cette majoration a la bonne puissance de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> sur
les exemples déja traités, mais pas forcément le meilleur coefficient
possible, parce que nous avons traité le cas général d’une
méthode d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, et utilisé une majoration pas toujours
optimale du reste. Pour obtenir la meilleure valeur possible de la
constante, il faut exprimer le reste de la formule de Taylor sous
forme intégrale et utiliser la forme précise de la méthode :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>t</mi></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mi>n</mi></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>f(t)=T_n(f)(t)+\int_\alpha^t \frac{(t&#x2d;x)^n}{n!} f^{[n+1]}(x) \ 
dx  </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>t</mi></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mi>n</mi></msup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>x</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mi>n</mi></msubsup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int_{\alpha}^{\beta} f&#x2d; \int_{\alpha}^{\beta} T_{n}(f)
= \int_{\alpha}^{\beta} \int_\alpha^t\frac{(t&#x2d;x)^{n}}{n!} 
f^{[n+1]}(x) \ dx \ dt
= \int_{\alpha}^{\beta} \int_\alpha^\beta \frac{(t&#x2d;x)_+^{n}}{n!} 
f^{[n+1]}(x) \ dx \ dt
 </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>x</mi><msub><mo stretchy="false">)</mo> <mo>+</mo></msub><mo>=</mo></mrow><annotation encoding='application/x-tex'>(t&#x2d;x)_+=</annotation></semantics></math>max<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mi>t</mi><mo>&minus;</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(0,t&#x2d;x)</annotation></semantics></math>. En intervertissant les deux intégrales
(Fubini), on obtient :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>x</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mi>n</mi></msubsup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msubsup><mo>&Integral;</mo> <mi>x</mi> <mi>&beta;</mi></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mi>x</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mi>n</mi></msubsup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} \int_{\alpha}^{\beta} f&#x2d; \int_{\alpha}^{\beta} T_{n}(f)
&amp;=&amp; \int_{\alpha}^{\beta} \int_\alpha^\beta \frac{(t&#x2d;x)_+^{n}}{n!} 
\ dt f^{[n+1]}(x) \ dx \\
&amp;=&amp; \int_{\alpha}^{\beta} \int_x^\beta \frac{(t&#x2d;x)_+^{n}}{n!} \ dt 
f^{[n+1]}(x) \ dx\\
&amp;=&amp; \int_{\alpha}^{\beta} \frac{(\beta&#x2d;x)^{n+1}}{(n+1)!} f^{[n+1]}(x) \ dx
 \end{matrix} </annotation></semantics></math>
D’autre part :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><msub><mi>T</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mi>I</mi><mrow><mo>(</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>t</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mi>n</mi></msubsup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>)</mo></mrow></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><msub><mi>w</mi> <mi>j</mi></msub><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo>&minus;</mo><mi>t</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mi>n</mi></msubsup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix} I(f)&#x2d;I(T_n(f)) &amp;=&amp;
I\left( \int_\alpha^\beta \frac{(x&#x2d;t)_+^{n}}{n!}  f^{[n+1]}(t) \ dt 
  \right) \\
&amp; = &amp;  \sum_{j=1}^k w_j 
\int_\alpha^\beta \frac{(x_j&#x2d;t)_+^{n}}{n!} f^{[n+1]}(t) \ dt 
 \end{matrix} </annotation></semantics></math>
Donc :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">(</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo>&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><msub><mi>w</mi> <mi>j</mi></msub><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo>&minus;</mo><mi>x</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mi>n</mi></msubsup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac><mo stretchy="false">)</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>\int_{\alpha}^{\beta} f&#x2d;I(f)
= \int_{\alpha}^{\beta} 
( \frac{(\beta&#x2d;x)^{n+1}}{(n+1)!} &#x2d;  \sum_{j=1}^k w_j \frac{(x_j&#x2d;x)_+^{n}}{n!})
f^{[n+1]}(x) \ dx
 </annotation></semantics></math>
On appelle noyau de <span style="font-weight:bold">Péano</span><a id="hevea_default226"></a> l’expression
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo>&minus;</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mi>k</mi></munderover><msub><mi>w</mi> <mi>j</mi></msub><mfrac><mrow><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo>&minus;</mo><mi>x</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mi>n</mi></msubsup></mrow><mrow><mi>n</mi><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>N(x)=\frac{(\beta&#x2d;x)^{n+1}}{(n+1)!} &#x2d;  \sum_{j=1}^k w_j
\frac{(x_j&#x2d;x)_+^{n}}{n!} </annotation></semantics></math>
On a alors :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mi>f</mi><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">&vert;</mo><mi>N</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo stretchy="false">&vert;</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo>&leq;</mo><msub><mi>M</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">&vert;</mo><mi>N</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>|\int_{\alpha}^{\beta} f&#x2d;I(f)|
\leq \int_{\alpha}^{\beta} |N(x)| |f^{[n+1]}(x)| \ dx
\leq M_{n+1} \int_{\alpha}^{\beta} |N(x)| \ dx </annotation></semantics></math></p>
<!--TOC section id="sec196" Simpson-->
<h2 id="sec196" class="section">20.3  Simpson</h2><!--SEC END --><p> <a id="hevea_default227"></a>
Il s’agit de la méthode obtenue en approchant la fonction
sur la subdivision <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\alpha,\beta]</annotation></semantics></math> par son polynome de Lagrange
aux points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>,</mo><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\alpha,(\alpha+\beta)/2,\beta</annotation></semantics></math>. On calcule l’intégrale
par exemple avec un logiciel de calcul formel, avec Xcas :
</p><div class="center">
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">factor(int(lagrange([a,(a+b)/2,b],[fa,fm,fb]),x=a..b)) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

</div><p>
qui donne la formule sur une subdivision
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>h</mi><mn>6</mn></mfrac><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn><mi>f</mi><mo stretchy="false">(</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> I(f) = \frac{h}{6} (f(\alpha)+4f(\frac{\alpha+\beta}{2}) + f(\beta))  </annotation></semantics></math>
et sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math> :
<a id="eqref_33"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>h</mi><mn>6</mn></mfrac><mrow><mo>(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mn>4</mn><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>j</mi><mi>h</mi><mo>+</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></munderover><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>j</mi><mi>h</mi><mo stretchy="false">)</mo><mo>)</mo></mrow><mspace width="2em"/><mo stretchy="false">(</mo><mn>33</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
I(f) = \frac{h}{6} \left( f(a)+f(b)+ 4 \sum_{j=0}^{n&#x2d;1} f(a+jh+\frac{h}{2})
+ 2  \sum_{j=1}^{n&#x2d;1} f(a+jh) \right)
\qquad (33) </annotation></semantics></math>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">f(x):=ln(1+x^2); a:=0; b:=1.0; n:=100.0; h:=(b-a)/n; int(f(x),x,a,b) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">h/6*(f(a)+f(b)+4*sum(f(a+j*h+h/2),j,0,n-1)+2*sum(f(a+j*h),j,1,n-1)) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
Si on intègre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>t</mi> <mn>3</mn></msup></mrow><annotation encoding='application/x-tex'>t^3</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,1]</annotation></semantics></math> en 1 subdivision par cette méthode,
on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mn>1</mn><mn>6</mn></mfrac><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mn>4</mn><mfrac><mn>1</mn><mrow><msup><mn>2</mn> <mn>3</mn></msup></mrow></mfrac><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac></mrow><annotation encoding='application/x-tex'> \frac{1}{6} (0+ 4 \frac{1}{2^3} + 1)=\frac{1}{4}  </annotation></semantics></math>
c’est-à-dire le résultat exact, ceci est aussi vérifié pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> polynome
de degré inférieur ou égal à 2 puisque l’approximation de Lagrange
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est alors égale à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>. On en déduit que la méthode de Simpson
est d’ordre 3 (pas plus car la méthode
de Simpson appliquée à l’intégrale de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>t</mi> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>t^4</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,1]</annotation></semantics></math> n’est pas exacte). On peut améliorer
la constante générale de la section précédente pour la majoration
de l’erreur en :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><mi>f</mi><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><msup><mi>h</mi> <mn>4</mn></msup></mrow><mn>2880</mn></mfrac><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><msub><mi>M</mi> <mn>4</mn></msub></mrow><annotation encoding='application/x-tex'> |\int_a^b f &#x2d; I(f)| \leq \frac{h^4}{2880} (b&#x2d;a) M_4  </annotation></semantics></math>
En effet sur une subdivision élémentaire <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\alpha,\beta]</annotation></semantics></math>, 
le noyau de Péano vaut :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mi>N</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mn>4</mn></msup></mrow><mrow><mn>4</mn><mo>!</mo></mrow></mfrac><mo>&minus;</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>x</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mn>3</mn></msubsup></mrow><mrow><mn>3</mn><mo>!</mo></mrow></mfrac><mo>&minus;</mo><mfrac><mn>23</mn><mfrac><mrow><mo stretchy="false">(</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo>&minus;</mo><mi>x</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mn>3</mn></msubsup></mrow><mrow><mn>3</mn><mo>!</mo></mrow></mfrac></mfrac><mo>&minus;</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mfrac><mrow><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>&minus;</mo><mi>x</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mn>3</mn></msubsup></mrow><mrow><mn>3</mn><mo>!</mo></mrow></mfrac></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mn>4</mn></msup></mrow><mrow><mn>4</mn><mo>!</mo></mrow></mfrac><mo>&minus;</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mfrac><mrow><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>x</mi><msup><mo stretchy="false">)</mo> <mn>3</mn></msup></mrow><mrow><mn>3</mn><mo>!</mo></mrow></mfrac><mo>&minus;</mo><mfrac><mn>23</mn><mfrac><mrow><mo stretchy="false">(</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo>&minus;</mo><mi>x</mi><msubsup><mo stretchy="false">)</mo> <mo>+</mo> <mn>3</mn></msubsup></mrow><mrow><mn>3</mn><mo>!</mo></mrow></mfrac></mfrac></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 N(x) &amp;=&amp;
\frac{(\beta&#x2d;x)^4}{4!} &#x2d; \frac{1}{6} \frac{(\beta&#x2d;x)_+^{3}}{3!}
&#x2d;\frac23 \frac{(\frac{\alpha+\beta}2&#x2d;x)_+^{3}}{3!} &#x2d; 
\frac{1}{6} \frac{(\alpha&#x2d;x)_+^{3}}{3!} \\
&amp; =&amp;
\frac{(\beta&#x2d;x)^4}{4!} &#x2d; \frac{1}{6} \frac{(\beta&#x2d;x)^{3}}{3!}
&#x2d;\frac23 \frac{(\frac{\alpha+\beta}2&#x2d;x)_+^{3}}{3!} 
 \end{matrix} </annotation></semantics></math>
on observe que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>N(x)\leq 0</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\alpha,\beta]</annotation></semantics></math> <br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">N(x):=(1-x)^4/4!-1/6*(1-x)^3/3!-2/3/3!*max(0,1/2-x)^3 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>
<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">plot(1000*N(x),x=0..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

et son intégrale vaut <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2880</mn><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><msup><mo stretchy="false">)</mo> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>&#x2d;1/2880(\beta&#x2d;\alpha)^4</annotation></semantics></math> :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">int(N(x),x=0..1/2)+int(N(x),x=1/2..1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p><span style="font-weight:bold">Remarque</span> : Une autre preuve de cette majoration utilise les
différences divisées (<a href="#eqref_51">51</a>).
La méthode de Simpson sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>[\alpha,\beta</annotation></semantics></math> 
utilise le polynôme d’interpolation en 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&alpha;</mi><mo>,</mo><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>\alpha, (\alpha+\beta)/2, \beta</annotation></semantics></math>, on a donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>P_2(x)&#x2d;f(x)=(x&#x2d;\alpha)(x&#x2d;\beta) (x&#x2d;\frac{\alpha+\beta}{2})
f[\alpha,\frac{\alpha+\beta}{2},\beta,x] </annotation></semantics></math>
on doit donc majorer l’erreur
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>E</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>E=\int_\alpha^\beta (x&#x2d;\alpha)(x&#x2d;\beta) (x&#x2d;\frac{\alpha+\beta}{2})
f[\alpha,\frac{\alpha+\beta}{2},\beta,x] \ dx  </annotation></semantics></math>
D’autre part, en appliquant <a href="#eqref_50">50</a> avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n+2</annotation></semantics></math> points, on a
pour tout <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_{n+1}</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>f[x_0,..,x_n,x]=f[x_0,..,x_n,x_{n+1}]+(x&#x2d;x_{n+1})f[x_0,..,x_n,x_{n+1},x] </annotation></semantics></math>
donc ici :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>t</mi><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>t</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>f[\alpha,\frac{\alpha+\beta}{2},\beta,x]=f[\alpha,\frac{\alpha+\beta}{2},\beta,t]+(x&#x2d;t)f[\alpha,\frac{\alpha+\beta}{2},\beta,t,x] </annotation></semantics></math>
que l’on remplace dans <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>E</mi></mrow><annotation encoding='application/x-tex'>E</annotation></semantics></math> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>E</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>t</mi><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>t</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><mo>,</mo><mi>&beta;</mi><mo>,</mo><mi>t</mi><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>E=\int_\alpha^\beta (x&#x2d;\alpha)(x&#x2d;\beta) (x&#x2d;\frac{\alpha+\beta}{2})
(f[\alpha,\frac{\alpha+\beta}{2},\beta,t]
+(x&#x2d;t)
f[\alpha,\frac{\alpha+\beta}{2},\beta,t,x]) \ dx </annotation></semantics></math>
on distribue, le premier terme est d’intégrale nulle,
et lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi></mrow><annotation encoding='application/x-tex'>t</annotation></semantics></math> tend vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>(\alpha+\beta)/2</annotation></semantics></math> le second
tend vers :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>E</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mfrac><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&xi;</mi> <mi>x</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mn>4</mn><mo>!</mo></mrow></mfrac><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>E=\int_\alpha^\beta (x&#x2d;\alpha)(x&#x2d;\beta) (x&#x2d;\frac{\alpha+\beta}{2})^2 
\frac{f^{[4]}(\xi_x)}{4!} \ dx </annotation></semantics></math>
On applique alors la formule de la moyenne 
(car <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>(x&#x2d;\alpha)(x&#x2d;\beta) (x&#x2d;\frac{\alpha+\beta}{2})^2</annotation></semantics></math> est de signe constant)
et
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>&xi;</mi><mo stretchy="false">)</mo></mrow><mrow><mn>4</mn><mo>!</mo></mrow></mfrac><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mi>&beta;</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mfrac><mrow><mi>&alpha;</mi><mo>+</mo><mi>&beta;</mi></mrow><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo>=</mo><mfrac><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>&xi;</mi><mo stretchy="false">)</mo></mrow><mrow><mn>4</mn><mo>!</mo></mrow></mfrac><mfrac><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><msup><mo stretchy="false">)</mo> <mn>5</mn></msup></mrow><mn>120</mn></mfrac></mrow><annotation encoding='application/x-tex'>E=\frac{f^{[4]}(\xi)}{4!} 
\int_\alpha^\beta (x&#x2d;\alpha)(x&#x2d;\beta) (x&#x2d;\frac{\alpha+\beta}{2})^2 \ dx
= \frac{f^{[4]}(\xi)}{4!} \frac{(b&#x2d;a)^5}{120} </annotation></semantics></math></p><p>La méthode de Simpson nécessite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2n+1</annotation></semantics></math> évaluations de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> (le calcul
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est un point étant presque toujours 
l’opération la plus couteuse en temps d’une
méthode de quadrature), au lieu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> pour les rectangles
et le point milieu et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> pour les trapèzes. Mais on a une majoration
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>h^4</annotation></semantics></math> au lieu de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>h^2</annotation></semantics></math> donc le “rapport qualité-prix” de la méthode
de Simpson est meilleur, on l’utilise donc plutot que les
méthodes précédentes sauf si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> n’a pas la régularité
suffisante (ou si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>4</mn></msub></mrow><annotation encoding='application/x-tex'>M_4</annotation></semantics></math> est trop grand).</p>
<!--TOC section id="sec197" Newton-Cotes-->
<h2 id="sec197" class="section">20.4  Newton-Cotes</h2><!--SEC END --><p> <a id="hevea_default228"></a>
On peut généraliser l’idée précédente, découper la subdivision 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>&alpha;</mi><mo>,</mo><mi>&beta;</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[\alpha,\beta]</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> parts égales et utiliser le polynôme d’interpolation
en ces <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>=</mo><mi>&alpha;</mi><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>=</mo><mi>&beta;</mi></mrow><annotation encoding='application/x-tex'>x_0=\alpha, x_1, ..., x_n=\beta</annotation></semantics></math>. 
Ce sont les méthodes de Newton-Cotes,
qui sont d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> au moins. Comme le polynôme d’interpolation
dépend linéairement des ordonnées, cette méthode est bien
de la forme :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow> <mi>n</mi></munderover><msub><mover><mi>w</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi></msub><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> I(f)=(\beta&#x2d;\alpha)\sum_{j=0}^n \tilde{w}_j f(x_j) </annotation></semantics></math>
De plus les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>w</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\tilde{w}_j</annotation></semantics></math> sont universels (ils ne dépendent pas de 
la subdivision), parce qu’on peut faire 
le changement de variables <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>&alpha;</mi><mo>+</mo><mi>t</mi><mo stretchy="false">(</mo><mi>&beta;</mi><mo>&minus;</mo><mi>&alpha;</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>x=\alpha+t(\beta&#x2d;\alpha)</annotation></semantics></math> dans l’intégrale
et le polynôme d’interpolation et donc se ramener à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,1]</annotation></semantics></math>.</p><p>Exemple : on prend le polynôme d’interpolation en 5 points 
équidistribués sur une subdivision <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math> (méthode de Boole). 
Pour calculer les
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>w</mi><mo stretchy="false">&tilde;</mo></mover> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>\tilde{w}_j</annotation></semantics></math>, on se ramène à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,1]</annotation></semantics></math>, puis on tape
</p><div class="center">
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">int(lagrange(seq(j/4,j,0,4),[f0,f1,f2,f3,f4]),x=0..1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>

</div><p>
et on lit les coefficients de <code>f0</code> à <code>f4</code>
qui sont les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>w</mi><mo stretchy="false">&tilde;</mo></mover> <mn>0</mn></msub></mrow><annotation encoding='application/x-tex'>\tilde{w}_0</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mover><mi>w</mi><mo stretchy="false">&tilde;</mo></mover> <mn>4</mn></msub></mrow><annotation encoding='application/x-tex'>\tilde{w}_4</annotation></semantics></math>: 7/90, 32/90, 12/90,
32/90, 7/90. Voir aussi la section <a href="#sec%3Apoids">20.5</a>
La méthode est d’ordre au moins 4 par construction, mais on vérifie
qu’elle est en fait d’ordre 5 (exercice), la majoration de l’erreur
d’une méthode d’ordre 5 est 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><mi>f</mi><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><msub><mi>M</mi> <mn>6</mn></msub></mrow><mrow><msup><mn>2</mn> <mn>6</mn></msup><mn>6</mn><mo>!</mo></mrow></mfrac><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mn>7</mn></mfrac><mo stretchy="false">)</mo><msup><mi>h</mi> <mn>6</mn></msup><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> |\int_a^b f &#x2d;I(f)| \leq \frac{M_6}{2^6 6!}(1+\frac{1}{7}) h^6 (b&#x2d;a)  </annotation></semantics></math>
elle peut être améliorée pour cette méthode précise en
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><mi>f</mi><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><msub><mi>M</mi> <mn>6</mn></msub></mrow><mn>1935360</mn></mfrac><msup><mi>h</mi> <mn>6</mn></msup><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> |\int_a^b f &#x2d;I(f)| \leq \frac{M_6}{1935360} h^6 (b&#x2d;a)  </annotation></semantics></math></p><p>En pratique, on ne les utilise pas très souvent, car d’une part
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&geq;</mo><mn>8</mn></mrow><annotation encoding='application/x-tex'>n\geq 8</annotation></semantics></math>, les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>w_j</annotation></semantics></math> ne sont pas tous positifs, et
d’autre part, parce que la constante <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>M_n</annotation></semantics></math> devient trop
grande. On préfère utiliser la méthode de Simpson en utilisant
un pas plus petit.</p><p>Il existe aussi d’autres méthodes, par exemple les quadratures de Gauss
(on choisit d’interpoler en utilisant des points non équirépartis 
tels que l’ordre de la méthode soit le plus grand possible, cf. infra)
ou la méthode de Romberg qui est une méthode d’accélération
de convergence basée sur la méthode des trapèzes (on prend
la méthode des trapèzes en 1 subdivision de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math>, puis
2, puis <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mn>2</mn> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>2^2</annotation></semantics></math>, ..., et on élimine les puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math>
du reste <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&Integral;</mo><mi>f</mi><mo>&minus;</mo><mi>I</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\int f&#x2d;I(f)</annotation></semantics></math> en utilisant un théorème d’Euler-Mac Laurin
qui montre que le développement asymptotique de
l’erreur en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> ne contient que des puissances paires
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math>). De plus, on peut être amené à faire varier le pas <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math>
en fonction de la plus ou moins grande régularité de la fonction.</p>
<!--TOC section id="sec198" Calcul des poids <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>w_i</annotation></semantics></math>-->
<h2 id="sec198" class="section">20.5  Calcul des poids <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>w_i</annotation></semantics></math></h2><!--SEC END --><p> <a id="sec:poids"></a>
Si la méthode d’intégration consiste à interpoler 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> points <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math>, alors la méthode est exacte pour
tout polynôme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>. Si on prend 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>k</mi><mo>&ne;</mo><mi>j</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_j(x)=\prod_{k \neq j}(x&#x2d;x_k)</annotation></semantics></math>, on en déduit :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msub><mi>P</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo>=</mo><msub><mi>w</mi> <mi>j</mi></msub><msub><mi>P</mi> <mi>j</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\int_\alpha^\beta P_j(x) \ dx = w_j P_j(x_j)  </annotation></semantics></math> 
Par exemple en interpolant en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn><mo>,</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>0,1/2,1</annotation></semantics></math> sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,1]</annotation></semantics></math>, on obtient
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>w</mi> <mn>0</mn></msub><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo>,</mo><mspace width="1em"/><msub><mi>P</mi> <mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>w_0 P_0(0)=\int_0^1 P_0(x) \ dx, \quad P_0(x)=(x&#x2d;\frac{1}{2})(x&#x2d;1) </annotation></semantics></math>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">P0:=(x-1)*(x-1/2); int(P0,x,0,1)/P0(x=0); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
On peut aussi résoudre un système linéaire en prenant pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>
les polynômes de la base canonique, la matrice du système est
la transposée de la matrice de Vandermonde en les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>x_j</annotation></semantics></math> et le second
membre a pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>-ième composante <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>&alpha;</mi> <mi>&beta;</mi></msubsup><msup><mi>x</mi> <mi>j</mi></msup><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>\int_\alpha^\beta x^j \ dx</annotation></semantics></math>.
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">inv(tran(vandermonde(0,1/2,1)))*[1,1/2,1/3] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p>
<!--TOC section id="sec199" En résumé-->
<h2 id="sec199" class="section">20.6  En résumé</h2><!--SEC END --><p>
Intégration sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math>, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> pas d’une subdivision, <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>M_k</annotation></semantics></math> majorant
de la dérivée <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi></mrow><annotation encoding='application/x-tex'>k</annotation></semantics></math>-ième de la fonction sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math><br>
</p><table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >formule</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >Lagrange degré</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >ordre</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >erreur </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >rectangles</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<a href="#eqref_31">31</a>), (<a href="#eqref_31">31</a>)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>1</mn></msub><mi>h</mi><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>M_1 h (b&#x2d;a)/2</annotation></semantics></math> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >point milieu</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<a href="#eqref_31">31</a>)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >0</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>2</mn></msub><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>24</mn></mrow><annotation encoding='application/x-tex'>M_2 h^2 (b&#x2d;a)/24</annotation></semantics></math> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >trapèzes</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<a href="#eqref_31">31</a>)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >1</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>2</mn></msub><msup><mi>h</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>12</mn></mrow><annotation encoding='application/x-tex'>M_2 h^2 (b&#x2d;a)/12</annotation></semantics></math> </td></tr>
<tr><td style="text-align:center;border:solid 1px;white-space:nowrap" >Simpson</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >(<a href="#eqref_33">33</a>)</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >2</td><td style="text-align:center;border:solid 1px;white-space:nowrap" >3</td><td style="text-align:center;border:solid 1px;white-space:nowrap" ><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>4</mn></msub><msup><mi>h</mi> <mn>4</mn></msup><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mn>2880</mn></mrow><annotation encoding='application/x-tex'>M_4 h^4 (b&#x2d;a)/2880</annotation></semantics></math> </td></tr>
</table>
<!--TOC section id="sec200" Accélération de Richardson-Romberg-->
<h2 id="sec200" class="section">20.7  Accélération de Richardson-Romberg</h2><!--SEC END --><p>
<a id="hevea_default229"></a><a id="hevea_default230"></a>
</p><div class="theorem"><span style="font-weight:bold">Proposition 40</span>  <em>
Soit </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>g</mi></mrow><annotation encoding='application/x-tex'>g</annotation></semantics></math><em> une fonction de classe </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup></mrow><annotation encoding='application/x-tex'>C^{2k}</annotation></semantics></math><em> sur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math><em>, 
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>h</mi></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_h(g)</annotation></semantics></math><em> la valeur de la méthode des trapèzes sur </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math><em> de pas 
</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>N</mi></mrow><annotation encoding='application/x-tex'>h=(b&#x2d;a)/N</annotation></semantics></math><em> (</em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math><em> entier).
Alors </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mi>h</mi></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_h(g)</annotation></semantics></math><em> admet un développement en puissances paires de </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math><em>
à l’ordre </em><math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>k</mi></mrow><annotation encoding='application/x-tex'>2k</annotation></semantics></math><em>.
</em></div><p>Pour montrer ce résultat, il faut établir la formule d’Euler-Mac
Laurin. On commence par se placer sur une subdivision de l’intervalle
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[0,1]</annotation></semantics></math>, on intègre par parties <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int_0^1 f(t)\ dt</annotation></semantics></math> en faisant apparaitre
la formule des trapèzes, on intègre donc 1 en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'>t&#x2d;\frac{1}{2}</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><msubsup><mo stretchy="false">]</mo> <mn>0</mn> <mn>1</mn></msubsup><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int_0^1 f(t) \ dt = 
[(t&#x2d;\frac{1}{2})f(t)]_0^1 &#x2d; \int_0^1 (t&#x2d;\frac{1}{2})f&apos;(t) \ dt =
\frac{f(0)+f(1)}{2} &#x2d; \int_0^1 (t&#x2d;\frac{1}{2})f&apos;(t) \ dt
 </annotation></semantics></math>
où encore
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>T</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>T_1(f)=\int_0^1 f(t) \ dt 
+  \int_0^1 (t&#x2d;\frac{1}{2})f&apos;(t) \ dt  </annotation></semantics></math>
Pour poursuivre, on pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding='application/x-tex'>B_1(t)=t&#x2d;\frac{1}{2}</annotation></semantics></math>, qu’on va intégrer
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\frac{1}{2}((t&#x2d;\frac{1}{2})^2+c)</annotation></semantics></math>, où on choisit <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi></mrow><annotation encoding='application/x-tex'>c</annotation></semantics></math> pour que l’intégrale
soit nulle, donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>c</mi><mo>=</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>6</mn></mrow><annotation encoding='application/x-tex'>c=&#x2d;1/6</annotation></semantics></math>. On pose <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>6</mn></mrow><annotation encoding='application/x-tex'>B_2=(t&#x2d;\frac{1}{2})^2&#x2d;1/6</annotation></semantics></math>, on a :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>T</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><mo stretchy="false">[</mo><mfrac><mrow><msub><mi>B</mi> <mn>2</mn></msub></mrow><mn>2</mn></mfrac><mi>f</mi><mo>&prime;</mo><msubsup><mo stretchy="false">]</mo> <mn>0</mn> <mn>1</mn></msubsup><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mfrac><mrow><msub><mi>B</mi> <mn>2</mn></msub></mrow><mn>2</mn></mfrac><mi>f</mi><mo>&prime;</mo><mo>&prime;</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>T_1(f)=\int_0^1 f(t) \ dt 
+ [\frac{B_2}{2} f&apos;]_0^1 &#x2d; \int_0^1 \frac{B_2}{2}f&apos;{&apos;}(t) \ dt 
 </annotation></semantics></math>
Plus
généralement, on pose
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>B</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&prime;</mo><mo>=</mo><mi>p</mi><msub><mi>B</mi> <mi>p</mi></msub><mo>,</mo><mspace width="1em"/><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><msub><mi>B</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>B_{p+1}&apos;=pB_p, \quad \int_0^1 B_{p+1}(t) \ dt=0  </annotation></semantics></math>
ce qui définit de manière unique les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>B_p</annotation></semantics></math>. La nullité de l’intégrale
montre que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>B</mi> <mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>B_{p+1}(1)=B_{p+1}(0)</annotation></semantics></math> ce qui simplifiera l’expression des
termes tout intégrés. De plus, on montre par récurrence
que les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>B</mi> <mi>p</mi></msub></mrow><annotation encoding='application/x-tex'>B_p</annotation></semantics></math> ont une symétrie paire
ou impaire selon la parité de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> par rapport à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo stretchy="false">/</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>t=1/2</annotation></semantics></math>.
Après <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>p</mi></mrow><annotation encoding='application/x-tex'>p</annotation></semantics></math> intégrations par parties, on obtient :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msub><mi>T</mi> <mn>1</mn></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><mfrac><mrow><msub><mi>B</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd/> <mtd/> <mtd><mo lspace="verythinmathspace" rspace="0em">+</mo><mfrac><mrow><msub><mi>B</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo stretchy="false">(</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&minus;</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mn>1</mn></msubsup><mfrac><mrow><msub><mi>B</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
  T_1(f)&amp;=&amp;\int_0^1 f(t) \ dt 
+ \frac{B_2(0)}{2} (f&apos;(1)&#x2d;f&apos;(0)) 
+ ... \\
&amp; &amp;+ \frac{B_{2k}(0)}{(2k)!} (f^{[2k&#x2d;1]}(1)&#x2d;f^{[2k&#x2d;1]}(0)) 
&#x2d; \int_0^1 \frac{B_{2k}}{(2k)!} f^{[2k]}(t) \ dt 
 \end{matrix} </annotation></semantics></math>
En faisant le même raisonnement sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>k</mi><mo>,</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[k,k+1]</annotation></semantics></math> pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><mi>N</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>k=1,...,N&#x2d;1</annotation></semantics></math>
et en sommant, on obtient la formule 
d’<span style="font-weight:bold">Euler-Mac Laurin</span><a id="hevea_default231"></a><a id="hevea_default232"></a> :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msubsup><mi>T</mi> <mn>1</mn> <mrow><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>N</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>+</mo><mfrac><mrow><msub><mi>B</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd/> <mtd/> <mtd><mo lspace="verythinmathspace" rspace="0em">+</mo><mfrac><mrow><msub><mi>B</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo stretchy="false">(</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>N</mi></msubsup><mfrac><mrow><msub><mi>B</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
  T_1^{[0,N]}(f)&amp;=&amp;\int_0^N f(t) \ dt 
+ \frac{B_2(0)}{2} (f&apos;(N)&#x2d;f&apos;(0)) 
+ ... \\
&amp; &amp; + \frac{B_{2k}(0)}{(2k)!} (f^{[2k&#x2d;1]}(N)&#x2d;f^{[2k&#x2d;1]}(0)) 
&#x2d; \int_0^N \frac{B_{2k}}{(2k)!} f^{[2k]}(t) \ dt 
 \end{matrix} </annotation></semantics></math>
On pose alors <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi><mo>+</mo><mi>h</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>x=a+ht</annotation></semantics></math> (donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>d</mi><mi>t</mi><mo>=</mo><mi>d</mi><mi>x</mi><mo stretchy="false">/</mo><mi>h</mi></mrow><annotation encoding='application/x-tex'>dt=dx/h</annotation></semantics></math>) et <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(t)=g(x)</annotation></semantics></math>
(donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mi>f</mi><mo stretchy="false">/</mo><mi>d</mi><mi>t</mi><mo>=</mo><mi>h</mi><mi>d</mi><mi>g</mi><mo stretchy="false">/</mo><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>f&apos;(t)=df/dt=h dg/dx</annotation></semantics></math>), on obtient 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><mfrac><mn>1</mn><mi>h</mi></mfrac><msubsup><mi>T</mi> <mi>h</mi> <mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><mfrac><mn>1</mn><mi>h</mi></mfrac><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>N</mi></msubsup><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo>+</mo><mfrac><mrow><msub><mi>B</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mi>h</mi><mo stretchy="false">(</mo><mi>g</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>g</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd/> <mtd/> <mtd><mo lspace="verythinmathspace" rspace="0em">+</mo><mfrac><mrow><msub><mi>B</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><msup><mi>h</mi> <mrow><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><msup><mi>g</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msup><mi>g</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&minus;</mo><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>N</mi></msubsup><mfrac><mrow><msub><mi>B</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><msup><mi>h</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup><msup><mi>g</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mfrac><mn>1</mn><mi>h</mi></mfrac><mi>d</mi><mi>x</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 \frac1h T_h^{[a,b]}(g)&amp;=&amp; \frac1h \int_0^N g(x) \ dx 
+ \frac{B_2(0)}{2} h(g&apos;(b)&#x2d;g&apos;(a)) 
+ ... \\
&amp; &amp;+ \frac{B_{2k}(0)}{(2k)!} h^{2k&#x2d;1} (g^{[2k&#x2d;1]}(N)&#x2d;g^{[2k&#x2d;1]}(0)) 
&#x2d; \int_0^N \frac{B_{2k}}{(2k)!} h^{2k} g^{[2k]}(x) \ \frac1h dx 
 \end{matrix} </annotation></semantics></math>
donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd><msubsup><mi>T</mi> <mi>h</mi> <mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo></mtd> <mtd><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>N</mi></msubsup><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo>+</mo><msup><mi>h</mi> <mn>2</mn></msup><mfrac><mrow><msub><mi>B</mi> <mn>2</mn></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>g</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mi>g</mi><mo>&prime;</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo></mtd></mtr> <mtr><mtd/> <mtd/> <mtd><mo lspace="verythinmathspace" rspace="0em">+</mo><msup><mi>h</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup><mfrac><mrow><msub><mi>B</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><mo stretchy="false">(</mo><msup><mi>g</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msup><mi>g</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&minus;</mo><msup><mi>h</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msup><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>N</mi></msubsup><mfrac><mrow><msub><mi>B</mi> <mrow><mn>2</mn><mi>k</mi></mrow></msub></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>k</mi><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><msup><mi>g</mi> <mrow><mo stretchy="false">[</mo><mn>2</mn><mi>k</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
 T_h^{[a,b]}(g) &amp;=&amp;  \int_0^N g(x) \ dx 
+ h^2 \frac{B_2(0)}{2} (g&apos;(b)&#x2d;g&apos;(a)) 
+ ... \\
&amp; &amp; + h^{2k} \frac{B_{2k}(0)}{(2k)!}  (g^{[2k&#x2d;1]}(N)&#x2d;g^{[2k&#x2d;1]}(0)) 
&#x2d; h^{2k} \int_0^N \frac{B_{2k}}{(2k)!}  g^{[2k]}(x) \  dx 
 \end{matrix} </annotation></semantics></math></p><p>L’accélération consiste à éliminer les puissances de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>h^2</annotation></semantics></math> en
commençant par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>h^2</annotation></semantics></math> avec des subdivisions deux fois plus fines
à chaque itération.
Ainsi <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>T</mi> <mi>h</mi> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>4</mn><msub><mi>T</mi> <mrow><mi>h</mi><mo stretchy="false">/</mo><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>T</mi> <mi>h</mi></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>4</mn><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_h^1(f) = (4T_{h/2}(f)&#x2d;T_h(f))/(4&#x2d;1)</annotation></semantics></math> n’a plus de termes en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>h^2</annotation></semantics></math>
et tend vers l’intégrale à approcher lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>h</mi></mrow><annotation encoding='application/x-tex'>h</annotation></semantics></math> tend vers 0. 
On peut d’ailleurs vérifier qu’il s’agit de la méthode de Simpson.
On élimine ensuite le terme en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>4</mn></msup></mrow><annotation encoding='application/x-tex'>h^4</annotation></semantics></math> en posant
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mi>T</mi> <mi>h</mi> <mn>2</mn></msubsup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msup><mn>4</mn> <mn>2</mn></msup><msubsup><mi>T</mi> <mrow><mi>h</mi><mo stretchy="false">/</mo><mn>2</mn></mrow> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msubsup><mi>T</mi> <mi>h</mi> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><msup><mn>4</mn> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>T_h^2(f)=(4^2 T_{h/2}^1(f)&#x2d;T_h^1(f))/(4^2&#x2d;1)</annotation></semantics></math> et ainsi
de suite. On construit un tableau triangulaire <code>T</code>
dont chaque
ligne <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>l</mi></mrow><annotation encoding='application/x-tex'>l</annotation></semantics></math> contient <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>T</mi> <mrow><mi>h</mi><mo stretchy="false">/</mo><msup><mn>2</mn> <mi>l</mi></msup></mrow></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>,</mo><msubsup><mi>T</mi> <mrow><mi>h</mi><mo stretchy="false">/</mo><msup><mn>2</mn> <mi>l</mi></msup></mrow> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo></mrow><annotation encoding='application/x-tex'>T_{h/2^l}(f), T_{h/2^l}^1(f), ...</annotation></semantics></math> 
(avec des indices qui commencent à 0). Pour
calculer le terme d’indice 0 de la ligne courante
on fait une méthode des trapèzes sur 2 fois plus
de subdivisions que la précédente, puis pour le <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>-ième terme
<code>T[l,j]</code>
on effectue <code>(4^j*T[l-1,j-1]-T[l,j-1])/(4^j-1)</code>
(on n’a donc besoin que de la ligne précédente pour calculer
la ligne courante).
On s’arrête par exemple lorsque la valeur absolue de la différence
entre les derniers termes de deux lignes consécutives est inférieur
à la précision souhaitée (erreur empirique).</p>
<!--TOC section id="sec201" Cas des fonctions périodiques.-->
<h2 id="sec201" class="section">20.8  Cas des fonctions périodiques.</h2><!--SEC END --><p>
Si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> est une fonction périodique régulière (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>C</mi> <mn>&infin;</mn></msup></mrow><annotation encoding='application/x-tex'>C^\infty</annotation></semantics></math>),
alors la méthode des trapèzes sur une période est d’ordre 
arbitrairement grand. En effet, pour une série de Fourier tronquée
à l’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi></mrow><annotation encoding='application/x-tex'>m</annotation></semantics></math>, la formule des trapèzes avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> subdivisions donne
le résultat exact de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo>&Integral;</mo> <mn>0</mn> <mi>T</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int_0^T f(t) dt</annotation></semantics></math> dès que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi><mi>&gt;</mi><mi>m</mi></mrow><annotation encoding='application/x-tex'>N&amp;gt;m</annotation></semantics></math>. Il suffit
ensuite d’utiliser que le reste de
la série de Fourier (<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>m</mi><mi>&gt;</mi><mi>N</mi></mrow><annotation encoding='application/x-tex'>m&amp;gt;N</annotation></semantics></math>) 
a des coefficients à décroissance rapide.</p><p>La méthode des trapèzes donne donc de bons résultats pour une 
fonction périodique, on peut d’ailleurs aussi 
l’appliquer pour calculer une valeur
approchée des coefficients de Fourier de la fonction. La liste des valeurs
approchées obtenue est alors la transformée de Fourier discrète
des valeurs de la fonction <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> aux <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>N</mi></mrow><annotation encoding='application/x-tex'>N</annotation></semantics></math> points de la subdivision, elle
se calcule donc rapidement avec la transformée de Fourier rapide.
Par exemple, pour approcher <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>e</mi> <mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>f(x)=e^{\sin(x)}</annotation></semantics></math>, on peut utiliser les
commandes suivantes en Xcas :

</p><pre class="verbatim">f(x):=exp(sin(x));
N:=16; F:=seq(f(k/N*2.*pi),k,0,N-1); G:=fft(F);
k:=4;
g:=G[0]+sum(G[j]*exp(i*j*x),j,1,k)+sum(G[N-j]*exp(-i*j*x),j,1,k);
h:=normal(re(exp2trig(g))/N);
</pre><p> 
<button onclick="var field=parentNode.previousSibling; var tmp=field.innerHTML;if(tmp.length==0) tmp=field.value;var t=createElement('TEXTAREA');t.style.fontSize=16;t.cols=60;t.rows=10;var tmp1=UI.ltgt(tmp);t.value=tmp1[0];tmp=UI.caseval(tmp);tmp=UI.rmquote(tmp);nextSibling.innerHTML=tmp; UI.render_canvas(nextSibling.innerHTML); field.parentNode.insertBefore(t,field);field.parentNode.removeChild(field);">ok</button><span></span><br>



<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">plot(h,x=-pi..pi,color=red); //plot(f(x),x=-pi..pi)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>Ou directement <code>2*re(G[j]/N)</code> est une valeur approchée du
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>j</mi></mrow><annotation encoding='application/x-tex'>j</annotation></semantics></math>-ième coefficient de Fourier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>a_j</annotation></semantics></math> de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>, et <code>-2*im(G[j]/N)</code>
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>b</mi> <mi>j</mi></msub></mrow><annotation encoding='application/x-tex'>b_j</annotation></semantics></math>, par exemple :<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">1/pi*int(f(x)*cos(4x),x,0,2.*pi); 2*re(G[4]/N);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>


<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">1/pi*int(f(x)*sin(5x),x,0,2.*pi); -2*im(G[5]/N);
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>

On observe en effet une très bonne concordance.</p><p>Bien entendu, cela n’est pas très utile pour approcher <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>e</mi> <mrow><mi>sin</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding='application/x-tex'>e^{\sin(x)}</annotation></semantics></math>
(il vaut mieux composer exponentielle et sinus), 
mais cela pourrait le devenir pour une
fonction périodique plus compliquée ou pour une fonction
périodique dont on ne connait qu’un échantillonage régulier
(par exemple un fichier numérique audio).</p>
<!--TOC section id="sec202" Quadratures gaussiennes.-->
<h2 id="sec202" class="section">20.9  Quadratures gaussiennes.</h2><!--SEC END --><p>
<a id="hevea_default233"></a><a id="hevea_default234"></a>
</p>
<!--TOC subsection id="sec203" Description-->
<h3 id="sec203" class="subsection">20.9.1  Description</h3><!--SEC END --><p>
On a vu que l’interpolation polynomiale était de meilleure
qualité en prenant les points de Tchebyshev plutot que
des points équidistants, il est donc naturel de calculer
des approximations d’intégrale de cette manière
ou encore d’optimiser le choix des abscisses pour avoir
une méthode d’intégration d’ordre maximal.</p><p>Si on se fixe <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> abscisses <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>1</mn></msub></mrow><annotation encoding='application/x-tex'>x_1</annotation></semantics></math> à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_n</annotation></semantics></math>, on peut obtenir l’ordre
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2n&#x2d;1</annotation></semantics></math>. En effet, considérons le polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo>=</mo><msubsup><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_n=\prod_{i=1}^n (x&#x2d;x_i)</annotation></semantics></math>,
qui est de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>, si la méthode est d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2n&#x2d;1</annotation></semantics></math> alors
il sera orthogonal à tous les polynômes de degré inférieur
strict à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> pour le produit scalaire 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>&lt;</mi><mi>f</mi><mo stretchy="false">&vert;</mo><mi>g</mi><mi>&gt;</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>&amp;lt;f|g&amp;gt;=\int_a^b f(x) g(x) \ dx </annotation></semantics></math>
puisque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&lt;</mi><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">&vert;</mo><msup><mi>x</mi> <mi>j</mi></msup><mi>&gt;</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><msub><mi>P</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>j</mi></msup></mrow><annotation encoding='application/x-tex'>&amp;lt;P_n|x^j&amp;gt;=\int_a^b P_n x^j </annotation></semantics></math> sera combinaison linéaire des
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>j</mi></msup></mrow><annotation encoding='application/x-tex'>P_n x^j</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub><mo>,</mo><mi>k</mi><mo>=</mo><mn>1</mn><mo>.</mo><mo>.</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>x_k, k=1..n</annotation></semantics></math> (car la formule d’intégration est exacte puisque le degré
du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><msup><mi>x</mi> <mi>j</mi></msup></mrow><annotation encoding='application/x-tex'>P_nx^j</annotation></semantics></math> est au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2n&#x2d;1</annotation></semantics></math>). Donc <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math> est à une constante
multiplicative près le <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math>-ième polynôme orthogonal pour
l’integrale sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math>, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]=[&#x2d;1,1]</annotation></semantics></math> c’est <code>legendre(n)</code>.
Réciproquement, si les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>x_k</annotation></semantics></math> sont les racines de ce polynôme,
alors la formule d’intégration est exacte, on effectue la division
euclidienne du polynôme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi></mrow><annotation encoding='application/x-tex'>P</annotation></semantics></math> de degré au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2n&#x2d;1</annotation></semantics></math> à
intégrer par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>P</mi><mo>=</mo><msub><mi>P</mi> <mi>n</mi></msub><mi>Q</mi><mo>+</mo><mi>R</mi><mo>,</mo><mspace width="1em"/><mtext>deg</mtext><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo><mo>&leq;</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>P= P_n Q + R , \quad \mbox{deg}(Q) \leq n&#x2d;1  </annotation></semantics></math>
On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><msub><mi>P</mi> <mi>n</mi></msub><mi>Q</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>\int_a^b P_n Q=0</annotation></semantics></math> par orthogonalité et la combinaison
linéaire correspondante en les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>x_k</annotation></semantics></math> est nulle, et on a exactiture
pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>R</mi></mrow><annotation encoding='application/x-tex'>R</annotation></semantics></math>, car de degré au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math>.</p><p>Exemple :
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">l:=proot(legendre(10)); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">f(x):=ln(1+x^2); int(f(x),x,-1.0,1.0); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">p:=interp(l,f); int(p,x,-1.0,1.0) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p>
<!--TOC subsection id="sec204" Calcul des poids-->
<h3 id="sec204" class="subsection">20.9.2  Calcul des poids</h3><!--SEC END --><p>
On peut calculer les poids en appliquant
la section <a href="#sec%3Apoids">20.5</a>. On peut ainsi montrer
que les poids sont positifs en appliquant la formule
d’intégration au polynôme
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mo lspace="thinmathspace" rspace="thinmathspace">&prod;</mo> <mrow><mi>j</mi><mo>&ne;</mo><mi>k</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\prod_{j\neq k}(x&#x2d;x_j)</annotation></semantics></math>
(la formule est exacte à cause du degré du polynome).
On peut d’ailleurs montrer que le poids <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>w_i</annotation></semantics></math> 
en une racine du polynôme de Legendre
sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math> est donné par :
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub><mo>=</mo><mfrac><mn>2</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msubsup><mi>x</mi> <mi>i</mi> <mn>2</mn></msubsup><mo stretchy="false">)</mo><mi>P</mi><msub><mo>&prime;</mo> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mo stretchy="false">(</mo><mn>1</mn><mo>&minus;</mo><msubsup><mi>x</mi> <mi>i</mi> <mn>2</mn></msubsup><mo stretchy="false">)</mo></mrow><mrow><msup><mi>n</mi> <mn>2</mn></msup><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mrow></mfrac><mo>=</mo><mfrac><mn>2</mn><mrow><mi>n</mi><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>P</mi> <mi>n</mi></msub><mo>&prime;</mo><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>w_i=\frac{2}{(1&#x2d;x_i^2)P&apos;_n(x_i)^2} = \frac{2(1&#x2d;x_i^2)}{n^2P_{n&#x2d;1}(x_i)^2}=\frac{2}{nP_{n&#x2d;1}(x_i)P_n&apos;(x_i)} </annotation></semantics></math>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">n:=10; P:=legendre(n); Q:=legendre(n-1); l:=proot(P); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">a:=inv(trn(vandermonde(l))):; a*seq((1+(-1)^j)/(j+1),j,0,n-1); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">seq(2/(1-l[j]^2)/P'(x=l[j])^2,j,0,n-1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">seq(2*(1-l[j]^2)/n^2/Q(x=l[j])^2,j,0,n-1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">seq(2/n/Q(x=l[j])/P'(x=l[j]),j,0,n-1) 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
Preuve de la dernière formule :<br>
On a <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>I</mi><mo stretchy="false">(</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>w</mi> <mi>i</mi></msub><mi>P</mi><msub><mo>&prime;</mo> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>I(P_n/(x&#x2d;x_i))=w_i P&apos;_n(x_i)</annotation></semantics></math> la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(P_n/(x&#x2d;x_i))</annotation></semantics></math>
en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math> est par définition de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>P</mi><msub><mo>&prime;</mo> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P&apos;_n(x_i)</annotation></semantics></math> la limite <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(P_n(x)&#x2d;P_n(x_i))/(x&#x2d;x_i)</annotation></semantics></math>
lorsque <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> tend vers <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>i</mi></msub></mrow><annotation encoding='application/x-tex'>x_i</annotation></semantics></math> (rappelons que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding='application/x-tex'>P_n(x_i)=0</annotation></semantics></math>).
Par exactitude de la formule d’intégration
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub><mi>P</mi><msub><mo>&prime;</mo> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><mfrac><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><msub><mi>P</mi> <mi>n</mi></msub><mfrac><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><msub><mi>P</mi> <mi>n</mi></msub><mfrac><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>w_i P&apos;_n(x_i)=\int_{&#x2d;1}^1 \frac{P_n}{x&#x2d;x_i} =
\frac1{P_{n&#x2d;1}(x_i)}\int_{&#x2d;1}^1 P_n \frac{P_{n&#x2d;1}(x_i)}{x&#x2d;x_i} 
= \frac1{P_{n&#x2d;1}(x_i)}\int_{&#x2d;1}^1 P_n \frac{P_{n&#x2d;1}(x)}{x&#x2d;x_i}  </annotation></semantics></math>
la dernière égalité résulte du fait que
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(P_{n&#x2d;1}(x)&#x2d;P_{n&#x2d;1}(x_i))/(x&#x2d;x_i)</annotation></semantics></math>
est un polynôme de degré au plus <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;2</annotation></semantics></math> donc orthogonal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>P_n</annotation></semantics></math>.
Donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub><mi>P</mi><msub><mo>&prime;</mo> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mfrac><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub></mrow></mfrac></mrow><annotation encoding='application/x-tex'>w_i P&apos;_n(x_i)=
= \frac1{P_{n&#x2d;1}(x_i)}\int_{&#x2d;1}^1 P_{n&#x2d;1} \frac{P_n(x)}{x&#x2d;x_i}  </annotation></semantics></math>
Or <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_n(x)/(x&#x2d;x_i)</annotation></semantics></math> est un polynôme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;1</annotation></semantics></math>, si on fait son
quotient par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P_{n&#x2d;1}</annotation></semantics></math> on obtient une constante qui vaut <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>a_{n&#x2d;1}</annotation></semantics></math> en
utilisant la relation de récurrence à 2 crans
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mi>x</mi><mo>&minus;</mo><msub><mi>b</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>&minus;</mo><msub><mi>c</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P_n=(a_{n&#x2d;1}x&#x2d;b_{n&#x2d;1})P_{n&#x2d;1}&#x2d;c_{n&#x2d;1}P_{n&#x2d;2}</annotation></semantics></math>. Le reste est de
degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>&minus;</mo><mn>2</mn></mrow><annotation encoding='application/x-tex'>n&#x2d;2</annotation></semantics></math> donc orthogonal à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>P_{n&#x2d;1}</annotation></semantics></math>, d’où
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>w</mi> <mi>i</mi></msub><mi>P</mi><msub><mo>&prime;</mo> <mi>n</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mfrac><mn>1</mn><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><msubsup><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow> <mn>2</mn></msubsup><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>w_i P&apos;_n(x_i)=
= \frac1{P_{n&#x2d;1}(x_i)}\int_{&#x2d;1}^1 P_{n&#x2d;1}^2 a_{n&#x2d;1}  </annotation></semantics></math>
On conclut en utilisant la valeur de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>a</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>a_{n&#x2d;1}=(2n&#x2d;1)/n</annotation></semantics></math> et de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&Vert;</mo><msub><mi>P</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><msup><mo stretchy="false">&Vert;</mo> <mn>2</mn></msup><mo>=</mo><mn>2</mn><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo>&minus;</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\| P_{n&#x2d;1}\|^2=2/(2(n&#x2d;1)+1)</annotation></semantics></math>.</p>
<!--TOC subsection id="sec205" Erreur d’une quadrature gaussienne-->
<h3 id="sec205" class="subsection">20.9.3  Erreur d’une quadrature gaussienne</h3><!--SEC END --><p>
On considère une quadrature gaussienne d’ordre <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>2n+1</annotation></semantics></math> obtenue
par interpolation aux <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math> racines du <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>-ième polynome de
Legendre sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math>.</p><p>Rappelons que le polynôme d’interpolation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> aux points
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,x_1,...,x_n</annotation></semantics></math> s’écrit
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_n(t)=f[x_0]+f[x_0,x_1](t&#x2d;x_0)+...+f[x_0,...,x_n](t&#x2d;x_0)...(t&#x2d;x_{n&#x2d;1}) </annotation></semantics></math>
Si on ajoute <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>x</mi></mrow><annotation encoding='application/x-tex'>x</annotation></semantics></math> on obtient un polynôme d’interpolation de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>P</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>t</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>P_{n+1}(t)=f[x_0]+f[x_0,x_1](t&#x2d;x_0)+...+f[x_0,...,x_n,x](t&#x2d;x_0)...(t&#x2d;x_{n&#x2d;1})(t&#x2d;x_n) </annotation></semantics></math>
qui coincide avec <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math> en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>t</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding='application/x-tex'>t=x</annotation></semantics></math> donc
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)=f[x_0]+f[x_0,x_1](x&#x2d;x_0)+...+f[x_0,...,x_n,x](x&#x2d;x_0)...(x&#x2d;x_{n&#x2d;1})(x&#x2d;x_n) </annotation></semantics></math>
Le même calcul fait avec un point <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_{n+1}</annotation></semantics></math> en plus donne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>f(x)=f[x_0]+f[x_0,x_1](x&#x2d;x_0)+...+f[x_0,...,x_n,x_{n+1}](x&#x2d;x_0)...(x&#x2d;x_{n&#x2d;1})(x&#x2d;x_n)
+ f[x_0,...,x_n,x_{n+1},x](x&#x2d;x_0)...(x&#x2d;x_{n&#x2d;1})(x&#x2d;x_n)(x&#x2d;x_{n+1}) </annotation></semantics></math>
On a donc montré la formule :
<a id="eqref_34"></a><math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mspace width="2em"/><mo stretchy="false">(</mo><mn>34</mn><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'> 
f[x_0,...,x_n,x]=f[x_0,...,x_n,x_{n+1}]+f[x_0,...,x_n,x_{n+1},x](x&#x2d;x_{n+1})
\qquad (34) </annotation></semantics></math>
mais en fait on va ajouter plus qu’un point, on va en ajouter <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mrow><mtable displaystyle="false" rowspacing="0.5ex"><mtr><mtd/> <mtd/> <mtd><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">]</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd/> <mtd><mo>=</mo></mtd> <mtd><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mn>2</mn><mi>n</mi></mrow></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding='application/x-tex'> \begin{matrix}
&amp; &amp;f(x)&#x2d;(f[x_0]+f[x_0,x_1](x&#x2d;x_0)+...+f[x_0,...,x_n](x&#x2d;x_0)...(x&#x2d;x_{n&#x2d;1})
)\\
&amp;=&amp;f[x_0,...,x_n,x_{n+1}](x&#x2d;x_0)...(x&#x2d;x_{n&#x2d;1})(x&#x2d;x_n) +...+f[x_0,...,x_{2n+1}](x&#x2d;x_0)...(x&#x2d;x_{2n})
+ f[x_0,...,x_{2n+1},x](x&#x2d;x_0)...(x&#x2d;x_{2n+1})
 \end{matrix} </annotation></semantics></math>
puis on intègre sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[&#x2d;1,1]</annotation></semantics></math>, on obtient à gauche l’erreur et à
droite, seul le dernier terme est non nul, car le polynôme de Legendre
proportionnel à <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>&minus;</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(x&#x2d;x_0)...(x&#x2d;x_{n&#x2d;1})(x&#x2d;x_n) </annotation></semantics></math>, de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>,
est orthogonal à tous les polynôme de degré <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo>&leq;</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>\leq n</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo>=</mo><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>\int_{&#x2d;1}^1 (f(x) &#x2d;P_n(x)) \ dx = \int_{&#x2d;1}^1
f[x_0,...,x_{2n+1},x](x&#x2d;x_0)...(x&#x2d;x_{2n+1}) \ dx  </annotation></semantics></math>
D’autre part, le résultat sur l’erreur d’interpolation <a href="#eqref_49">49</a> donne
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mfrac><mrow><msup><mi>f</mi> <mrow><mo stretchy="false">[</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><msub><mi>&xi;</mi> <mi>x</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac></mrow><annotation encoding='application/x-tex'>f[x_0,...,x_n,x]=\frac{f^{[n+1]}(\xi_x)}{(n+1)!} </annotation></semantics></math>
en particulier <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">&vert;</mo><mi>f</mi><mo stretchy="false">[</mo><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo>,</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">&vert;</mo><mo>&leq;</mo><msub><mi>M</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">/</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>!</mo></mrow><annotation encoding='application/x-tex'>|f[x_0,...,x_n,x]| \leq M_{n+1}/(n+1)!</annotation></semantics></math>
D’où la majoration
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><msub><mi>M</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><mo stretchy="false">&vert;</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mn>0</mn></msub><mo stretchy="false">)</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo stretchy="false">(</mo><mi>x</mi><mo>&minus;</mo><msub><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">&vert;</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>|  \int_{&#x2d;1}^1 (f(x) &#x2d;P_n(x)) \ dx | \leq \frac{M_{2n+2}}{(2n+2)!}
\int_{&#x2d;1}^1|(x&#x2d;x_0)...(x&#x2d;x_{2n+1})| \ dx  </annotation></semantics></math>
Il suffit ensuite de faire tendre les <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>x_{n+1},...,x_{2n+1}</annotation></semantics></math> vers
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mn>0</mn></msub><mo>,</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub></mrow><annotation encoding='application/x-tex'>x_0,...,x_n</annotation></semantics></math> pour enlever la valeur absolue et obtenir
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mo stretchy="false">&vert;</mo><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&minus;</mo><msub><mi>P</mi> <mi>n</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo stretchy="false">&vert;</mo><mo>&leq;</mo><mfrac><mrow><msub><mi>M</mi> <mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>!</mo></mrow></mfrac><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><msubsup><mi>L</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow> <mn>2</mn></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi></mrow><annotation encoding='application/x-tex'>|  \int_{&#x2d;1}^1 (f(x) &#x2d;P_n(x)) \ dx | \leq \frac{M_{2n+2}}{(2n+2)!}
 \int_{&#x2d;1}^1 L_{n+1}^2(x) \ dx  </annotation></semantics></math> 
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding='application/x-tex'>L_{n+1}</annotation></semantics></math> est proportionnel au <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n+1</annotation></semantics></math>-ième polynôme de
Legendre de coefficient dominant 1.</p><p>Par exemple, pour <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n=1</annotation></semantics></math>, on a 2 points d’interpolation en les racines
de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>L</mi> <mn>2</mn></msub><mo>=</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>3</mn></mrow><annotation encoding='application/x-tex'>L_2=x^2&#x2d;1/3</annotation></semantics></math> et l’erreur d’interpolation
est majorée par <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>M</mi> <mn>4</mn></msub><mo stretchy="false">/</mo><mn>24</mn><msubsup><mo>&Integral;</mo> <mrow><mo lspace="verythinmathspace" rspace="0em">&minus;</mo><mn>1</mn></mrow> <mn>1</mn></msubsup><mo stretchy="false">(</mo><msup><mi>x</mi> <mn>2</mn></msup><mo>&minus;</mo><mn>1</mn><mo stretchy="false">/</mo><mn>3</mn><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>x</mi><mo>=</mo><msub><mi>M</mi> <mn>4</mn></msub><mo stretchy="false">/</mo><mn>24</mn><mo>&times;</mo><mn>8</mn><mo stretchy="false">/</mo><mn>45</mn><mo>=</mo><msub><mi>M</mi> <mn>4</mn></msub><mo stretchy="false">/</mo><mn>135</mn></mrow><annotation encoding='application/x-tex'>M_4/24\int_{&#x2d;1}^1(x^2&#x2d;1/3) \ dx=M_4/24 \times 8/45=M_4/135</annotation></semantics></math>.</p>
<!--TOC section id="sec206" Méthode adaptative.-->
<h2 id="sec206" class="section">20.10  Méthode adaptative.</h2><!--SEC END --><p>
On calcule une valeur approchée de l’intégrale sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math> par
deux quadratures gaussiennes emboitées, on estime l’erreur,
si elle est supérieure à la tolérance on divise en 2. On
recommence en subdivisant en 2 l’intervalle où l’erreur est
maximale. On s’arrête lorsque l’erreur estimée est inférieure
à la tolérance.</p><p>L’estimation de l’erreur se fait par exemple avec deux quadratures
gaussiennes emboitées (c’est-à-dire que les points d’interpolation
de la moins fine sont contenues dans les points d’interpolation de la
plus fine, pour éviter de devoir calculer la fonction en de nouveaux
points, on considére alors l’erreur sur la quadrature la moins fine
comme la valeur absolue de la différence des deux valeurs). Ou avec
trois quadratures emboitées,
Hairer propose de prendre comme quadrature la plus fine en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>30</mn></msup></mrow><annotation encoding='application/x-tex'>h^{30}</annotation></semantics></math>
(15 points), intermédiaire en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>14</mn></msup></mrow><annotation encoding='application/x-tex'>h^{14}</annotation></semantics></math> (avec les mêmes points
sauf le point central), moins fine en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>6</mn></msup></mrow><annotation encoding='application/x-tex'>h^6</annotation></semantics></math> (avec les points 1, 3, 5,
9, 11, 13), et d’estimer l’erreur par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msub><mi>&epsi;</mi> <mn>1</mn></msub><mo>=</mo><mo stretchy="false">&vert;</mo><msub><mi>I</mi> <mn>30</mn></msub><mo>&minus;</mo><msub><mi>I</mi> <mn>14</mn></msub><mo stretchy="false">&vert;</mo><mo>,</mo><msub><mi>&epsi;</mi> <mn>2</mn></msub><mo>=</mo><mo stretchy="false">&vert;</mo><msub><mi>I</mi> <mn>30</mn></msub><mo>&minus;</mo><msub><mi>I</mi> <mn>6</mn></msub><mo stretchy="false">&vert;</mo><mo>;</mo><mi>&epsi;</mi><mo>=</mo><msub><mi>&epsi;</mi> <mn>1</mn></msub><msup><mrow><mo>(</mo><mfrac><mrow><msub><mi>&epsi;</mi> <mn>1</mn></msub></mrow><mrow><msub><mi>&epsi;</mi> <mn>2</mn></msub></mrow></mfrac><mo>)</mo></mrow> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\epsilon_1=| I_{30}&#x2d;I_{14}|,  \epsilon_2=| I_{30}&#x2d;I_{6}|; 
\epsilon = \epsilon_1 \left(\frac{\epsilon_1}{\epsilon_2} \right)^2  </annotation></semantics></math>
On observe en effet que <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&epsi;</mi></mrow><annotation encoding='application/x-tex'>\epsilon</annotation></semantics></math> est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msup><mi>h</mi> <mn>30</mn></msup></mrow><annotation encoding='application/x-tex'>h^{30}</annotation></semantics></math>, comme
l’ordre de la méthode.</p>
<!--TOC section id="sec207" Méthodes probabilistes.-->
<h2 id="sec207" class="section">20.11  Méthodes probabilistes.</h2><!--SEC END --><p> <a id="hevea_default235"></a>
Pour déterminer <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi></mrow><annotation encoding='application/x-tex'>\int_a^b f(t) \ dt </annotation></semantics></math>, on l’interprète comme
une espérance, plus précisément comme <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mi>E</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>(b&#x2d;a)E(f(X))</annotation></semantics></math> 
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>X</mi></mrow><annotation encoding='application/x-tex'>X</annotation></semantics></math> est une variable aléatoire
qui suit la loi uniforme sur <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding='application/x-tex'>[a,b]</annotation></semantics></math>, et on approche cette valeur
par 
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><mfrac><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><mi>n</mi></mfrac><munderover><mo lspace="thinmathspace" rspace="thinmathspace">&Sum;</mo> <mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow> <mi>n</mi></munderover><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi> <mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding='application/x-tex'>\frac{b&#x2d;a}{n} \sum_{k=1}^n f(x_k)  </annotation></semantics></math>
où <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><msub><mi>x</mi> <mi>k</mi></msub></mrow><annotation encoding='application/x-tex'>x_k</annotation></semantics></math> est obtenu par un générateur pseudo-aléatoire
(selon la loi uniforme).
Par exemple<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">f(t):=exp(-t^2); n:=1000; a:=0; b:=2.0;l:=ranv(n,uniformd,a,b):; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">(b-a)*sum(apply(f,l))/n; int(f(t),t,a,b); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
La convergence en fonction de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est assez lente, on peut l’observer
en faisant plusieurs estimations :<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">m:=ranm(500,n,uniformd,a,b):;I:=seq(2*sum(apply(f,m[k]))/n,k,0,size(m)-1); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:400px;font-size:large">histogram(I,0,0.01)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>En effet, les tirages sont équidistribués selon la même loi,
la loi des grands nombres s’applique donc : on fait <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow><annotation encoding='application/x-tex'>b&#x2d;a</annotation></semantics></math> fois
une moyenne de
<math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> tirages, si <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math> est grand, on converge vers une loi normale
dont l’écart-type est en <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>&minus;</mo><mi>a</mi><mo stretchy="false">)</mo><mi>&sigma;</mi><mo stretchy="false">/</mo><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>(b&#x2d;a)\sigma/\sqrt{n}</annotation></semantics></math>.
La valeur de la constante <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&sigma;</mi></mrow><annotation encoding='application/x-tex'>\sigma</annotation></semantics></math>
peut se calculer à partir de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math>
<math xmlns='http://www.w3.org/1998/Math/MathML' display='block'><semantics><mrow><msup><mi>&sigma;</mi> <mn>2</mn></msup><mo>=</mo><mfrac><mn>1</mn><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow></mfrac><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><msup><mi>f</mi> <mn>2</mn></msup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>&minus;</mo><msup><mrow><mo>(</mo><mfrac><mn>1</mn><mrow><mi>b</mi><mo>&minus;</mo><mi>a</mi></mrow></mfrac><msubsup><mo>&Integral;</mo> <mi>a</mi> <mi>b</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mspace width="mediummathspace"/><mi>d</mi><mi>t</mi><mo>)</mo></mrow> <mn>2</mn></msup></mrow><annotation encoding='application/x-tex'>\sigma^2 = \frac{1}{b&#x2d;a}\int_a^b f^2(t) \ dt &#x2d;
\left( \frac{1}{b&#x2d;a}\int_a^b f(t) \ dt  \right)^2  </annotation></semantics></math>
par exemple ici<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">2*sqrt(int(f(t)^2,t,0,2.)/2-(1/2*int(f(t),t,0,2.))^2)/sqrt(n); stddevp(I); 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
mais on ne fait pas ce calcul en pratique
(puisqu’il faudrait calculer une intégrale), on estime
l’écart-type <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&sigma;</mi><mo stretchy="false">/</mo><msqrt><mi>n</mi></msqrt></mrow><annotation encoding='application/x-tex'>\sigma/\sqrt{n}</annotation></semantics></math> de la loi normale par
l’écart-type de l’échantillon des estimations <code>stddevp(I)</code>.<br>

<textarea onkeypress="UI.ckenter(event,this,1)" 
style="width:800px;font-size:large">histogram(I,0,0.01); plot(normald(mean(I),stddevp(I),x),x=0.8..1)
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value);tmp=UI.rmquote(tmp); nextSibling.innerHTML='&nbsp;'+tmp;UI.render_canvas(nextSibling);">ok</button><span></span><br>
</p><p>On peut donc obtenir rapidement une estimation de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>&sigma;</mi></mrow><annotation encoding='application/x-tex'>\sigma</annotation></semantics></math> en prenant
l’écart-type d’une séquence de valeurs de <math xmlns='http://www.w3.org/1998/Math/MathML' display='inline'><semantics><mrow><mi>f</mi></mrow><annotation encoding='application/x-tex'>f</annotation></semantics></math><br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">f(t):=exp(-t^2); n:=1000; a:=0; b:=2.0;l:=ranv(n,uniformd,a,b):; 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
<br>
<div><textarea onkeypress="UI.ckenter(event,this,2)" 
style="width:800px;font-size:large">fl:=apply(f,l):;m:=(b-a)*mean(fl);s:=(b-a)*stddevp(fl)/sqrt(n);[m-2s,m+2s] 
</textarea><button onclick="previousSibling.style.display='inherit';var tmp=UI.caseval(previousSibling.value); tmp=UI.latexeval(tmp);nextSibling.innerHTML=tmp; if (UI.usemathjax) MathJax.Hub.Queue(['Typeset',MathJax.Hub,nextSibling])">ok</button><div style="width:800px;max-height:200px;overflow:auto;color:blue;text-align:center"></div></div>
</p><p>Cette méthode converge donc beaucoup moins vite que les quadratures,
en dimension 1. Mais elle se généralise très facilement en
dimension plus grande en conservant la même vitesse de convergence
alors que le travail nécessaire pour une méthode de quadrature
croit comme une puissance de la dimension, et ne nécessite pas
de paramétrer des domaines d’intégration compliqués (il suffit
par exemple d’utiliser la méthode du rejet pour avoir un
générateur uniforme
dans un domaine inclus dans un cube).</p>
<!--TOC chapter id="sec208" Suites récurrentes et applications-->
</html>
